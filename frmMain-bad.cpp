//---------------------------------------------------------------------------
// 2022 9 6 - chc
// 1. TMemo要固定要清除, 否則速度會變慢! 370改成320
// 2. 加入雙片作業
// 3. Get/Put加入檢查是否有Wafer在Fork上面
// 4. 處理APos/Pos "X"問題
// 5. DFK 33GX264e
//    2,448×2,048 (5 MP), 24fps, 8-Bit Bayer (RG), 12-Bit Bayer Packed (RG),
//    16-Bit Bayer (RG), YUV 4:2:2, YUV 4:1:1, RGB24, 水平: 3.45 ?m, 垂直: 3.45 ?m
//
// 2022 9 12 - chc
// 1. Robot是否有片DI: 延長到4秒(原2秒)
// 2022 9 12a - chc
// 2. GetNextNo()寫錯! 用slotno
//
// 2022 9 14a - chc
// tmChuckMeasure/tmMacroDemo: Interval from 100 to 500
// 2022 9 22a - chc
// 2. WaitTimeChuck()/WaitTimeMacro()/WaitTime()中不做ProcessMessages看看,
//    UpdateMotionStatus()中會做2次=>降只做1次
//
// 2022 11 25 - chc
// 1. ICS後不用再試Basler
//
// StartVel
// 23h (35) PRA_VS Start velocity Unit: pulse/sec 100
// I32 APS_set_axis_param( I32 Axis_ID, I32 AXS_Param_No, I32 AXS_Param );
//
// 2022 12 5 - chc
// 1. Screen要有:
//    a. 顯示Auto/Manual: Recipe run為Auto, 餘為Manual
//    b. PWD等級: 要明顯
//    c. Reset
//    d. Alarm Message
//    e. History Record
//    f. Parameter Setting
//    g. Software Version
// 2. 登錄權線/手動等危險操作: 限2階以上人員可操作
// 3. 校正/Password switch: 限3階以上人員可操作
// 4. 安全迴路的軟體斷路功能(測試時將硬體短路)
//    => X
// 5. 復位後不會造成任何動作的啟動
//    => EMO/Light: button(OK) - Button(Reset-Blue) - Operation
// 6. 參數具上下限設定
// 7. 開機時: 三色燈與蜂鳴器能自動測試或具測試鍵
//    => ok
// 8. 斷電後再次開機: 錯誤與警報訊息不會被清除

// 9. 按鍵(SoftKey)顏色要符合法規定義: 停止-紅色, 啟動-綠色, 復位-藍色)
//    => ok
// 10. Alarm Message: 保留3個
// 11. Error List(Reserve 100條): Date/Time/Code/Message/Reset Time
// 12. Reset(光柵)LP ID3 Bit5(On-侵入, Off-非侵入): 要先ORG Aligner/LP/Robot才能操作
//     => On: Stage XYZW要停止, Aligner要Stop
//     => On: LP/Robot斷電: 要由RS232重開始做
//     => On -> Off時作業
// 13. 非OP: 15分(可設定)後強制設為OP
// 14. OP: 只可以Recipe Switch / Start餘不可以操作
// 15: UI
//
// 2022 12 26 - chc
// 1. LoadWafer: Demo? / Inverse
// 2. UnLoadWafer: Aligner?
// 3. Double Wafer
// 4. 3 CCD不要同時動
// 5. 加入RFID - 矽品
// 6. Pattern Match
// 7. Recipe Operation
// 8. Flow by Recipe
//
// 2023 1 4 - chc
// 1. PRP會改變角度！Aligner流程修正為：[HOM, PRP]放片, ALG,3, 讀QRCode, PRP, ALG,5, 取片。無法避免要做兩次notch的尋找。
// 2023 1 5 - chc
// Load .txt
// 1. Micro Recipe: WaferMap/CCD/Shtter/BXFM/Motion Move/Base Pattern*2/Die Pattern/Point List/Lens/Observation
//    --- 同Inspection Form
// 2. WaferMap: DoubleClick Move to die
//
// 1. tazmo @@@@
// 2. Macro翻面
//
//
//
//
//
//
// 4. STD Pattern Move Slow
//
// DFK 33GX264e
// 2,448×2,048 (5 MP), 24fps, 8-Bit Bayer (RG), 12-Bit Bayer Packed (RG), 16-Bit Bayer (RG), YUV 4:2:2, YUV 4:1:1,
// RGB24, 水平: 3.45 ?m, 垂直: 3.45 ?m
//
//
#include <vcl.h>
#pragma hdrstop

#include "frmMain.h"

// 2022 6 16a - chc 不應該有, 否則下面第一個Include會Error
//#include "Motion.h"

// .ini
// 2022 6 6a - chc  不需要
//#include <inifiles.hpp>

// Euresys eVision
// 2022 6 16a - chc .h內有定義, 這裡不用
//#include "easy.h"
//#include "emulticam.h"

//#include "LicenseCode.h"

// AutoFocus
#include "AutoFocus.h"
//void __fastcall AutoFocus();
//void __fastcall LoadFocusParameter();

// Socket
#include "Socket.h"
extern bool boolInSocketRead;

// 2022 8 5 - chc Logo Form
#include "LogoFrm.h"

// 2022 8 30 - chc 加入Recipe/Inspection form
#include "InspectionForm.h"
#include "RecipeForm.h"
#include "MaintenanceForm.h"
#include "SystemLogForm.h"
#include "RecipeSetForm.h"

// 2022 9 2 - chc 量測點位
extern int MeasurePointNo;

//---------------------------------------------------------------------------
// 2022 7 6 - chc Robot
unsigned char RobotBuffer[500];
int RobotBufferLength = 0;
AnsiString ReplyStrRobot = "";
#define STX             0x02
#define ETX             0x03
// Send: STX-001- LR-ETX-LRC
// Recv: STX-001 X Y Z W-L-0x0-ETX-LRC
// Recv: STX-001 E-Status-ETX-LRC
#define ROBOT_CMD_NONE          0
#define ROBOT_CMD_LR            1
#define ROBOT_CMD_GP            2
#define ROBOT_CMD_LS            3
#define ROBOT_CMD_VACUUM        4

// 2022 12 19 - chc Tazmo
#define ROBOT_CMD_RST           5
#define ROBOT_CMD_GET           6
#define ROBOT_CMD_PUT           7
#define ROBOT_CMD_MTP           8

int RobotCmd = ROBOT_CMD_NONE;
#define ROBOT_CMD_STATE_NONE            0
#define ROBOT_CMD_STATE_SENT            1                                       // 4401
#define ROBOT_CMD_STATE_DONE            2                                       // 0601
#define ROBOT_CMD_STATE_TIMEOUT         3

// 2022 9 12a - chc 已收到4401
#define ROBOT_CMD_STATE_4401_LS         4                                       // 4401

// 2022 9 14a - chc 已收到0601
#define ROBOT_CMD_STATE_0601_LS         5                                       // 0601

int RobotCmdState = ROBOT_CMD_STATE_NONE;
unsigned char RobotStatus[12];                                                   // 4401 or 0601
bool boolRobotLRCommand = false;
int RobotXPosition;
// Set Mapping Status
bool boolMappingStatus = false;
unsigned char CassetteBuffer[25];
unsigned char LoadPortStatus[20];
unsigned char AlignerStatus[15];
unsigned char LoadPortLED[8];
unsigned char Aligner2Status[15];

// 2022 7 10 - chc LoadPort2
bool boolMappingStatus2 = false;
unsigned char CassetteBuffer2[25];
unsigned char LoadPort2Status[20];
unsigned char LoadPort2LED[8];

//---------------------------------------------------------------------------
// 2022 6 16 - chc NCC
#include "iMatchDLL\iVisionErrs.h"
#include "iMatchDLL\iVision_Types.h"
#include "iMatchDLL\iVision.h"
#include "iMatchDLL\iImage.h"
#include "iMatchDLL\iMatch.h"
LONG_PTR ColorImg,ColorLearnImg,GrayImg,GrayLearnImg;
LONG_PTR iMatchModel;

//----------------------------------------------------------------------------
// Basler
// 2022 7 19 - chc Basler Pylon
//-Basler acA1300 Thread--------------------------------------------------------
#include "scA1300Thread.h"
TscA1300 *scA1300Thread = NULL;
// scA1300-gm
#include <pylonc/PylonC.h>
#define CHECK( errc ) if ( GENAPI_E_OK != errc ) ErrorAndExit( errc )
GENAPIC_RESULT          res;                    // Return value of pylon methods.

//size_t                  numDevices;             // Number of available devices.
unsigned int                  numDevices;             // Number of available devices.

PYLON_DEVICE_HANDLE     hDevscA1300;            // Handle for the pylon device.
PYLON_DEVICE_HANDLE     hDevacA2040;            // Handle for the pylon device.
const int               numGrabs = 10;          // Number of images to grab.
int32_t                 payloadSize;            // Size of an image frame in bytes.
unsigned char*          imgBuf;                 // Buffer used for grabbing.
//unsigned char*          imgBuf[3];            // Buffer used for grabbing.
_Bool                   isAvail;
//調色盤變數
#include <Graphics.hpp>
bool mcolor;
Graphics::TBitmap *pBitmap;
typedef struct {
   TLogPalette lpal;
   TPaletteEntry dummy[256];
} LogPal;
// Stream Grabber Handle/Object
PYLON_STREAMGRABBER_HANDLE hStg;
PYLON_WAITOBJECT_HANDLE    hWobj;
// GigE CCD : scA1300
bool bool_scA1300_Status;
PylonGrabResult_t grabResult;
_Bool bufferReady;

//bool boolInGigaBuffer = false;
// 不同CCD對應不同的程式碼
//bool boolInGigaBufferAry[3] = {false};
//unsigned char*          imgBufAry[3];                                           // Buffer used for grabbing.
//int CCDSelectNo = -1;
//unsigned long GigaWidth,GigaHeight,AlignWidth,AlignHeight;

PylonGrabResult_t grabResultAry[3];
_Bool bufferReadyAry[3];
PYLON_DEVICE_HANDLE     hDevGigaAry[3];                                         // Handle for the pylon device.
struct CCDINFO_STRU        {
   int Width,Height;
   int No;
   int PixelSize;
   int Type;
   int TotalSize;
   AnsiString Name;
   AnsiString DeviceID;
};
struct CCDINFO_STRU        CCDInfoAry[3];
TscA1300 *scA1300ThreadAry[3] = {NULL};
bool bool_scA1300_StatusAry[3];
//----------------------------------------------------------------------------

//---------------------------------------------------------------------------
#pragma package(smart_init)
#pragma link "LMDButton"
#pragma link "LMDControl"
#pragma link "LMDCustomBevelPanel"
#pragma link "LMDCustomButton"
#pragma link "LMDCustomControl"
#pragma link "LMDCustomGroupBox"
#pragma link "LMDCustomPanel"
#pragma link "LMDCustomPanelFill"
#pragma link "LMDCustomParentPanel"
#pragma link "LMDCustomSheetControl"
#pragma link "LMDGroupBox"
#pragma link "LMDPageControl"
#pragma link "LMDCustomButtonGroup"
#pragma link "LMDCustomRadioGroup"
#pragma link "LMDRadioGroup"
#pragma link "ICImagingControl3_OCX"
#pragma link "LMDBaseEdit"
#pragma link "LMDButtonControl"
#pragma link "LMDCheckBox"
#pragma link "LMDCustomCheckBox"
#pragma link "LMDCustomEdit"
#pragma link "LMDCustomTrackBar"
#pragma link "LMDEdit"
#pragma link "LMDTrackBar"
#pragma link "YbCommDevice"
#pragma link "LMDComboBox"
#pragma link "LMDCustomComboBox"
#pragma link "LMDThemedComboBox"
#pragma link "LMDBaseControl"
#pragma link "LMDBaseGraphicControl"
#pragma link "LMDBaseMeter"
#pragma link "LMDCustomProgress"
#pragma link "LMDGraphicControl"
#pragma link "LMDProgress"
#pragma link "LMDPNGImage"
#pragma resource "*.dfm"
TfrnMain *frnMain;

//==============================================================================
// 2021 9 10 - chc
// 1. 設定是否有平邊, 找不到平邊則直接宣告失敗(不再轉380度)
// 2. 角度過大要宣告為Fail
// 3. 目前DO0尚無法直接控制Relay, 故無法控制真空On/Off
//
// 2022 7 14 - chc
// 1. @@@ 暫不做 : tmActiveSocketTimer
//
//
//
//
//
//
//==============================================================================
// GigE CCD : scA1300 or IC
bool boolInGigaBuffer = false;
// 不同CCD對應不同的程式碼
bool boolInGigaBufferAry[3] = {false};
unsigned char*          imgBufAry[3];                                           // Buffer used for grabbing.
// 2022 6 6a - chc 給AutoFocus.cpp用
//struct CCDINFO_STRU        {
//   int Width,Height;
//   int No;
//   int PixelSize;
//   int Type;
//   int TotalSize;
//   AnsiString Name;
//   AnsiString DeviceID;
//};
//struct CCDINFO_STRU        CCDInfoAry[3];
// 記錄Basler存檔中...
bool boolInGigaSaveAry[3];
int BaslerCaptureNoAry[3];
bool bool_CCD_StatusAry[3] = {false, false, false};
bool boolBaslerImageLoadedAry[3];
long BaslerStartTimeAry[3],BaslerStopTimeAry[3],BaslerElapsedmsAry[3];
short BaslerStartTickAry[3],BaslerStopTickAry[3];
int CCDSelectNo = -1;
unsigned long GigaWidth,GigaHeight,AlignWidth,AlignHeight;
//#define CCD_BW                0
//#define CCD_COLOR             1
int CCDShutterAry[3],CCDGainAry[3],CCDGrayAry[3],CCDContrastAry[3];
bool boolCCDImageLoadedAry[3];
bool CCDWBAuto[3];
//==============================================================================

// Motion - 使用APS
bool bool_APS_Status;
I32 BoardID, BoardName, BoardHSL, BoardMNET;
I32 Board7856;
I32 StartAxisNo, FirstAxisNo, TotalAxisNo;
I32 StartAxisNo2, FirstAxisNo2, TotalAxisNo2;
char MNET_BUS, HSL_BUS;
// PCI-7856 + IO Board(ID=1)
// I/O Module 1, 3
bool bool_IO_Status = false;

// IO1: 1, 16in/16out
// IO2: 3, 16in/16out
// IO3: 5, 32out
I32 IO1_ID = 1;
I32 IO2_ID = 3;
I32 IO3_ID = 5;

bool HSL_DI_InStatus1[32];
bool HSL_DI_InStatus2[32];
bool HSL_DI_InStatus3[32];

bool HSL_DO_OutStatus1[32];
bool HSL_DO_OutStatus2[32];
bool HSL_DO_OutStatus3[32];

I32 input_DI1 = 0;
I32 input_DI2 = 0;
I32 input_DI3 = 0;

I32 DOValue1 = 0;
I32 DOValue2 = 0;
I32 DOValue3 = 0;

// Motion Status
bool boolMotion,boolDI,boolDO;

void __fastcall InitMotion();
void __fastcall UpdateMotionStatus();
// 後退: 要判定Limit問題
void __fastcall MoveBackward();
void __fastcall DelayTime(int no);                                              // 測試作業使用 - Sleep(1)
// 設定DelayTime
#define HOST_SLEEP_TIME                 0
// Aligner
bool __fastcall WaitMotionDoneCCD(int axisno, int ms);
// 要先記住目前T位置
I32 AlignTPositionTemp,AlignTPosition;
void __fastcall GetAxisName(int axisno);

// ToPosition
void __fastcall ToCenterPosition();
void __fastcall To45Position(int mode);
void __fastcall ToR45Position(int mode);
void __fastcall To0Position(int mode);
void __fastcall ToLoadPosition();
void __fastcall ToOriginalPosition();
void __fastcall ToCCDPosition();
void __fastcall SetCenterPosition();
void __fastcall Set45Position();
void __fastcall SetR45Position();
void __fastcall Set0Position();
void __fastcall SetLoadPosition();
void __fastcall SetOriginalPosition();
void __fastcall SetCCDPosition();
void __fastcall SetUserPosition(int no);
void __fastcall ToUserPosition(int no);
void __fastcall SetSaveRange(int mode);
bool __fastcall MoveToXYRatio(int xpos,int ypos, double ratio);
bool __fastcall MoveToXY(int xpos,int ypos);
void __fastcall AxisMove(int mode, int type);
// Utility
void __fastcall AllHome();
void __fastcall MoveForward();
void __fastcall MoveBackward();
void __fastcall SetAlmOn();
void __fastcall SetAlmOff();
void __fastcall SetServoOn();
void __fastcall SetServoOff();
void __fastcall StopOneAxis(int axisno);
void __fastcall HomeOneAxis();
void __fastcall StopAxis(int axisno);
bool __fastcall MoveAbsolute(int axisno);
void __fastcall InitDO();
void __fastcall WriteDO(int idno);
void __fastcall GetAxisData(int axisno,int *dist,int *startvel,int *maxvel,F64 *tacc,F64 *tdec,int *homevel, int *reviewvel, int* uplimit, int *lowdistance);
void __fastcall Beep(int mstime);
void __fastcall BeepStop();
void __fastcall DoAxisTrMove(int axisno, int pos, int startvel, int maxvel, F64 tacc, F64 tdec);
void __fastcall GetPosition(int axisno, I32 *pos);
bool __fastcall MoveToY(int position);
bool __fastcall MoveToX(int position);
void __fastcall StopAllAxis();
void __fastcall SetLensPosition(int no);
void __fastcall ToLensPosition(int no);
void __fastcall SetLensZLimit(int no);
void __fastcall SetRedLamp(bool mode);
void __fastcall SetGreenLamp(bool mode);
void __fastcall SetYellowLamp(bool mode);
void __fastcall SetBlueLamp(bool mode);
void __fastcall SetRingLamp(bool mode);

// Macro
bool __fastcall MacroOuterTCW();

// 2022 9 15 - chc 可分是否檢查?
//bool __fastcall MacroOuterTCCW();
bool __fastcall MacroOuterTCCW(bool mode);

bool __fastcall MacroOuterTRelease();
bool __fastcall MacroInnerYMove();
bool __fastcall MacroInnerYBack();
bool __fastcall MacroInnerYBackForce();
bool __fastcall MacroInnerYRelease();
bool __fastcall MacroInnerXMove();
bool __fastcall MacroInnerXBack();
bool __fastcall MacroInnerXRelease();
bool __fastcall MacroInnerTMove();
bool __fastcall MacroInnerTBack();
bool __fastcall MacroInnerTRelease();

I32 __fastcall GetDI(int id);

void __fastcall ToWPositionFun(int no);
void __fastcall SetWPosition(int no);

// 2022 12 5 - chc 測試Signal Tower: R/Y/G/B/Buzzer
void __fastcall TestSignalTower();

// 2022 6 16 - chc Joystick停止時還要檢查其它軸
// 用Joystick
#include "Joystick.h"

#include "LicenseCode.h"


//==============================================================================
// Table標示範圍: Motion CCD
int Tx1 = -405201;
int Ty1 = 214318;
int Tx2 = 4527086;
int Ty2 = 6126607;

// Table標示範圍: Bruker CCD
int Vx1 = 649921;
int Vy1 = 308814;
int Vx2 = 5367962;
int Vy2 = 6088443;

int iBoxWidth,iBoxHeight;
bool boolFormshow = false;

// EMO
bool boolInEMO = false;
//---------------------------------------------------------------------------
__fastcall TfrnMain::TfrnMain(TComponent* Owner)
        : TForm(Owner)
{
}
//---------------------------------------------------------------------------
// 2022 8 15 - chc 分段啟動
bool boolFormShowDone = false;

void __fastcall TfrnMain::FormShow(TObject *Sender)
{
AnsiString CheckDir;
char CurrentDir[256];
AnsiString temp;

// 2022 8 15 - chc 分段啟動
static int step = 0;

   //2022 12 22 - chc Tazmo
   // By Parameter
   //RobotMode = ROBOT_MODE_TAZMO;
   //pnlAligner2->Visible = true;

   pnlEFEM->Left = 3;
   pnlEFEM->Top = 2;
   pnlEFEM->Height = 982;
   pnlMoving->Left = 528;
   pnlMoving->Top = 53;
   MainImageFactor = 0.28;

   // Set Flag
   boolInInspecting = false;

   // 2022 9 4 - chc 已進入formshow
   if(boolFormshow == true && step >= 2)
      return;

   step++;
   if(step > 1)
      goto step2;

   // 2022 7 15 - chc Measure
   MeasureState = 0;
   Mx1 = My1 = Mx2 = My2 = -1;

   // 2022 7 25 - chc 已進入formshow
   boolFormshow = true;

   // 2022 8 10 - chc 定義Status
   boolCSTWithoutWafer = false;
   boolChuckWithoutWafer = false;
   boolAlignerWithoutWafer = false;
   boolCSTWithWafer = false;
   boolChuckWithWaferError = false;
   boolAlignerWithWafer = false;
   boolWaferNotSpecified = false;

   // 到入料點/原點用最高速
   boolUseMaxSpeed = false;
   for(int i=0 ; i<3 ; i++)
      boolInGigaSaveAry[i] = false;
   // 重新定義硬體異常
   InitAlarmStatus();
   boolHomeDone = false;
   boolDoorEMO = false;

   // Aligner Status
   boolInSocketRead = false;

   GetCurrentDirectory(sizeof(CurrentDir),CurrentDir);
   SystemDirectory = AnsiString(CurrentDir);
   Sleep(100);

   BitmapDirectory = SystemDirectory + "\\Bmp";
   if(!DirectoryExists(BitmapDirectory))
      mkdir(BitmapDirectory.c_str());

   ImageDirectory = SystemDirectory + "\\Image";
   if(!DirectoryExists(ImageDirectory))
      mkdir(ImageDirectory.c_str());

   RecipeDirectory = SystemDirectory + "\\Recipe";
   if(!DirectoryExists(RecipeDirectory))
      mkdir(RecipeDirectory.c_str());

   ExportDirectory = SystemDirectory + "\\Export";
   if(!DirectoryExists(ExportDirectory))
      mkdir(ExportDirectory.c_str());

   // 2022 7 13 - chc RobotRX.ini檔名與目錄名
   RobotWINIFilename = SystemDirectory + ROBOTW_INI_FILENAME;

   LogDirectory = SystemDirectory + "\\Log";
   if(!DirectoryExists(LogDirectory))
      mkdir(LogDirectory.c_str());
   DateTimeToString(temp,"yyyymmddhhnnss",Now());
   LogFileName = LogDirectory + "\\" + temp + ".log";
   ErrorLogFileName = LogDirectory + "\\" + temp + "-E.log";
   MainLogFileName = LogDirectory + "\\System.log";

   // Main Log
   mmMainLog->Lines->LoadFromFile(MainLogFileName);
   frmSystemLog->mmMainLog->Lines->LoadFromFile(MainLogFileName);

   WriteSystemLog(">>LoadSystemParameter()");

   // 2019 8 13 - chc ini- port
   SystemINIFilename = SystemDirectory + SYSTEM_INI_FILENAME;
   LoadSystemParameter();

   WriteSystemLog(">>LoadCOMPort()");

   // 2022 8 15 - chc COM Port
   LoadCOMPort();

   WriteSystemLog(">>LoadAlignerParameter()");

   // 2022 7 10 - chc Read Aligner Parameters
   LoadAlignerParameter();

   WriteSystemLog(">>LoadMacroParameter()");

   // 2022 8 16 - chc Load Macro Parameter
   LoadMacroParameter();

   WriteSystemLog(">>LoadRobotParameter()");

   // 2022 8 16 - chc Load Robot Parameter
   LoadRobotParameter();

   WriteSystemLog(">>Init Joystick");

   // 2020 6 6 - chc Load Joystick
   LoadJoystick();
   // Load Joystick Default Speed
   LoadJoystickDefaultSpeed();

   // 2022 8 12 - chc Log
   WriteSystemLog(">>LoadUserPosition()");
   // User filename: UserPosition.ini
   UserINIFilename = SystemDirectory + USER_INI_FILENAME;
   LoadUserPosition();

   LensINIFilename = SystemDirectory + LENS_INI_FILENAME;
   WriteSystemLog(">>LoadLensPosition()...");
   LoadLensPosition(LensNo);
   WriteSystemLog(">>LoadLensPosition() Done");

   // Stage.ini
   ReadRangeData();
   WriteSystemLog(">>ReadRangeData() Done");

   // 2022 6 16 - chc Load Speed Parameter
   SpeedINIFilename = SystemDirectory + SPEED_INI_FILENAME;
   LoadSpeedParameter();
   WriteSystemLog(">>LoadSpeedParameter() Done");

   // 2022 6 16 - chc FocusParameter.ini
   FocusINIFilename = SystemDirectory + FOCUS_INI_FILENAME;
   LoadFocusParameter();
   WriteSystemLog(">>LoadFocusParameter() Done");

   // 2022 7 13 - chc Load W Position: RobotW.ini
   LoadWPosition();

   // 2022 8 23 - chc Load BXFM/A2M Parameter: 但不執行
   ReadA2MParameter(0);                                          // 要先讀取AF/Z Table值
   ReadBXFMParameter(0);                                         // 會切換Lens: 改變AF/Z
   ReadDICParameter(0);                                          // 要先讀取AF/Z Table值

   // 2022 8 15 - chc Logo form
   frmLogo->Visible = true;

   // 2023 1 9 - chc NCC: 有Match, 要做
   ColorImg = CreateColoriImage();
   ColorLearnImg = CreateColoriImage();
   GrayImg = CreateGrayiImage();
   GrayLearnImg = CreateGrayiImage();
   iMatchModel = CreateNCCMatch();

   // 2022 8 15 - chc 分段啟動
   if(step == 1) {
      return;
   }
step2:

   WriteSystemLog("啟動CCD...");
   boolCCD = true;
   // Setup CCD
   SetupCCD(1);                                                                 // 要個自啟動Thread來取像
   if(bool_CCD_StatusAry[0] == true || bool_CCD_StatusAry[1] == true || bool_CCD_StatusAry[2] == true) {
      pnlCCDStatus->Color = clLime;
      pnlCCDStatus1->Color = clLime;
      frnMain->AlarmStatus.boolCCD = false;
   }
   else {

      // 2022 11 25 - chc ICS後不用再試Basler
      //SetupCCD(2);
                                                                                // 要個自啟動Thread來取像
      if(bool_CCD_StatusAry[0] == true) {
         pnlCCDStatus->Color = clLime;
         pnlCCDStatus1->Color = clLime;
         frnMain->AlarmStatus.boolCCD = false;
      }
      else {
         pnlCCDStatus->Color = clRed;
         pnlCCDStatus1->Color = clRed;
         btnReviewLive->Enabled = false;
         frnMain->AlarmStatus.boolCCD = true;
      }
   }
   WriteSystemLog("Init CCD Buffer...");
   // 強制為Color CCD : 1278*958, 3.75um
   if(numDevices == 0) {
      WriteSystemLog("未偵測到CCD! 強制設為Mono CCD: 1280*960");
      GigaWidth = 1280;
      GigaHeight = 960;
      CCDInfoAry[0].Width = GigaWidth;
      CCDInfoAry[0].Height = GigaHeight;
      CCDInfoAry[0].Type = CCD_BW;
      CCDImageAry[0].SetSize(GigaWidth,GigaHeight);
      CCDImageROIAry[0].Attach(&CCDImageAry[0]);

      AlignWidth = imCCD->Width;
      AlignHeight = imCCD->Height - 50;

   }
   imCCD->Left = 4;
   imCCD->Top = 3;
   imCCD->Width = 1100;
   imCCD->Height = 925;
   // CCD FOV vs CCDImage Area
   CCDDx = CCDInfoAry[0].Width - imCCD->Width;
   CCDDy = CCDInfoAry[0].Height - imCCD->Height;
   CCDRangeX = CCDDx / 2;
   CCDRangeY = CCDDy / 2;

   // QRCode Socket連線
   csQRCode1->Port = QRCodePort1;
   csQRCode1->Address = QRCodeIP1;
   edQRCodeIP1->Text = QRCodeIP1;
   edQRCodePort1->Text = QRCodePort1;
   csQRCode2->Port = QRCodePort2;
   csQRCode2->Address = QRCodeIP2;
   edQRCodeIP2->Text = QRCodeIP2;
   edQRCodePort2->Text = QRCodePort2;
   // 0.5sec
   tmActiveSocket->Enabled = true;
   tmActiveSocket2->Enabled = true;

   // 2022 6 16 - chc Joystick
   InitJoystick(Handle);

   // Motion: PCI7856/DIO
   SetupMotion();
   if(boolMotion == true) {
      pnlPCI7856->Color = clLime;
      pnl7856Status->Color = clLime;
      // 設定成可操作: 軸控參數
      gbMotion->Enabled = true;
      shMotionStatus->Brush->Color = clLime;
   }
   else {
      pnlPCI7856->Color = clRed;
      frnMain->WriteSystemLog(">>Set 7856 RED - 0");
      pnl7856Status->Color = clRed;
      shMotionStatus->Brush->Color = clRed;
   }
   if(boolDI == true) {
      pnlInStatus->Color = clLime;
   }
   else {
      pnlInStatus->Color = clRed;
   }
   if(boolDO == true) {
      pnlOutStatus->Color = clLime;
   }
   else {
      pnlOutStatus->Color = clRed;
   }
   WriteSystemLog(">After SetupMotion");

   // 設定位置
   pnlStartMessage->Top = 304;
   pnlStartMessage->Left = 232;
   pnlAxisError->Left = 232;
   pnlAxisError->Top = 408;
   pnlEMO->Left = 232;
   pnlEMO->Top = 208;
   pnlError->Left = 232;
   pnlError->Top = 120;

   // 記錄目前做連續移動中: 軸與移動方向(1/2: 正/反, 0-沒有移動)
   MoveDirection = 0;
   MoveIgnore = false;
   WriteSystemLog("MoveDirection = 0 => 1");

   // 指定Page
   pcSystem->ActivePage = tsSystemInformation;
   pcMotion->ActivePage = tsMotionOperate;
   // 此時再啟動Timer
   tmSystem->Enabled = true;
   // Eanble timer
   // Blinking
   boolStartState = false;
   boolAllHomeState = false;
   btnHome2->Font->Color = clNavy;
   tm400ms->Enabled = true;

   // 2022 12 6 - chc Logo Form
   //if(frmLogo->Visible == true)
   //   frmLogo->pnlHome3->Font->Color = clNavy;

   // Recipe
   RecipeName = "Recipe";

   // LED Controller
   WriteSystemLog(">>InitLampControl1()");
   InitLampControl1();
   WriteSystemLog(">>InitLampControl2()");
   InitLampControl2();
   // 切換Recipe: 讀取亮度值
   WriteSystemLog(">>ReadLEDValue()");
   ReadLEDValue();

   frnMain->Width = 1920;
   frnMain->Height = 1038;
   frnMain->Top = 0;
   frnMain->Left = 0;
   pcOperation->ActivePage = tsOperation;

   // 2022 8 15 - chc Logo form
   MASTER_SCREEN_WIDTH  = 1920;
   MASTER_SCREEN_HEIGHT = 1040;

   pnlPassword->Top = 51;
   pnlPassword->Left = 4;
   UserTitle();
   LoadUser();
   PriorityLevel = PRIORITY_OP;
   SwitchLevel();

   // 2022 6 16 - chc Joystick
   if(boolJoystick == true) {
      tmJoystick->Enabled = true;
   }

   SaveBMPSerialNo = 1;
   LensNo = 1;

   // Wafer Map: 1.1um, 12"/8"
   sbWaferMap->Left = imCCD->Left;
   sbWaferMap->Top = imCCD->Top;
   sbWaferMap->Width = imCCD->Width;
   sbWaferMap->Height = imCCD->Height;
   imWaferMap->Width = sbWaferMap->Width;
   imWaferMap->Height = sbWaferMap->Height;
   sbWaferMap->DoubleBuffered = true;
   //shMapHorizontal->Top = (imCCD->Height - 17) / 2;
   shMapHorizontal->Top = (imCCD->Height - 21) / 2;
   shMapHorizontal->Width = imCCD->Width;
   //shMapVertical->Left = (imCCD->Width - 17) / 2;
   shMapVertical->Left = (imCCD->Width - 21) / 2;
   shMapVertical->Height = imCCD->Height;
   //iBoxWidth = imCCD->Width - 17;
   //iBoxHeight = imCCD->Height - 17;
   iBoxWidth = imCCD->Width - 21;
   iBoxHeight = imCCD->Height - 21;
   pnlVertical->Left = imCCD->Left + pnlHorizontal->Width/2;
   pnlHorizontal->Top = imCCD->Top + pnlVertical->Height/2;
   imMeasure->Width = imWaferMap->Width;
   imMeasure->Height = imWaferMap->Height;
   imMeasure->Top = imWaferMap->Top;
   imMeasure->Left = imWaferMap->Left;
   InitWaferMap();
   InitStageInformation();

   // 2022 8 15 - chc 分段啟動
   boolFormShowDone = true;

   // 2022 8 26 - chc YuanLi Socket
   boolSendYuanliCommand = false;
   SetCmdSet();

   // 2022 12 27 - chc FormShow後再啟動
   if(bool_CCD_StatusAry[0] == true)
      tmISCCD->Enabled = true;
   if(bool_CCD_StatusAry[1] == true)
      tmISLeftCCD->Enabled = true;
   if(bool_CCD_StatusAry[2] == true)
      tmISRightCCD->Enabled = true;

   // 2023 1 9 - chc 提前做
   InitRFIDCom();

   sbSystem->Panels->Items[14]->Text = "M01";
   pnlMainVersion->Caption = "M01";

   pnlSystemMessage->Caption = "System Ready. Wait SVON...";
}
//---------------------------------------------------------------------------
void __fastcall TfrnMain::pnlSocketClick(TObject *Sender)
{
bool connect;

   pnlSocket->Color = clSilver;
   pnlSocket->Enabled = false;

   pnlSocket->Enabled = true;
}
//---------------------------------------------------------------------------
void __fastcall TfrnMain::btnSendClick(TObject *Sender)
{
int no;
char buf[100];

   btnSend->Enabled = false;
   sprintf(buf,"%s",edSocket->Text.c_str());
   SendSocket(buf);
   pnlMessage->Caption = "送出" + edSocket->Text;
   WriteSystemLog(pnlMessage->Caption);
   AddMessage(pnlMessage->Caption);
   btnSend->Enabled = true;
   return;
}
//---------------------------------------------------------------------------
void __fastcall TfrnMain::mnSaveToFileClick(TObject *Sender)
{

   if(mmQRCodeMessage->Lines->Count == 0) {
      Application->MessageBox("目前尚無記錄事項!","量測系統: 記錄檔寫入作業    ",MB_ICONINFORMATION|MB_OK);
      return;
   }
   if(sdSocketMessages->Execute()) {
      mmQRCodeMessage->Lines->SaveToFile(sdSocketMessages->FileName.c_str());
   }
}
//---------------------------------------------------------------------------
void __fastcall TfrnMain::mnClearMessageClick(TObject *Sender)
{

   mmQRCodeMessage->Clear();
}
//---------------------------------------------------------------------------
// 重連線
void __fastcall TfrnMain::pnlVersionClick(TObject *Sender)
{

   return;

   btnSend->Enabled = true;

   // 先設Close再Active
   csQRCode1->Close();
   pnlSystemMessage->Caption = "與QRCode Reader手動重連線...";
   Sleep(100);

   csQRCode1->Port = edQRCodePort1->Text.ToInt();

   csQRCode1->Active = true;
   return;

}
//---------------------------------------------------------------------------
// Load *.ini : WVQuartz.ini
void __fastcall TfrnMain::LoadSystemParameter()
{
TIniFile *pSystemFile;
AnsiString msg,axisname;

   pSystemFile = new TIniFile(SystemINIFilename);

   //2023 1 11 - chc Tazmo: By Parameter
   RobotMode = pSystemFile->ReadInteger("System","OPMode",ROBOT_MODE_TAZMO);
   if(RobotMode == ROBOT_MODE_TAZMO) {
      frnMain->Caption = "WLS3200v-T";
      pnlAligner2->Visible = true;
   }
   else {
      frnMain->Caption = "WLS3200-H";
      pnlAligner2->Visible = false;
      btnMacroZ1Down->Enabled = true;
      btnMacroZ2Up->Enabled = true;
      btnMacroZ2Home->Enabled = true;
      btnMacroZ2Down->Enabled = true;
      btnMacroZ1Up->Enabled = true;
      btnMacroRobotPosition->Enabled = true;
      btnMacroReadyPosition->Enabled = true;
      btnMacroInnerPosition->Enabled = true;
      btnMacroInnerStop->Enabled = true;
      btnMacroOuterPosition->Enabled = true;
      btnMacroOuterStop->Enabled = true;
      btnMacroOuterTCCW->Enabled = true;
      btnMacroOuterTCW->Enabled = true;
      combDICComport->Enabled = false;
      combDICBaudrate->Enabled = false;
      btnDICConnect->Enabled = false;
      btnDICCMD->Enabled = false;
      btnDICFCNearFarSet->Enabled = false;
      btnDICSave->Enabled = false;
      laChuckInner->Caption = "Chuck Vacuum";
      laChuckOuter->Caption = "Macro內環Vacuum";
      laMacrokInner->Caption = "Macro外環Vacuum";
      laMacrokOuter->Caption = "Reserved";
      cbBit0->Caption = "0-Table吸真空";
      cbBit1->Caption = "1-Macro內環吸真空";
      cbBit2->Caption = "2-Macro外環吸真空";
      cbBit3->Caption = "Reserved";
   }

   // Cognex 174: HostName = is1741_823dba
   QRCodePort1 = pSystemFile->ReadInteger("QRCode1","Port",2000);
   QRCodeIP1 = pSystemFile->ReadString("QRCode1","IP","169.254.7.53");
   QRCodePort2 = pSystemFile->ReadInteger("QRCode2","Port",2000);
   QRCodeIP2 = pSystemFile->ReadString("QRCode2","IP","169.254.7.54");

   // 心跳包Interval: 30sec
   int ivalue = pSystemFile->ReadInteger("QRCode" ,"Interval Time"                  ,30000);
   if(ivalue < 5000)
      ivalue = 5000;
   else if(ivalue > 30000)
      ivalue = 30000;
   edInterval->Text = ivalue;
   StatusInterval = ivalue;
   tmStatus->Interval = StatusInterval;
   tmStatus2->Interval = StatusInterval;

   // Degree: edQRCodeDegree
   QRCodeDegree = pSystemFile->ReadFloat("QRCode","Degree",180.0);

   // ImagingSource Name: DFK 33GP1300 + 44614266
   ISCCDName              = pSystemFile->ReadString("CCD","ISCCDName"       ,"DFK 33G445");
   ISCCDSerialNo          = pSystemFile->ReadString("CCD","ISCCDSerialNo"   ,"52024109");

   // 2022 12 26 - chc ImagingSource Name: DFK 33GP1300 + 44614266
   ISCCD2Name              = pSystemFile->ReadString("CCD","ISCCD2Name"       ,"DFK 33G445");
   ISCCD2SerialNo          = pSystemFile->ReadString("CCD","ISCCD2SerialNo"   ,"52024109");
   ISCCD3Name              = pSystemFile->ReadString("CCD","ISCCD3Name"       ,"DFK 33G445");
   ISCCD3SerialNo          = pSystemFile->ReadString("CCD","ISCCD3SerialNo"   ,"52024109");

   // 2022 8 10 - chc for test
   boolForTest            = pSystemFile->ReadBool("System Parameter","bool For Test"       ,false);

   // Position
   // [Position Parameter]各點位置 : X/Y/Z/T
   TLMDEdit *editx,*edity,*editz,*editt;
   for(int no=0 ; no<MAX_POSITION_NO ; no++) {
      if(no == POSITION_CENTER)
         axisname = "Center";
      else if(no == POSITION_45)
         axisname = "45";
      else if(no == POSITION_0)
         axisname = "0";
      else if(no == POSITION_LOAD)
         axisname = "Load";
      else if(no == POSITION_ORIGINAL)
         axisname = "Original";
      else if(no == POSITION_CCD)
         axisname = "CCD";
      else if(no == POSITION_R45)
         axisname = "R45";
      editx = (TLMDEdit *)(FindComponent("ed" + axisname + "X"));
      Position[no].X = pSystemFile->ReadInteger(POSITION_PARAMETER_SECTION,axisname+" PositionX" ,0);
      editx->Text = IntToStr(Position[no].X);
      edity = (TLMDEdit *)(FindComponent("ed" + axisname + "Y"));
      Position[no].Y = pSystemFile->ReadInteger(POSITION_PARAMETER_SECTION,axisname+" PositionY" ,0);
      edity->Text = IntToStr(Position[no].Y);
      editz = (TLMDEdit *)(FindComponent("ed" + axisname + "Z"));
      Position[no].Z = pSystemFile->ReadInteger(POSITION_PARAMETER_SECTION,axisname+" PositionZ" ,0);
      editz->Text = IntToStr(Position[no].Z);
      editt = (TLMDEdit *)(FindComponent("ed" + axisname + "T"));
      Position[no].T = pSystemFile->ReadInteger(POSITION_PARAMETER_SECTION,axisname+" PositionT" ,82000);
      editt->Text = IntToStr(Position[no].T);
   }

   // T轉動時的Z最低高度(最大值): edTMoveZMax
   int maxz = pSystemFile->ReadInteger(POSITION_PARAMETER_SECTION,"TMoveMaxZ"   ,150000);
   edTMoveZMax->Text = IntToStr(maxz);

   // Motion
   // [Motion Information] 各軸資訊
   //struct MOTION_STRU   {
   //   int StartVel,MaxVel,Distance,Position,HomeVel,ReviewVel,UpLimit,HomeMode,LowDistance;
   //   bool ORGLogic;
   //   double Tacc,Tdec;
   //};
   //struct MOTION_STRU   MotionParameter[MAX_AXIS_NO];
   TLMDEdit *edit;
   TLMDCheckBox *checkbox;
   TLMDComboBox *combobox;
   for(int i=0 ; i<MAX_AXIS_NO ; i++) {
      GetAxisName(i);
      axisname = AxisName;

      edit = (TLMDEdit *)(FindComponent("edStartVel" + axisname));
      MotionParameter[i].StartVel = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,axisname+START_VEL      ,1000);
      edit->Text = IntToStr(MotionParameter[i].StartVel);

      edit = (TLMDEdit *)(FindComponent("edMaxVel" + axisname));
      MotionParameter[i].MaxVel = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,axisname+MAX_VEL          ,5000);
      edit->Text = IntToStr(MotionParameter[i].MaxVel);

      edit = (TLMDEdit *)(FindComponent("edDistance" + axisname));
      MotionParameter[i].Distance = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,axisname+DISTANCE       ,1000);
      edit->Text = IntToStr(MotionParameter[i].Distance);

      edit = (TLMDEdit *)(FindComponent("edPosition" + axisname));
      MotionParameter[i].Position = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,axisname+POSITION       ,0);
      edit->Text = IntToStr(MotionParameter[i].Position);

      edit = (TLMDEdit *)(FindComponent("edHomeVel" + axisname));
      MotionParameter[i].HomeVel = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,axisname+HOME_VEL        ,1000);
      edit->Text = IntToStr(MotionParameter[i].HomeVel);

      edit = (TLMDEdit *)(FindComponent("edReviewVel" + axisname));
      MotionParameter[i].ReviewVel = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,axisname+REVIEW_VEL    ,1000);
      edit->Text = IntToStr(MotionParameter[i].ReviewVel);

      edit = (TLMDEdit *)(FindComponent("edUpLimit" + axisname));
      MotionParameter[i].UpLimit = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,axisname+UP_LIMIT        ,1000);
      edit->Text = IntToStr(MotionParameter[i].UpLimit);

      edit = (TLMDEdit *)(FindComponent("edTacc" + axisname));
      MotionParameter[i].Tacc = pSystemFile->ReadFloat(MOTION_INFORMATION_SECTION  ,axisname+TACC               ,0.1);
      msg.sprintf("%.2f",MotionParameter[i].Tacc);
      edit->Text = msg;

      edit = (TLMDEdit *)(FindComponent("edTdec" + axisname));
      MotionParameter[i].Tdec = pSystemFile->ReadFloat(MOTION_INFORMATION_SECTION  ,axisname+TDEC               ,0.1);
      msg.sprintf("%.2f",MotionParameter[i].Tdec);
      edit->Text = msg;

      edit = (TLMDEdit *)(FindComponent("edLowDistance" + axisname));
      MotionParameter[i].LowDistance = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION  ,axisname+LOW_DISTANCE  ,1000);
      edit->Text = IntToStr(MotionParameter[i].LowDistance);

      combobox = (TLMDComboBox *)(FindComponent("combHomeMode" + axisname));
      MotionParameter[i].HomeMode = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,axisname+HOME_MODE       ,0);
      combobox->Text = IntToStr(MotionParameter[i].HomeMode);
   }

   // Z
   int zmin,zmax;
   double tresolution;
   zmin = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,"Z Min"                                           ,-20000);
   zmax = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,"Z Max"                                           ,200000);
   // 18萬 - 360度
   tresolution = pSystemFile->ReadFloat(MOTION_INFORMATION_SECTION  ,"T Resolution"                             ,0.002);
   edMinZPosition->Text = zmin;
   edMaxZPosition->Text = zmax;
   msg.sprintf("%.3f",tresolution);
   edTResolution->Text = msg;
   // T
   int tmin,tmax;
   tmin = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,"T Min"                                           ,-120000);
   tmax = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,"T Max"                                           ,120000);
   edMinTPosition->Text = tmin;
   edMaxTPosition->Text = tmax;

   // 2022 8 4 - chc 加入X/Y Min/Max
   // X
   int xmin,xmax;
   xmin = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,"X Min"                                           ,-80000);
   xmax = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,"X Max"                                           ,3000000);
   edMinXPosition->Text = xmin;
   edMaxXPosition->Text = xmax;
   // Y
   int ymin,ymax;
   ymin = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,"Y Min"                                           ,-80000);
   ymax = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,"Y Max"                                           ,3000000);
   edMinYPosition->Text = ymin;
   edMaxYPosition->Text = ymax;

   // CCD
   // CCD Precision
   CCDPrecision = pSystemFile->ReadFloat("CCD" ,CCD_PRECISION                                   ,21.818);
   msg.sprintf("%.3f",CCDPrecision);
   edCCDPrecision->Text = msg;
   Set400Width();

   // GridPixel
   GridPixel = pSystemFile->ReadInteger("CCD" ,"Grid Pixel"                                     ,40);
   edGridPixel->Text = IntToStr(GridPixel);

   // Ruler Color
   iRulerColor = pSystemFile->ReadInteger("CCD","int Ruler Color"                               ,0);
   rgRulerColor->ItemIndex = iRulerColor;

   // Cross Mark
   iCrossMark = pSystemFile->ReadInteger("CCD","int Cross Mark"                                 ,0);
   rgRulerType->ItemIndex = iCrossMark;

   // 設定Gain/Shutter: CCDShutterAry, CCDGainAry, CCDContrastAry
   CCDShutterAry[0] = pSystemFile->ReadInteger("CCD","Shutter"                                  ,5);
   CCDGainAry[0] = pSystemFile->ReadInteger("CCD","Gain"                                        ,175);
   CCDContrastAry[0] = pSystemFile->ReadInteger("CCD","Contrast"                                ,12);
   // @@@@ Setup CCD後再設定
   //rgCCDShutter->ItemIndex = CCDShutterAry[0];
   //rgCCDShutterClick(this);
   //tbCCDGain->Position = CCDGainAry[0];
   //tbContrast->Position = CCDContrastAry[0];

   WriteSystemLog(">>LoadSystemParameter() Shutter,Gain,Contrast Done.");

   // 2022 12 26 - chc Multi CCD
   CCDShutterAry[1] = pSystemFile->ReadInteger("CCDLeft","Shutter"                                  ,5);
   CCDGainAry[1] = pSystemFile->ReadInteger("CCDLeft","Gain"                                        ,175);
   CCDContrastAry[1] = pSystemFile->ReadInteger("CCDLeft","Contrast"                                ,12);
   CCDShutterAry[2] = pSystemFile->ReadInteger("CCDRight","Shutter"                                  ,5);
   CCDGainAry[2] = pSystemFile->ReadInteger("CCDRight","Gain"                                        ,175);
   CCDContrastAry[2] = pSystemFile->ReadInteger("CCDRight","Contrast"                                ,12);

   WriteSystemLog(">>LoadSystemParameter() Read WhiteBalance...");
   // 2023 1 3 - chc White Balance
   CCDWBAuto[0] = pSystemFile->ReadBool("CCD","Bool White Balance Auto"                    ,true);
   // @@@@ Setup CCD後再設定
   //cbWBAuto->Checked = CCDWBAuto[0];
   if(cbWBAuto->Checked == false)
      btnWBOneTouch->Enabled = true;
   else
      btnWBOneTouch->Enabled = false;
   WriteSystemLog(">>LoadSystemParameter() Read WhiteBalance...1");
   // @@@@ Setup CCD後再設定
   //frmInspection->cbWBAuto->Checked = cbWBAuto->Checked;
   frmInspection->btnWBOneTouch->Enabled = btnWBOneTouch->Enabled;
   WriteSystemLog(">>LoadSystemParameter() Read WhiteBalance...2");
   CCDWBAuto[1] = pSystemFile->ReadBool("CCDLeft","Bool White Balance Auto"                ,true);
   CCDWBAuto[2] = pSystemFile->ReadBool("CCDRight","Bool White Balance Auto"               ,true);
   // @@@@ Setup CCD後再設定
   //ICImagingControl1->WhiteBalanceAuto = CCDWBAuto[0];
   //ICImagingControl2->WhiteBalanceAuto = CCDWBAuto[1];
   //ICImagingControl3->WhiteBalanceAuto = CCDWBAuto[2];

   WriteSystemLog(">>LoadSystemParameter() Read WhiteBalance Done.");

   // edStdGray
   int stdgray = pSystemFile->ReadInteger("CCD","Std Gray"                                      ,250);
   edStdGray->Text = IntToStr(stdgray);
   int stdgraytolerance = pSystemFile->ReadInteger("CCD","Std Gray Tolerance"                   ,6);
   edStdGrayTolerance->Text = IntToStr(stdgraytolerance);

   // Aligner
   // 絕對灰階
   bool bflag;

   // CCD X Direction
   boolCCDXDirection      = pSystemFile->ReadBool("System Parameter","bool CCD X Direction"     ,true);
   cbCCDXDirection->Checked = boolCCDXDirection;
   // CCD Y Direction
   boolCCDYDirection      = pSystemFile->ReadBool("System Parameter","bool CCD Y Direction"     ,false);
   cbCCDYDirection->Checked = boolCCDYDirection;

   // Lens X Direction
   boolLensXDirection      = pSystemFile->ReadBool("System Parameter","bool Lens X Direction"     ,false);
   cbLensXDirection->Checked = boolLensXDirection;
   // Lens Y Direction
   boolLensYDirection      = pSystemFile->ReadBool("System Parameter","bool Lens Y Direction"     ,false);
   cbLensYDirection->Checked = boolLensYDirection;

   // 指定7/8/9/10何者為Enable/Disable: JoystickEnabledKey, JoystickEnabledMode
   JoystickEnabledMode = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,"Joystick Enable Mode" ,0);
   JoystickEnabledKey = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,"Joystick Enable Key"   ,9);
   SetJoystickEnabledName();

   // 2022 6 29 - chc Z Source, Y Direciton: JoystickZSource,JoystickYDirection
   JoystickZSource = pSystemFile->ReadInteger(MOTION_INFORMATION_SECTION,"Joystick Z Source"            ,0);
   boolJoystickYDirection = pSystemFile->ReadBool(MOTION_INFORMATION_SECTION,"Joystick Y Direction"         ,false);
   boolJoystick2LockZ = pSystemFile->ReadBool(MOTION_INFORMATION_SECTION,"Joystick 2 LockZ"                 ,false);
   rgZSource->ItemIndex = JoystickZSource;
   cbJoystickYDirection->Checked = boolJoystickYDirection;
   cbJoystick2LockZ->Checked = boolJoystick2LockZ;

   // Idle/Measure/Recipe Lamp
   // Idle: T/F
   boolIdleYellow = pSystemFile->ReadBool(MOTION_INFORMATION_SECTION,BOOL_IDLE_YELLOW           ,true);
   cbIdleYellow->Checked = boolIdleYellow;
   boolIdleGreen = pSystemFile->ReadBool(MOTION_INFORMATION_SECTION,BOOL_IDLE_GREEN            ,false);
   cbIdleGreen->Checked = boolIdleGreen;
   // Measure: F/T
   boolMeasureYellow = pSystemFile->ReadBool(MOTION_INFORMATION_SECTION,BOOL_MEASURE_YELLOW        ,false);
   cbMeasureYellow->Checked = boolMeasureYellow;
   boolMeasureGreen = pSystemFile->ReadBool(MOTION_INFORMATION_SECTION,BOOL_MEASURE_GREEN         ,true);
   cbMeasureGreen->Checked = boolMeasureGreen;
   // Recipe: T/T
   boolRecipeYellow = pSystemFile->ReadBool(MOTION_INFORMATION_SECTION,BOOL_RECIPE_YELLOW         ,true);
   cbRecipeYellow->Checked = boolRecipeYellow;
   boolRecipeGreen = pSystemFile->ReadBool(MOTION_INFORMATION_SECTION,BOOL_RECIPE_GREEN          ,true);
   cbRecipeGreen->Checked = boolRecipeGreen;

   delete pSystemFile;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::csQRCode1Disconnect(TObject *Sender,
      TCustomWinSocket *Socket)
{

   btnSend->Enabled = false;
   pnlSocketConnect->Color = clSilver;
   pnlQRCodeConnect->Color = clSilver;

   tmActiveSocket->Enabled = true;
   AddMessage("Socket斷線.");

   // 取消心跳包
   tmStatus->Enabled = false;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::csQRCode1Connect(TObject *Sender,
      TCustomWinSocket *Socket)
{

   btnSend->Enabled = true;
   pnlSocketConnect->Color = clLime;
   pnlQRCodeConnect->Color = clLime;
   AddMessage("Socket連線.");

   // 啟動心跳包
   tmStatus->Enabled = true;

}
//---------------------------------------------------------------------------
// Start Connect
void __fastcall TfrnMain::btnReadyClick(TObject *Sender)
{

   pnlVersionClick(this);
   return;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::csQRCode1Error(TObject *Sender,
      TCustomWinSocket *Socket, TErrorEvent ErrorEvent, int &ErrorCode)
{

   ErrorCode = 0;
   pnlSocketConnect->Color = clRed;
   pnlQRCodeConnect->Color = clRed;
   AddMessage("Socket異常.");
   tmActiveSocket->Enabled = true;

   // 取消心跳包
   tmStatus->Enabled = false;
}
//---------------------------------------------------------------------------
// Client Socket
AnsiString ReplyStrSocket = "";
void __fastcall TfrnMain::csQRCode1Read(TObject *Sender,
      TCustomWinSocket *Socket)
{
static bool inactive = false;
char Buf[1024+1];
char tmpbuf[1024+1];
int len,no;
AnsiString msg;

   boolInSocketRead = true;
   WriteSystemLog("Socket Enter...");
   // Re-Entrant
   if(inactive == true) {
      AddMessage("[C] Re-Entrant!");
      WriteSystemLog("Socket Re-Entrant!");
      // 接收
      len = Socket->ReceiveBuf(tmpbuf,1024);
      if(len > 0) {
         sprintf(Buf,"%s%s",Buf,tmpbuf);
      }
      return;
   }

   inactive = true;
   no = Socket->ReceiveBuf(Buf,1024);
   if(no > 0) {
      Buf[no] = 0;

      // 即時顯示: 否則有亂碼
      //msg.sprintf("[org]%s",Buf);
      //AddMessage(msg);
      //WriteSystemLog(msg);
      //msg = "[X]";
      //for(int i=0 ; i<no ; i++) {
      //   msg1.sprintf("%2X ",Buf[i]);
      //   msg = msg + msg1;
      //}
      //WriteSystemLog(msg);

      for(int i=0 ; i<no ; i++) {
         // End Code
         if(Buf[i] == 0x0d)
            continue;
         if(Buf[i] == 0x0a) {
            // Display
            AddMessage(ReplyStrSocket);
            WriteSystemLog("QRCode: Recv = " + ReplyStrSocket);
            len = ReplyStrSocket.Length();
            pnlWaferID->Caption = ReplyStrSocket.SubString(2,len-1);
            // Clear
            ReplyStrSocket = "";
         }
         else {
            if(ReplyStrSocket == "")
               ReplyStrSocket += "<";
            ReplyStrSocket += Buf[i];
         }
      }
      pnlMessage->Caption = "Ready";
      //pnlBXFM->Enabled = true;
   }

   WriteSystemLog("Socket Leave.");
   boolInSocketRead = false;
   inactive = false;
}
//---------------------------------------------------------------------------
// 0.5sec
void __fastcall TfrnMain::tmActiveSocketTimer(TObject *Sender)
{
static bool first = true;

   if(pnlSocketConnect->Color == clLime)
      tmActiveSocket->Enabled = false;
   else {
      // 先設Close再Active
      csQRCode1->Close();
      pnlSystemMessage->Caption = "與QRCode自動重連線...";
      AddPerformanceMessage(pnlSystemMessage->Caption);
      Sleep(100);

      // 23, admin, SO1(連線), SO0(斷線)
      if(first == true)
         csQRCode1->Port = 23;

      csQRCode1->Active = true;
   }

   if(first == true) {
      // 1500 => 3000(每3秒重連線)
      tmActiveSocket->Interval = 3000;
      first = false;

      // 23, admin, SO1(連線), SO0(斷線)
      int cnt = 0;
      while(1) {
         Sleep(100);
         if(pnlSocketConnect->Color == clLime) {
            SendSocket("admin");
            Sleep(100);
            SendSocket("");
            Sleep(100);
            SendSocket("SO1");
            Sleep(100);
            // 斷線重連
            csQRCode1->Active = false;
            csQRCode1->Port = QRCodePort1;
            csQRCode1->Active = true;
            break;
         }
         cnt++;
         if(cnt > 20) {
            WriteSystemLog("QRCode Port 23設定失敗!");
            // 斷線重連
            csQRCode1->Active = false;
            csQRCode1->Port = QRCodePort1;
            csQRCode1->Active = true;
            break;
         }
      }
   }
}
//---------------------------------------------------------------------------
void __fastcall TfrnMain::WriteSystemLog(AnsiString msg)
{
static bool flag = false;

   // 避免ReEntrance
   if(flag == true) {
      return;
   }
   flag = true;

   // Exception Error
   try {                                                            // 追蹤Exception Error
      AnsiString logMessage;
      FILE *logFile;
      AnsiString dstr,tstr;
      DateTimeToString(dstr,"yyyy'/'mm'/'dd",Date());
      DateTimeToString(tstr,"hh':'nn':'ss':'zzz",Time());
      logMessage = dstr + " " + tstr + "-" + msg + "\n";

      logFile = fopen(LogFileName.c_str(),"a+t");
      fprintf(logFile,logMessage.c_str());
      fclose(logFile);
   }
   catch(Exception& e) {
      //WriteSystemLog(">>Error(WriteSystemLog): "+e.Message);
   }

   // 避免ReEntrance
   flag = false;
}
//---------------------------------------------------------------------------
// IC CCD Timer: Capture
int CaptureCounter = 0;
void __fastcall TfrnMain::tmISCCDTimer(TObject *Sender)
{
int no;
static int count = 0;
AnsiString msg;
int width,height,sx,sy,x,y,w,h;

   // 2022 12 28 - chc Stop Capture
   /*
   if((frmInspection->Visible == true && frmInspection->pcInspection->ActivePage == frmInspection->tsMicroInspection) ||
      (pnlMaintenance->Visible == true && pcMaintenance->ActivePage == tsMainCCD) ||
      (pnlEFEM->Visible == false)) {
      //if(ICImagingControl1->LiveCaptureContinuous == false) {
      //   ICImagingControl1->LiveStop();
      //   ICImagingControl1->LiveCaptureContinuous = true;
         ICImagingControl1->LiveStart();
      //}
      goto tocapture;
   }
   else {
      //if(ICImagingControl1->LiveCaptureContinuous == true) {
         ICImagingControl1->LiveStop();
      //   ICImagingControl1->LiveCaptureContinuous = false;
      //}
      return;
   }
   */
tocapture:

   tmISCCD->Enabled = false;
   pnlISCCDCapture->Color = clLime;
   pnlISCCDCapture->Refresh();

   // Snap an image.
   ICImagingControl1->MemorySnapImage();
   // Copy the last grabbed image to the PictureBox control

   // File Mode: 存檔與顯示
   //===========================
   //AnsiString fname;
   //fname = "D:\\test.bmp";
   //WideString ws;
   //ws = fname;
   //ICImagingControl1->ImageActiveBuffer->SaveAsBitmap(ws.c_bstr(),2);
   //if(FileExists(fname))
   //   imCCD->Picture->LoadFromFile(fname);
   //tmISCCD->Enabled = true;
   //return;
   //===========================

   // Buffer Mode: 取得資料加以解讀
   //unsigned char r,g,b;
   //color = imCCD->Canvas->Pixels[X][Y];
   //b = (color & 0xff0000) >> 16;
   //g = (color & 0x00ff00) >> 8;
   //r = color & 0x0000ff;
   unsigned char *buffer;
   buffer = (unsigned char *)ICImagingControl1->ImageActiveBuffer->get_ImageDataPtr();
   int bytesperpixel;
   bytesperpixel = ICImagingControl1->ImageBitsPerPixel / 8;

   // 累計數量
   CaptureCounter++;

   // Index
   pnlCCDStatus->Color = clSilver;
   pnlCCDStatus1->Color = clSilver;
   no = 0;
   width = CCDInfoAry[no].Width;
   height = CCDInfoAry[no].Height;
   //WriteSystemLog("Show-0: " + IntToStr(width) + "," + IntToStr(height) + "," + IntToStr(CCDInfoAry[no].Type));
   w = imCCD->Width;
   h = imCCD->Height;
   // 固定為CCDRangeX,CCDRangeY: 部份影像的起點(有雷射機要以雷射點為主)
   LaserCenterX = CCDRangeX;
   LaserCenterY = CCDRangeY;
   sx = LaserCenterX;
   sy = LaserCenterY;
   //WriteSystemLog("Frame sx,sy= " + IntToStr(sx) + "," + IntToStr(sy));

   // Check Range: 檢查起點是否錯誤?
   // sx,sy目前可視區域的起點: Scrollbar的Position值
   //   CCDDx = CCDInfoAry[0].Width - imCCD->Width;
   //   CCDDy = CCDInfoAry[0].Height - imCCD->Height;
   //   CCDRangeX = CCDDx / 2;
   //   CCDRangeY = CCDDy / 2;
   CheckRange(&sx,&sy);
   // 在影像處理中
   boolInGigaBufferAry[no] = true;
   //WriteSystemLog("Frame sx,sy= " + IntToStr(sx) + "," + IntToStr(sy));

   count++;
   unsigned char *pt,*pt1;
   int i;
   int pointer;
   // 記錄Basler存檔中...: 目前無作用
   if(boolInGigaSaveAry[no] == true) {
      pnlSystemMessage->Caption = "In Saving... Stop Refeshing Image";
      boolInGigaBufferAry[no] = false;
      return;
   }
   pnlCCDStatus->Color = clLime;
   pnlCCDStatus1->Color = clLime;

   //WriteSystemLog("Frame width,height,sx,sy,w,h= " + IntToStr(width) + "," + IntToStr(height) + "," + IntToStr(sx) + "," + IntToStr(sy)+ "," + IntToStr(w) + "," + IntToStr(h));

   // 要顯示在主畫面
   // width,height: CCD解析度
   // sx,sy: 目前可視區域的起點, Scrollbar的Position值
   // w,h: imCCD解析度
   GetImageXY(width,height,sx,sy,w,h,&x,&y);

   //WriteSystemLog("Frame x,y= " + IntToStr(x) + "," + IntToStr(y));

   //height = 960;
   //WriteSystemLog("Show-1: " + IntToStr(width) + "," + IntToStr(height) + "," + IntToStr(CCDInfoAry[no].Type));
   if(CCDInfoAry[no].Type == CCD_BW)
      CCDImageAry[no].SetSize(width,height);
   else
      usb_ImageAry[no].SetSize(width,height);
   //WriteSystemLog("Show-2");

   // BW : CCDImageAry
   if(CCDInfoAry[no].Type == CCD_BW) {
      //WriteSystemLog("Show-Gray");
      i = 0;
      for(int row=height-1 ; row>=0 ; row--) {
         pt = (unsigned char *)CCDImageAry[no].GetImagePtr(0,row);
         // 由buffer到pt
         memcpy(pt, &buffer[i],width);
         i += width;
      }

      // imOpeation
      if(frmInspection->Visible == false && pnlMaintenance->Visible == true && pcMaintenance->ActivePage == tsMainCCD) {
         w = imOperation->Width;
         h = imOperation->Height;
         if(cbCCDFullImage->Checked == true) {
            w = width;
            h = height;
         }
         sx = (width - imOperation->Width) / 2;
         sy = (height - imOperation->Height) / 2;
         LaserCenterX = sx;
         LaserCenterY = sy;
         CCDRangeX = sx;
         CCDRangeY = sy;
         imOperation->Picture->Bitmap->Width = w;
         imOperation->Picture->Bitmap->Height = h;
         CCDImageROIAry[no].Detach();
         CCDImageROIAry[no].Attach(&CCDImageAry[no]);
         GetImageXY(width,height,sx,sy,w,h,&x,&y);
         CCDImageROIAry[no].SetPlacement(x,y,w,h);
         CCDImageROIAry[no].Draw(imOperation->Canvas->Handle);
      }
      else if(frmInspection->Visible == true && frmInspection->pcInspection->ActivePage == frmInspection->tsMicroInspection &&
         frmInspection->cbFreeze->Checked == false) {
         // frmInspection->imInspection
         w = frmInspection->imInspection->Width;
         h = frmInspection->imInspection->Height;
         if(frmInspection->cbCCDFullImage->Checked == true) {
            w = width;
            h = height;
         }
         sx = (width - frmInspection->imInspection->Width) / 2;
         sy = (height - frmInspection->imInspection->Height) / 2;
         frmInspection->LaserCenterX = sx;
         frmInspection->LaserCenterY = sy;
         frmInspection->CCDRangeX = sx;
         frmInspection->CCDRangeY = sy;
         frmInspection->imInspection->Picture->Bitmap->Width = w;
         frmInspection->imInspection->Picture->Bitmap->Height = h;
         CCDImageROIAry[no].Detach();
         CCDImageROIAry[no].Attach(&CCDImageAry[no]);
         GetImageXY(width,height,sx,sy,w,h,&x,&y);
         CCDImageROIAry[no].SetPlacement(x,y,w,h);
         CCDImageROIAry[no].Draw(frmInspection->imInspection->Canvas->Handle);
      }
      else if(frmRecipeSet->Visible == true && frmRecipeSet->pcWaferInformation->ActivePage == frmRecipeSet->tsMicro &&
         frmRecipeSet->cbFreeze->Checked == false) {
         // frmRecipeSet->imInspection
         w = frmRecipeSet->imInspection->Width;
         h = frmRecipeSet->imInspection->Height;
         if(frmRecipeSet->cbCCDFullImage->Checked == true) {
            w = width;
            h = height;
         }
         sx = (width - frmRecipeSet->imInspection->Width) / 2;
         sy = (height - frmRecipeSet->imInspection->Height) / 2;
         frmRecipeSet->LaserCenterX = sx;
         frmRecipeSet->LaserCenterY = sy;
         frmRecipeSet->CCDRangeX = sx;
         frmRecipeSet->CCDRangeY = sy;
         frmRecipeSet->imInspection->Picture->Bitmap->Width = w;
         frmRecipeSet->imInspection->Picture->Bitmap->Height = h;
         CCDImageROIAry[no].Detach();
         CCDImageROIAry[no].Attach(&CCDImageAry[no]);
         GetImageXY(width,height,sx,sy,w,h,&x,&y);
         CCDImageROIAry[no].SetPlacement(x,y,w,h);
         CCDImageROIAry[no].Draw(frmRecipeSet->imInspection->Canvas->Handle);
      }
      else if(pnlEFEM->Visible == false) {
         // imCCD
         w = imCCD->Width;
         h = imCCD->Height;
         if(cbCCDFullImage->Checked == true) {
            w = width;
            h = height;
         }
         sx = (width - imCCD->Width) / 2;
         sy = (height - imCCD->Height) / 2;
         LaserCenterX = sx;
         LaserCenterY = sy;
         CCDRangeX = sx;
         CCDRangeY = sy;
         imCCD->Picture->Bitmap->Width = w;
         imCCD->Picture->Bitmap->Height = h;
         CCDImageROIAry[no].Detach();
         CCDImageROIAry[no].Attach(&CCDImageAry[no]);
         GetImageXY(width,height,sx,sy,w,h,&x,&y);
         CCDImageROIAry[no].SetPlacement(x,y,w,h);
         CCDImageROIAry[no].Draw(imCCD->Canvas->Handle);
      }
      /*
      //WriteSystemLog("Show-3");
      CCDImageROIAry[no].Detach();
      //WriteSystemLog("Show-4");
      CCDImageROIAry[no].Attach(&CCDImageAry[no]);
      //WriteSystemLog("Show-5");

      // Full Image
      //WriteSystemLog("Frame x,y,w,h= " + IntToStr(x) + "," + IntToStr(y) + "," + IntToStr(w) + "," + IntToStr(h));
      if(cbCCDFullImage->Checked == true) {
         imCCD->Picture->Bitmap->Width = width;
         imCCD->Picture->Bitmap->Height = height;
         CCDImageROIAry[no].SetPlacement(0,0,width,height);
      }
      else {
         // 要設Size
         imCCD->Picture->Bitmap->Width = w;
         imCCD->Picture->Bitmap->Height = h;
         CCDImageROIAry[no].SetPlacement(x,y,w,h);
      }

      // 2022 9 4 - chc Inspection
      if(frmInspection->Visible == true && frmInspection->pcInspection->ActivePage == frmInspection->tsMicroInspection &&
         frmInspection->cbFreeze->Checked == false) {
         w = frmInspection->imInspection->Width;
         h = frmInspection->imInspection->Height;
         GetImageXY(width,height,sx,sy,w,h,&x,&y);
         if(frmInspection->cbCCDFullImage->Checked == true) {
            frmInspection->imInspection->Picture->Bitmap->Width = width;
            frmInspection->imInspection->Picture->Bitmap->Height = height;
            CCDImageROIAry[no].SetPlacement(0,0,width,height);
         }
         else {
            frmInspection->imInspection->Picture->Bitmap->Width = frmInspection->imInspection->Width;
            frmInspection->imInspection->Picture->Bitmap->Height = frmInspection->imInspection->Height;
            CCDImageROIAry[no].SetPlacement(x,y,w,h);
         }
         CCDImageROIAry[no].Draw(frmInspection->imInspection->Canvas->Handle);
      }

      // 2022 12 6 - chc Display CCD
      else if(frmInspection->Visible == false && pnlMaintenance->Visible == true && pcMaintenance->ActivePage == tsMainCCD) {
         w = imOperation->Width;
         h = imOperation->Height;
         GetImageXY(width,height,sx,sy,w,h,&x,&y);
         if(cbCCDFullImage->Checked == true) {
            imOperation->Picture->Bitmap->Width = width;
            imOperation->Picture->Bitmap->Height = height;
            CCDImageROIAry[no].SetPlacement(0,0,width,height);
         }
         else {
            imOperation->Picture->Bitmap->Width = imOperation->Width;
            imOperation->Picture->Bitmap->Height = imOperation->Height;
            CCDImageROIAry[no].SetPlacement(x,y,w,h);
         }
         CCDImageROIAry[no].Draw(imOperation->Canvas->Handle);
      }

      // 2023 1 6 - chc RecipeSet
      else if(frmRecipeSet->Visible == true && frmRecipeSet->pcWaferInformation->ActivePage == frmRecipeSet->tsMicro) {
         w = frmRecipeSet->imInspection->Width;
         h = frmRecipeSet->imInspection->Height;
         GetImageXY(width,height,sx,sy,w,h,&x,&y);
         if(frmRecipeSet->cbCCDFullImage->Checked == true) {
            frmRecipeSet->imInspection->Picture->Bitmap->Width = width;
            frmRecipeSet->imInspection->Picture->Bitmap->Height = height;
            CCDImageROIAry[no].SetPlacement(0,0,width,height);
         }
         else {
            // 要設Size
            frmRecipeSet->imInspection->Picture->Bitmap->Width = w;
            frmRecipeSet->imInspection->Picture->Bitmap->Height = h;
            CCDImageROIAry[no].SetPlacement(x,y,w,h);
         }
         CCDImageROIAry[no].Draw(frmRecipeSet->imInspection->Canvas->Handle);
      }
      else if(pnlEFEM->Visible == false)

         //WriteSystemLog("Show-6");
         CCDImageROIAry[no].Draw(imCCD->Canvas->Handle);
      //WriteSystemLog("Show-7");
      */

      // 計算平均灰階
      ComputeAverageGray();
   }
   // Color
   else {
      //WriteSystemLog("Show-8");
      //WriteSystemLog("Show-Color");

      // Color : usb_ImageAry
      i = 0;
      for(int row=height-1 ; row>=0 ; row--) {
         pt = (unsigned char *)usb_ImageAry[no].GetImagePtr(0,row);
         // 由buffer到pt
         memcpy(pt, &buffer[i],width*3);
         i += (width*3);
      }

      // imOperation
      if(frmInspection->Visible == false && pnlMaintenance->Visible == true && pcMaintenance->ActivePage == tsMainCCD) {
         w = imOperation->Width;
         h = imOperation->Height;
         if(cbCCDFullImage->Checked == true) {
            w = width;
            h = height;
         }
         sx = (width - imOperation->Width) / 2;
         sy = (height - imOperation->Height) / 2;
         LaserCenterX = sx;
         LaserCenterY = sy;
         CCDRangeX = sx;
         CCDRangeY = sy;
         imOperation->Picture->Bitmap->Width = w;
         imOperation->Picture->Bitmap->Height = h;
         usb_ImageROIAry[no].Detach();
         usb_ImageROIAry[no].Attach(&usb_ImageAry[no]);
         GetImageXY(width,height,sx,sy,w,h,&x,&y);
         usb_ImageROIAry[no].SetPlacement(x,y,w,h);
         usb_ImageROIAry[no].Draw(imOperation->Canvas->Handle);
         imOperation->Refresh();
         //WriteSystemLog("Show-0: imOperation");
      }
      else if(frmInspection->Visible == true && frmInspection->pcInspection->ActivePage == frmInspection->tsMicroInspection &&
         frmInspection->cbFreeze->Checked == false) {
         // frmInspection->imInspection
         w = frmInspection->imInspection->Width;
         h = frmInspection->imInspection->Height;
         if(frmInspection->cbCCDFullImage->Checked == true) {
            w = width;
            h = height;
         }
         sx = (width - frmInspection->imInspection->Width) / 2;
         sy = (height - frmInspection->imInspection->Height) / 2;
         frmInspection->LaserCenterX = sx;
         frmInspection->LaserCenterY = sy;
         frmInspection->CCDRangeX = sx;
         frmInspection->CCDRangeY = sy;
         frmInspection->imInspection->Picture->Bitmap->Width = w;
         frmInspection->imInspection->Picture->Bitmap->Height = h;
         usb_ImageROIAry[no].Detach();
         usb_ImageROIAry[no].Attach(&usb_ImageAry[no]);
         GetImageXY(width,height,sx,sy,w,h,&x,&y);
         usb_ImageROIAry[no].SetPlacement(x,y,w,h);
         usb_ImageROIAry[no].Draw(frmInspection->imInspection->Canvas->Handle);
         frmInspection->imInspection->Refresh();
         //WriteSystemLog("Show-0: frmInspection");
      }
      // frmRecipeSet->imInspection
      else if(frmRecipeSet->Visible == true && frmRecipeSet->pcWaferInformation->ActivePage == frmRecipeSet->tsMicro &&
         frmRecipeSet->cbFreeze->Checked == false) {
         w = frmRecipeSet->imInspection->Width;
         h = frmRecipeSet->imInspection->Height;
         if(frmRecipeSet->cbCCDFullImage->Checked == true) {
            w = width;
            h = height;
         }
         sx = (width - frmRecipeSet->imInspection->Width) / 2;
         sy = (height - frmRecipeSet->imInspection->Height) / 2;
         frmRecipeSet->LaserCenterX = sx;
         frmRecipeSet->LaserCenterY = sy;
         frmRecipeSet->CCDRangeX = sx;
         frmRecipeSet->CCDRangeY = sy;
         frmRecipeSet->imInspection->Picture->Bitmap->Width = w;
         frmRecipeSet->imInspection->Picture->Bitmap->Height = h;
         usb_ImageROIAry[no].Detach();
         usb_ImageROIAry[no].Attach(&usb_ImageAry[no]);
         GetImageXY(width,height,sx,sy,w,h,&x,&y);
         usb_ImageROIAry[no].SetPlacement(x,y,w,h);
         usb_ImageROIAry[no].Draw(frmRecipeSet->imInspection->Canvas->Handle);
         frmRecipeSet->imInspection->Refresh();
         //WriteSystemLog("Show-0: frmRecipeSet");
      }
      else if(pnlEFEM->Visible == false) {
         // imCCD
         w = imCCD->Width;
         h = imCCD->Height;
         if(cbCCDFullImage->Checked == true) {
            w = width;
            h = height;
         }
         sx = (width - imCCD->Width) / 2;
         sy = (height - imCCD->Height) / 2;
         LaserCenterX = sx;
         LaserCenterY = sy;
         CCDRangeX = sx;
         CCDRangeY = sy;
         imCCD->Picture->Bitmap->Width = w;
         imCCD->Picture->Bitmap->Height = h;
         usb_ImageROIAry[no].Detach();
         usb_ImageROIAry[no].Attach(&usb_ImageAry[no]);
         GetImageXY(width,height,sx,sy,w,h,&x,&y);
         usb_ImageROIAry[no].SetPlacement(x,y,w,h);
         usb_ImageROIAry[no].Draw(imCCD->Canvas->Handle);
         imCCD->Refresh();
         //WriteSystemLog("Show-0: imCCD");
      }

      /*
      usb_ImageROIAry[no].Detach();
      usb_ImageROIAry[no].Attach(&usb_ImageAry[no]);

      if(cbCCDFullImage->Checked == true) {
         imCCD->Picture->Bitmap->Width = width;
         imCCD->Picture->Bitmap->Height = height;
         usb_ImageROIAry[no].SetPlacement(0,0,width,height);
      }
      else {
         // 要設Size
         imCCD->Picture->Bitmap->Width = w;
         imCCD->Picture->Bitmap->Height = h;
         usb_ImageROIAry[no].SetPlacement(x,y,w,h);
      }

      // 2022 9 4 - chc Inspection
      if(frmInspection->Visible == true && frmInspection->pcInspection->ActivePage == frmInspection->tsMicroInspection &&
         frmInspection->cbFreeze->Checked == false) {
         w = frmInspection->imInspection->Width;
         h = frmInspection->imInspection->Height;
         GetImageXY(width,height,sx,sy,w,h,&x,&y);
         if(frmInspection->cbCCDFullImage->Checked == true) {
            frmInspection->imInspection->Picture->Bitmap->Width = width;
            frmInspection->imInspection->Picture->Bitmap->Height = height;
            usb_ImageROIAry[no].SetPlacement(0,0,width,height);
         }
         else {
            frmInspection->imInspection->Picture->Bitmap->Width = frmInspection->imInspection->Width;
            frmInspection->imInspection->Picture->Bitmap->Height = frmInspection->imInspection->Height;
            usb_ImageROIAry[no].SetPlacement(x,y,w,h);
         }
         usb_ImageROIAry[no].Draw(frmInspection->imInspection->Canvas->Handle);
      }

      // 2022 12 6 - chc Display CCD
      else if(frmInspection->Visible == false && pnlMaintenance->Visible == true && pcMaintenance->ActivePage == tsMainCCD &&
              frmInspection->cbFreeze->Checked == false) {
         w = imOperation->Width;
         h = imOperation->Height;
         GetImageXY(width,height,sx,sy,w,h,&x,&y);
         if(cbCCDFullImage->Checked == true) {
            imOperation->Picture->Bitmap->Width = width;
            imOperation->Picture->Bitmap->Height = height;
            usb_ImageROIAry[no].SetPlacement(0,0,width,height);
         }
         else {
            imOperation->Picture->Bitmap->Width = imOperation->Width;
            imOperation->Picture->Bitmap->Height = imOperation->Height;
            usb_ImageROIAry[no].SetPlacement(x,y,w,h);
         }
         usb_ImageROIAry[no].Draw(imOperation->Canvas->Handle);
      }

      // 2023 1 6 - chc RecipeSet
      else if(frmRecipeSet->Visible == true && frmRecipeSet->pcWaferInformation->ActivePage == frmRecipeSet->tsMicro &&
              frmRecipeSet->cbFreeze->Checked == false) {
         w = frmRecipeSet->imInspection->Width;
         h = frmRecipeSet->imInspection->Height;
         GetImageXY(width,height,sx,sy,w,h,&x,&y);
         if(frmRecipeSet->cbCCDFullImage->Checked == true) {
            frmRecipeSet->imInspection->Picture->Bitmap->Width = width;
            frmRecipeSet->imInspection->Picture->Bitmap->Height = height;
            usb_ImageROIAry[no].SetPlacement(0,0,width,height);
         }
         else {
            // 要設Size
            frmRecipeSet->imInspection->Picture->Bitmap->Width = w;
            frmRecipeSet->imInspection->Picture->Bitmap->Height = h;
            usb_ImageROIAry[no].SetPlacement(x,y,w,h);
         }
         usb_ImageROIAry[no].Draw(frmRecipeSet->imInspection->Canvas->Handle);
      }

      else if(pnlEFEM->Visible == false)

         usb_ImageROIAry[no].Draw(imCCD->Canvas->Handle);
      imOperation->Refresh();
      frmInspection->imInspection->Refresh();
      frmRecipeSet->imInspection->Refresh();
      */
   }

   // 2022 9 4 - chc Inspection
   /*
   if(frmInspection->Visible == true && frmInspection->pcInspection->ActivePage == frmInspection->tsMicroInspection &&
      frmInspection->cbFreeze->Checked == false) {
      frmInspection->imInspection->Refresh();
   }

   // 2022 12 6 - chc Display CCD
   else if(frmInspection->Visible == false && pnlMaintenance->Visible == true && pcMaintenance->ActivePage == tsMainCCD) {
      imOperation->Refresh();
   }
   else

      // 若沒有Refresh就不會顯示
      imCCD->Refresh();
   //WriteSystemLog("Show-9");
   */

   // Basler Pylon GigE CCD: 計算Capture Rate
   boolBaslerImageLoadedAry[no] = true;
   boolCCDImageLoadedAry[no] = true;
   BaslerCaptureNoAry[no]++;
   if((count % 5) == 0) {
      GetTimeTic(&BaslerStopTimeAry[no],&BaslerStopTickAry[no]);
      BaslerElapsedmsAry[no] = ((BaslerStopTimeAry[no]*1000+BaslerStopTickAry[no]) - (BaslerStartTimeAry[no]*1000+BaslerStartTickAry[no]));
      double ratio;
      AnsiString msg;
      // Devide by zero
      if(BaslerElapsedmsAry[no] != 0) {
         ratio = ((double)BaslerCaptureNoAry[no] * 1000.0) / BaslerElapsedmsAry[no];
         msg.sprintf("%.1f",ratio);
         pnlCapturedNo->Caption = msg;
      }
   }

   // 未在影像處理中
   boolInGigaBufferAry[no] = false;
   tmISCCD->Enabled = true;
   pnlISCCDCapture->Color = clSilver;
   pnlISCCDCapture->Refresh();
   //WriteSystemLog("Show-0: end");
}
//---------------------------------------------------------------------------
// Setup CCD
// 要取得: no(CCD編號/序號), name(CCD名稱), type(BW/Color), Width, Height
//struct CCDINFO_STRU        {
//   int width,Height;
//   int No;
//   int PixelSize;
//   int Type;
//   AnsiString Name;
//};
//struct CCDINFO_STRU        CCDInfoAry[3];
void __fastcall TfrnMain::SetupCCD(int ccdtype)
{
int baslerccdno;
AnsiString msg;
int pos,pixelsize,width,height;
AnsiString ccdname,deviceid;
// 設定為自動還是手動
bool boolauto = true;

   CCDType = CCD_TYPE_NONE;
   WriteSystemLog("Setup CCD: 1");
   // CCD編號(0/1/2/3...)
   baslerccdno = 0;
   WriteSystemLog("Setup CCD: 2");
   // 最多三個CCD
   for(int i=0 ; i<3 ; i++)
      bool_CCD_StatusAry[i] = false;

   // Basler
   if(ccdtype == 2)
      goto basler;

   WriteSystemLog("Setup CCD: [" + ISCCDName + "], [" + ISCCDSerialNo + "]");
   if(boolCCD == false) {
      WriteSystemLog("Setup CCD: CCD未啟動! 強制為啟動.");
      boolCCD = true;
      goto ccdok;
      return;
   }

ccdok:
   // 2019 7 5 - chc 透過ShowDeviceSettingDialog來設定
   //---------------------------------------------------------------------------
   // CCD1
   if(boolauto == false) {
      ICImagingControl1->ShowDeviceSettingsDialog();
      WriteSystemLog("CCD: " + ICImagingControl1->Device + "," + ICImagingControl1->DeviceUniqueName + "," + IntToStr(ICImagingControl1->ImageWidth));
      WriteSystemLog("CCD: bit= " + IntToStr(ICImagingControl1->ImageBitsPerPixel));
   }
   else {
      try {
         ICImagingControl1->Device = ISCCDName;                                       // "DFK 33G274";
         WriteSystemLog("Setup CCD: ISCCDName");
         ICImagingControl1->DeviceUniqueName = ISCCDName + " " + ISCCDSerialNo;       // "DFK 33G274 11124360";
         CCDType = CCD_TYPE_IS;
      }
      catch(Exception &e) {
         pnlISCCDStaus->Color = clRed;
         pnlCCD->Color = clRed;
         WriteSystemLog("Setup ImagingSource CCD - Exception error");
         //sbSystem->Panels->Items[1]->Text = "Setup ImagingSource CCD - Exception Error";
         boolCCD = false;
         goto setccd2;
      }
   }
   WriteSystemLog("Setup CCD: Enable...");
   try {
      if(boolauto == true) {                                                                         // 43614991(AUO1)
         ICImagingControl1->Enabled = true;
         MakeDeviceSettings();
      }
      if(ICImagingControl1->DeviceValid == true) {
         WriteSystemLog("Setup CCD Device: ok");
         numDevices = 1;
         bool_CCD_StatusAry[0] = true;
         // CCD: 取得編號, 名稱, Bit數, Width, Height
         CCDInfoAry[baslerccdno].No = 0;                                           // First CCD
         CCDInfoAry[baslerccdno].Name = ISCCDName;
         CCDInfoAry[baslerccdno].PixelSize = ICImagingControl1->ImageBitsPerPixel / 8;
         CCDInfoAry[baslerccdno].Width = ICImagingControl1->ImageWidth;
         CCDInfoAry[baslerccdno].Height = ICImagingControl1->ImageHeight;
         CCDInfoAry[baslerccdno].DeviceID = ISCCDSerialNo;;

         GigaWidth = CCDInfoAry[baslerccdno].Width;
         GigaHeight = CCDInfoAry[baslerccdno].Height;

         AlignWidth = imCCD->Width;
         AlignHeight = imCCD->Height - 50;

         // Color or BW
         WriteSystemLog("CCD Bits: " + IntToStr(ICImagingControl1->ImageBitsPerPixel));
         if(ICImagingControl1->ImageBitsPerPixel > 8) {
            CCDInfoAry[baslerccdno].Type = CCD_COLOR;
            WriteSystemLog("CCD: Color");
         }
         else {
            CCDInfoAry[baslerccdno].Type = CCD_BW;
            WriteSystemLog("CCD: Gray");
         }

         // Live
         ICImagingControl1->LiveStart();
         // 2022 12 27 - chc FormShow後再啟動
         //tmISCCD->Enabled = true;
         pnlISCCDStaus->Color = clLime;
         pnlCCD->Color = clGreen;
         msg.sprintf("%dx%d %d %s 3.75um",CCDInfoAry[baslerccdno].Width,CCDInfoAry[baslerccdno].Height,CCDInfoAry[baslerccdno].PixelSize,CCDInfoAry[baslerccdno].DeviceID.c_str());
         pnlISCCDInfo->Caption = msg;
         WriteSystemLog(msg);
         msg.sprintf("%dx%d %d",CCDInfoAry[baslerccdno].Width,CCDInfoAry[baslerccdno].Height,CCDInfoAry[baslerccdno].PixelSize);
         pnlCCDSize->Caption = msg;
         // 不能設為Live, 設為Live就會啟動Basler的取像與顯示作業
         //CCDThreadAry[baslerccdno]->boolBaslerLive = true;
         BaslerCaptureNoAry[baslerccdno] = 0;
         GetTimeTic(&BaslerStartTimeAry[baslerccdno],&BaslerStartTickAry[baslerccdno]);
         btnReviewLive->Caption = "Grab";

         WriteSystemLog("Set CCD Shutter and Gain");
         // 設定Gain/Shutter: CCDShutter, CCDGain
         rgCCDShutter->ItemIndex = CCDShutterAry[0];
         WriteSystemLog("Set CCD Shutter and Gain - 1");
         rgCCDShutterClick(this);
         WriteSystemLog("Set CCD Shutter and Gain - 2");
         tbCCDGain->Position = CCDGain;
         pnlCCDGain->Caption = IntToStr(CCDGain);
         WriteSystemLog("Setup CCD: Shutter,Gain= " + IntToStr(CCDShutter) + "," + IntToStr(CCDGain));

      }
      else {
         WriteSystemLog("Setup CCD Device: fail");
         pnlISCCDStaus->Color = clRed;
         pnlCCD->Color = clRed;
      }
   }
   catch(Exception &e) {
      pnlISCCDStaus->Color = clRed;
      pnlCCD->Color = clRed;
      WriteSystemLog("Setup ImagingSource CCD - Error");
      sbSystem->Panels->Items[1]->Text = "Setup ImagingSource CCD - Error";
   }
   //---------------------------------------------------------------------------
setccd2:

   // 2023 1 11 - chc Hirata(Tazmo)
   if(RobotMode != ROBOT_MODE_TAZMO) {
      goto end;
   }

   // CCD2
   baslerccdno++;
   if(boolauto == false) {
      ICImagingControl2->ShowDeviceSettingsDialog();
      WriteSystemLog("CCD: " + ICImagingControl2->Device + "," + ICImagingControl2->DeviceUniqueName + "," + IntToStr(ICImagingControl2->ImageWidth));
      WriteSystemLog("CCD: bit= " + IntToStr(ICImagingControl2->ImageBitsPerPixel));
   }
   else {
      try {
         ICImagingControl2->Device = ISCCDName;                                       // "DFK 33G274";
         WriteSystemLog("Setup CCD: ISCCD2Name");
         ICImagingControl2->DeviceUniqueName = ISCCD2Name + " " + ISCCD2SerialNo;       // "DFK 33G274 11124360";
         CCDType = CCD_TYPE_IS;
      }
      catch(Exception &e) {
         pnlISCCD2Staus->Color = clRed;
         frmInspection->pnlLeftCCD->Color = clRed;
         boolCCD2 = false;
         WriteSystemLog("Setup ImagingSource CCD2 - Exception error");
         //sbSystem->Panels->Items[1]->Text = "Setup ImagingSource CCD2 - Exception Error";
         goto setccd3;
      }
   }
   WriteSystemLog("Setup CCD2: Enable...");
   try {
      if(boolauto == true) {                                                                         // 43614991(AUO1)
         ICImagingControl2->Enabled = true;
         MakeDeviceSettings_2();
      }
      if(ICImagingControl2->DeviceValid == true) {
         WriteSystemLog("Setup CCD2 Device: ok");
         numDevices++;
         bool_CCD_StatusAry[baslerccdno] = true;
         // CCD: 取得編號, 名稱, Bit數, Width, Height
         CCDInfoAry[baslerccdno].No = 0;                                           // First CCD
         CCDInfoAry[baslerccdno].Name = ISCCD2Name;
         CCDInfoAry[baslerccdno].PixelSize = ICImagingControl2->ImageBitsPerPixel / 8;
         CCDInfoAry[baslerccdno].Width = ICImagingControl2->ImageWidth;
         CCDInfoAry[baslerccdno].Height = ICImagingControl2->ImageHeight;
         CCDInfoAry[baslerccdno].DeviceID = ISCCD2SerialNo;;

         GigaWidth = CCDInfoAry[baslerccdno].Width;
         GigaHeight = CCDInfoAry[baslerccdno].Height;

         AlignWidth = imCCD->Width;
         AlignHeight = imCCD->Height - 50;

         // Color or BW
         WriteSystemLog("CCD2 Bits: " + IntToStr(ICImagingControl2->ImageBitsPerPixel));
         if(ICImagingControl2->ImageBitsPerPixel > 8) {
            CCDInfoAry[baslerccdno].Type = CCD_COLOR;
            WriteSystemLog("CCD2: Color");
         }
         else {
            CCDInfoAry[baslerccdno].Type = CCD_BW;
            WriteSystemLog("CCD2: Gray");
         }

         // Live
         ICImagingControl2->LiveStart();
         // 2022 12 27 - chc FormShow後再啟動
         //tmISLeftCCD->Enabled = true;
         pnlISCCD2Staus->Color = clLime;
         frmInspection->pnlLeftCCD->Color = clGreen;
         msg.sprintf("%dx%d %d %s 3.75um",CCDInfoAry[baslerccdno].Width,CCDInfoAry[baslerccdno].Height,CCDInfoAry[baslerccdno].PixelSize,CCDInfoAry[baslerccdno].DeviceID.c_str());
         pnlISCCD2Info->Caption = msg;
         WriteSystemLog(msg);
         msg.sprintf("%dx%d %d",CCDInfoAry[baslerccdno].Width,CCDInfoAry[baslerccdno].Height,CCDInfoAry[baslerccdno].PixelSize);
         //pnlCCDSize->Caption = msg;
         //btnReviewLive->Caption = "Grab";
         // 不能設為Live, 設為Live就會啟動Basler的取像與顯示作業
         //CCDThreadAry[baslerccdno]->boolBaslerLive = true;
         BaslerCaptureNoAry[baslerccdno] = 0;
         GetTimeTic(&BaslerStartTimeAry[baslerccdno],&BaslerStartTickAry[baslerccdno]);

         WriteSystemLog("Set CCD2 Shutter and Gain");
         // 設定Gain/Shutter: CCDShutter, CCDGain
         rgCCDShutter->ItemIndex = CCDShutterAry[baslerccdno];
         WriteSystemLog("Set CCD Shutter and Gain - 1");
         rgCCDShutterClick(this);
         WriteSystemLog("Set CCD Shutter and Gain - 2");
         tbCCDGain->Position = CCDGainAry[baslerccdno];
         pnlCCDGain->Caption = IntToStr(CCDGainAry[baslerccdno]);
         WriteSystemLog("Setup CCD2: Shutter,Gain= " + IntToStr(CCDShutterAry[baslerccdno]) + "," + IntToStr(CCDGainAry[baslerccdno]));

      }
      else {
         WriteSystemLog("Setup CCD2 Device: fail");
         pnlISCCD2Staus->Color = clRed;
         frmInspection->pnlLeftCCD->Color = clRed;
      }
   }
   catch(Exception &e) {
      pnlISCCD2Staus->Color = clRed;
      frmInspection->pnlLeftCCD->Color = clRed;
      WriteSystemLog("Setup ImagingSource CCD2 - Error");
      sbSystem->Panels->Items[1]->Text = "Setup ImagingSource CCD2 - Error";
   }
   //---------------------------------------------------------------------------
setccd3:
   // CCD3
   baslerccdno++;
   if(boolauto == false) {
      ICImagingControl3->ShowDeviceSettingsDialog();
      WriteSystemLog("CCD: " + ICImagingControl3->Device + "," + ICImagingControl3->DeviceUniqueName + "," + IntToStr(ICImagingControl3->ImageWidth));
      WriteSystemLog("CCD: bit= " + IntToStr(ICImagingControl3->ImageBitsPerPixel));
   }
   else {
      try {
         ICImagingControl3->Device = ISCCDName;                                       // "DFK 33G274";
         WriteSystemLog("Setup CCD: ISCCD3Name");
         ICImagingControl3->DeviceUniqueName = ISCCD3Name + " " + ISCCD3SerialNo;       // "DFK 33G274 11124360";
         CCDType = CCD_TYPE_IS;
      }
      catch(Exception &e) {
         pnlISCCD3Staus->Color = clRed;
         frmInspection->pnlRightCCD->Color = clRed;
         boolCCD3 = false;
         WriteSystemLog("Setup ImagingSource CCD3 - Exception error");
         //sbSystem->Panels->Items[1]->Text = "Setup ImagingSource CCD2 - Exception Error";
         return;
      }
   }
   WriteSystemLog("Setup CCD3: Enable...");
   try {
      if(boolauto == true) {                                                                         // 43614991(AUO1)
         ICImagingControl3->Enabled = true;
         MakeDeviceSettings_3();
      }
      if(ICImagingControl3->DeviceValid == true) {
         WriteSystemLog("Setup CCD3 Device: ok");
         numDevices++;
         bool_CCD_StatusAry[baslerccdno] = true;
         // CCD: 取得編號, 名稱, Bit數, Width, Height
         CCDInfoAry[baslerccdno].No = 0;                                           // First CCD
         CCDInfoAry[baslerccdno].Name = ISCCD2Name;
         CCDInfoAry[baslerccdno].PixelSize = ICImagingControl3->ImageBitsPerPixel / 8;
         CCDInfoAry[baslerccdno].Width = ICImagingControl3->ImageWidth;
         CCDInfoAry[baslerccdno].Height = ICImagingControl3->ImageHeight;
         CCDInfoAry[baslerccdno].DeviceID = ISCCD3SerialNo;;

         GigaWidth = CCDInfoAry[baslerccdno].Width;
         GigaHeight = CCDInfoAry[baslerccdno].Height;

         AlignWidth = imCCD->Width;
         AlignHeight = imCCD->Height - 50;

         // Color or BW
         WriteSystemLog("CCD3 Bits: " + IntToStr(ICImagingControl3->ImageBitsPerPixel));
         if(ICImagingControl3->ImageBitsPerPixel > 8) {
            CCDInfoAry[baslerccdno].Type = CCD_COLOR;
            WriteSystemLog("CCD3: Color");
         }
         else {
            CCDInfoAry[baslerccdno].Type = CCD_BW;
            WriteSystemLog("CCD3: Gray");
         }

         // Live
         ICImagingControl3->LiveStart();
         // 2022 12 27 - chc FormShow後再啟動
         //tmISRightCCD->Enabled = true;
         pnlISCCD3Staus->Color = clLime;
         frmInspection->pnlRightCCD->Color = clGreen;
         msg.sprintf("%dx%d %d %s 3.75um",CCDInfoAry[baslerccdno].Width,CCDInfoAry[baslerccdno].Height,CCDInfoAry[baslerccdno].PixelSize,CCDInfoAry[baslerccdno].DeviceID.c_str());
         pnlISCCD3Info->Caption = msg;
         WriteSystemLog(msg);
         msg.sprintf("%dx%d %d",CCDInfoAry[baslerccdno].Width,CCDInfoAry[baslerccdno].Height,CCDInfoAry[baslerccdno].PixelSize);
         //pnlCCDSize->Caption = msg;
         //btnReviewLive->Caption = "Grab";
         // 不能設為Live, 設為Live就會啟動Basler的取像與顯示作業
         //CCDThreadAry[baslerccdno]->boolBaslerLive = true;
         BaslerCaptureNoAry[baslerccdno] = 0;
         GetTimeTic(&BaslerStartTimeAry[baslerccdno],&BaslerStartTickAry[baslerccdno]);

         WriteSystemLog("Set CCD3 Shutter and Gain");
         // 設定Gain/Shutter: CCDShutter, CCDGain
         rgCCDShutter->ItemIndex = CCDShutterAry[baslerccdno];
         WriteSystemLog("Set CCD Shutter and Gain - 1");
         rgCCDShutterClick(this);
         WriteSystemLog("Set CCD Shutter and Gain - 2");
         tbCCDGain->Position = CCDGainAry[baslerccdno];
         pnlCCDGain->Caption = IntToStr(CCDGainAry[baslerccdno]);
         WriteSystemLog("Setup CCD3: Shutter,Gain= " + IntToStr(CCDShutterAry[baslerccdno]) + "," + IntToStr(CCDGainAry[baslerccdno]));

      }
      else {
         WriteSystemLog("Setup CCD3 Device: fail");
         pnlISCCD3Staus->Color = clRed;
         frmInspection->pnlRightCCD->Color = clRed;
      }
   }
   catch(Exception &e) {
      pnlISCCD3Staus->Color = clRed;
      frmInspection->pnlRightCCD->Color = clRed;
      WriteSystemLog("Setup ImagingSource CCD3 - Error");
      sbSystem->Panels->Items[1]->Text = "Setup ImagingSource CCD3 - Error";
   }
end:
   WriteSystemLog("Setup CCD: Finished.");
   return;

basler:
//
   WriteSystemLog("PylonInitialize()...");
   //---------------------------------------------------------------------------
   // Basler
   try {
      // Before using any pylon methods, the pylon runtime must be initialized.
      PylonInitialize();
   }
   catch(Exception &e) {
      WriteSystemLog("PylonInitialize() Fail!");
      pnlSystemMessage->Caption = "PylonInitialize() Fail!";
      return;
   }
   WriteSystemLog(">SetupscA1300-1");
   // Enumerate all camera devices. You must call PylonEnumerateDevices() before creating a device!
   res = PylonEnumerateDevices((unsigned int *)&numDevices);
   WriteSystemLog(">SetupscA1300-2");
   if(0 == numDevices) {
      pnlSystemMessage->Caption = "No GigE devices found!";
      pnlSystemMessage->Caption = "No devices found!";
      // Before exiting a program, PylonTerminate() should be called to release all pylon related resources.
      PylonTerminate();
      return;
   }

   boolCCD = true;
   CCDType = CCD_TYPE_BASLER;
   for(int i=0 ; i<numDevices ; i++) {
      baslerccdno = i;
      // Get a handle for the first device found.
      res = PylonCreateDeviceByIndex( baslerccdno, &hDevGigaAry[baslerccdno]);
      //CHECK(res);

      // Before using the device, it must be opened. Open it for configuring parameters and for grabbing images.
      res = PylonDeviceOpen( hDevGigaAry[baslerccdno], PYLONC_ACCESS_MODE_CONTROL | PYLONC_ACCESS_MODE_STREAM );
      //CHECK(res);
      {
         char buf[256];
         size_t siz = sizeof(buf);
         _Bool isReadable;
         ccdname = "";
         deviceid = "";
         width = 0;
         height = 0;
         pixelsize = 0;
         isReadable = PylonDeviceFeatureIsReadable(hDevGigaAry[baslerccdno], "DeviceModelName");
         if ( isReadable ) {
            res = PylonDeviceFeatureToString(hDevGigaAry[baslerccdno], "DeviceModelName", buf, &siz );
            //CHECK(res);
            lbGiga->Items->Add(buf);
            ccdname.sprintf("%s", buf);
            pnlSystemMessage->Caption = "CCDName: " + ccdname;
         }
      }

      //    Review(192.168.1.11): Basler scA1000-30gc(1032*778), 1/3", 4.65um*4.65um
      //    上(192.168.1.12): Basler scA1390-17gm(1392*1040), 1/2", 4.65um*4.65um
      //    下(192.168.1.13): Basler scA1390-17gm(1392*1040), 1/2", 4.65um*4.65um
      // 找gc or gm
      // bits per pixel
      res = PylonDeviceGetIntegerFeatureInt32( hDevGigaAry[baslerccdno], "PixelSize", &pixelsize);
      res = PylonDeviceGetIntegerFeatureInt32( hDevGigaAry[baslerccdno], "SensorWidth", &width);
      res = PylonDeviceGetIntegerFeatureInt32( hDevGigaAry[baslerccdno], "SensorHeight", &height);
      {
         char buf[256];
         size_t siz = sizeof(buf);
         _Bool isReadable;
         isReadable = PylonDeviceFeatureIsReadable(hDevGigaAry[baslerccdno], "DeviceID");
         if ( isReadable ) {
            res = PylonDeviceFeatureToString(hDevGigaAry[baslerccdno], "DeviceID", buf, &siz );
            //CHECK(res);
            lbGiga->Items->Add(buf);
            deviceid.sprintf("%s", buf);
            pnlSystemMessage->Caption = "CCD ID: " + deviceid;
            // 取得序號
            CCDSN = deviceid;
         }
      }

      // 2016 4 16 - chc 修正w/h: RealSize=>1278*958 - Sensor Size=>1294*964???
      if(width == 1294)
         width = 1278;
      if(height == 964)
         height = 958;
      if(pixelsize == 0) {
         lbGiga->Items->Add("PixelSize: 0 to 2!!!");
         pixelsize = 2;
      }

      // CCD: 取得編號, 名稱, Bit數, Width, Height
      CCDInfoAry[baslerccdno].No = baslerccdno;
      CCDInfoAry[baslerccdno].Name = ccdname;
      CCDInfoAry[baslerccdno].PixelSize = pixelsize;
      CCDInfoAry[baslerccdno].Width = width;
      CCDInfoAry[baslerccdno].Height = height;
      CCDInfoAry[baslerccdno].DeviceID = deviceid;
      pos = ccdname.Pos("gc");
      // BW
      if(pos == 0) {
         // CCD: 取得Type
         lbGiga->Items->Add("Gray CCD");
         CCDInfoAry[baslerccdno].Type = CCD_BW;
         WriteSystemLog(">CCD" + IntToStr(baslerccdno+1) + ": Gray");
         // Set the pixel format to Mono8, where gray values will be output as 8 bit values for each pixel.
         // ... Check first to see if the device supports the Mono8 format.
         isAvail = PylonDeviceFeatureIsAvailable(hDevGigaAry[baslerccdno],"EnumEntry_PixelFormat_Mono8");
         if(!isAvail) {
            pnlSystemMessage->Caption = "Device doesn't support the Mono8 pixel format";
            pnlSystemMessage->Caption = "Not support Mono8";
            // Before exiting a program, PylonTerminate() should be called to release all pylon related resources.
            PylonTerminate();
            return;
         }
         // ... Set the pixel format to Mono8.
         res = PylonDeviceFeatureFromString(hDevGigaAry[baslerccdno], "PixelFormat", "Mono8" );
         //CHECK(res);
      }
      // Color
      else {
         lbGiga->Items->Add("Color CCD: PixelSize=" + IntToStr(pixelsize));
         // CCD: 取得Type
         CCDInfoAry[baslerccdno].Type = CCD_COLOR;
         WriteSystemLog(">CCD" + IntToStr(baslerccdno+1) + ": Color");
         // Set the pixel format to Mono8, where gray values will be output as 8 bit values for each pixel.
         // ... Check first to see if the device supports the Mono8 format.

         // ###暫不處理: 可能YUV422只有16bits
         //isAvail = PylonDeviceFeatureIsAvailable(hDevGigaAry[baslerccdno],"EnumEntry_PixelFormat_RGB8Packed");
         //if(!isAvail) {
         //   pnlSystemMessage->Caption = "Device doesn't support the RGB8Packed pixel format";
         //   pnlSystemMessage->Caption = "Not support RGB8Packed";
         //   // Before exiting a program, PylonTerminate() should be called to release all pylon related resources.
         //   PylonTerminate();
         //   return;
         //}
         // ... Set the pixel format to RGB8Packed.
         //res = PylonDeviceFeatureFromString(hDevGigaAry[baslerccdno], "PixelFormat", "RGB8Packed" );

         //CHECK(res);
      }
      WriteSystemLog(">CCD" + IntToStr(baslerccdno+1) + ": " + ccdname + "," + deviceid + "," + IntToStr(CCDInfoAry[baslerccdno].PixelSize) + "," +
                           IntToStr(CCDInfoAry[baslerccdno].Width) + "," + IntToStr(CCDInfoAry[baslerccdno].Height));
      // Disable acquisition start trigger if available
      isAvail = PylonDeviceFeatureIsAvailable( hDevGigaAry[baslerccdno], "EnumEntry_TriggerSelector_AcquisitionStart");
      if(isAvail) {
         //res = PylonDeviceFeatureFromString( hDevGigaAry[baslerccdno], "TriggerSelector", "AcquisitionStart");
         //CHECK(res);
         //res = PylonDeviceFeatureFromString( hDevGigaAry[baslerccdno], "TriggerMode", "Off");
         //CHECK(res);
      }

      //Disable frame start trigger if available
      isAvail = PylonDeviceFeatureIsAvailable( hDevGigaAry[baslerccdno], "EnumEntry_TriggerSelector_FrameStart");
      if(isAvail) {
         // res = PylonDeviceFeatureFromString( hDevGigaAry[baslerccdno], "TriggerSelector", "FrameStart");
         //CHECK(res);
         // res = PylonDeviceFeatureFromString( hDevGigaAry[baslerccdno], "TriggerMode", "Off");
         //CHECK(res);
      }

      // 2011 10 9 - chc Software Trigger說明 - 參考範例
      // Software and Hardware Trigger -> TriggerSelector_FrameStart
      // Software -> TriggerSelector_AcquisitionStart
      // Camera uses the acquisition start trigger as the only trigger mode.
      //         Camera.TriggerSelector.SetValue(TriggerSelector_AcquisitionStart);
      //         Camera.TriggerMode.SetValue(TriggerMode_On);
      //         triggerSelectorValue = TriggerSelector_AcquisitionStart;
      // Enable continous acquisition mode
      //     Camera.AcquisitionMode.SetValue(AcquisitionMode_Continuous);
      // 無法作動, 先不用
      //res = PylonDeviceFeatureFromString( hDevGigaAry[baslerccdno], "TriggerSelector"  , "AcquisitionStart");
      //res = PylonDeviceFeatureFromString( hDevGigaAry[baslerccdno], "TriggerMode"      , "On");
      //res = PylonDeviceFeatureFromString( hDevGigaAry[baslerccdno], "TriggerSource"    , "Software");
      //res = PylonDeviceFeatureFromString( hDevGigaAry[baslerccdno], "AcquisitionMode"  , "Continuous");

      // For GigE cameras, we recommend increasing the packet size for better
      //    performance. If the network adapter supports jumbo frames, set the packet
      //    size to a value > 1500, e.g., to 8192. In this sample, we only set the packet size
      //    to 1500.
      // ... Check first to see if the GigE camera packet size parameter is supported
      //     and if it is writable.
      isAvail = PylonDeviceFeatureIsWritable(hDevGigaAry[baslerccdno], "GevSCPSPacketSize");
      if(isAvail) {
         // ... The device supports the packet size feature. Set a value.
         res = PylonDeviceSetIntegerFeature( hDevGigaAry[baslerccdno], "GevSCPSPacketSize", 1500 );
         //CHECK(res);
      }

      // Determine the required size of the grab buffer.
      res = PylonDeviceGetIntegerFeatureInt32( hDevGigaAry[baslerccdno], "PayloadSize", &payloadSize );
      //CHECK(res);
      // CCD: 取得TotalSize
      CCDInfoAry[baslerccdno].TotalSize = payloadSize;
      WriteSystemLog(">CCD" + IntToStr(baslerccdno+1) + " TotalSize: " + IntToStr(CCDInfoAry[baslerccdno].TotalSize));

      // Allocate memory for grabbing.
      imgBufAry[baslerccdno] = NULL;
      imgBufAry[baslerccdno] = (unsigned char*) malloc( payloadSize );
      if(imgBufAry[baslerccdno] == NULL) {
         pnlSystemMessage->Caption = "Out of memory";
         pnlSystemMessage->Caption = "Out of memory";
         // Before exiting a program, PylonTerminate() should be called to release all pylon related resources.
         PylonTerminate();
         lbGiga->Items->Add("Out of Memory!");
         return;
      }

      pnlCCDSize->Caption = IntToStr(CCDInfoAry[baslerccdno].Width) + "x" + IntToStr(CCDInfoAry[baslerccdno].Height) + " 3.75um";
      GigaWidth = CCDInfoAry[baslerccdno].Width;
      GigaHeight = CCDInfoAry[baslerccdno].Height;
      // 1100 * 890
      AlignWidth = imCCD->Width;
      AlignHeight = imCCD->Height;

      // 區分BW/Color
      if(CCDInfoAry[baslerccdno].Type == CCD_BW) {
         // 前面已Initial, 要先Detech
         CCDImageROIAry[baslerccdno].Detach();
         // scA1300的影像顯示改由EImageBW8 - CPU效能問題!!!!
         CCDImageAry[baslerccdno].SetSize(GigaWidth,GigaHeight);
         CCDImageROIAry[baslerccdno].Attach(&CCDImageAry[baslerccdno]);
         CCDImageROIAry[baslerccdno].SetPlacement((GigaWidth-AlignWidth)/2,(GigaHeight-AlignHeight)/2,AlignWidth,AlignHeight);

         // 2016 4 17 - chc 加入Mark
         CCDImageMarkROIAry[baslerccdno].Detach();
         CCDImageMarkROIAry[baslerccdno].Attach(&CCDImageAry[baslerccdno]);

      }
      else {
         // 前面已Initial, 要先Detech
         usb_ImageROIAry[baslerccdno].Detach();
         usb_ImageAry[baslerccdno].SetSize(GigaWidth,GigaHeight);
         usb_ImageROIAry[baslerccdno].Attach(&usb_ImageAry[baslerccdno]);
         usb_ImageROIAry[baslerccdno].SetPlacement((GigaWidth-AlignWidth)/2,(GigaHeight-AlignHeight)/2,AlignWidth,AlignHeight);

         // 2016 4 17 - chc 加入Mark
         usb_ImageMarkROIAry[baslerccdno].Detach();
         usb_ImageMarkROIAry[baslerccdno].Attach(&usb_ImageROIAry[baslerccdno]);

      }
      lbGiga->Items->Add("CCD " + IntToStr(baslerccdno+1) + " Initial Success.");
      bool_scA1300_StatusAry[baslerccdno] = true;
      boolBaslerGrabbedAry[baslerccdno] = false;
      boolBaslerImageLoadedAry[baslerccdno] = false;
      boolInGigaSaveAry[baslerccdno] = false;
      // 建立Thread
      scA1300ThreadAry[baslerccdno] = new TscA1300(true, baslerccdno+1, CCDInfoAry[baslerccdno].Name, CCDInfoAry[baslerccdno].Type,
                                   CCDInfoAry[baslerccdno].Width, CCDInfoAry[baslerccdno].Height);

      lbGiga->Items->Add("CCD Thread Created.");
      // 設定選項
//    Review(192.168.1.11): Basler scA1000-30gc(1032*778), 1/3", 4.65um*4.65um  Device ID=21699292
//    上(192.168.1.12): Basler scA1390-17gm(1392*1040), 1/2", 4.65um*4.65um     Device ID=21706344
//    下(192.168.1.13): Basler scA1390-17gm(1392*1040), 1/2", 4.65um*4.65um     Device ID=21706349
      // ### 暫不處理
      //if(CCDInfoAry[baslerccdno].DeviceID == "21699292") {
      //   rgCCDSelect->Items->Strings[baslerccdno] = "Color(R)";
      //}
      //else if(CCDInfoAry[baslerccdno].DeviceID == "21706344") {
      //   rgCCDSelect->Items->Strings[baslerccdno] = "Gray(U)";
      //}
      //else {
      //   rgCCDSelect->Items->Strings[baslerccdno] = "Gray(D)";
      //}

      // Let the camera acquire images continuously ( Acquisiton mode equals
      // Continuous! )
      //Camera.AcquisitionStart.Execute();
      PylonDeviceExecuteCommandFeature(hDevGigaAry[baslerccdno], "AcquisitionStart");
      // 取得StreamGrabber
      //PylonDeviceGetStreamGrabber(PYLON_DEVICE_HANDLE hDevscA1300, size_t index, RETVAL_PAR PYLON_STREAMGRABBER_HANDLE *phStg);
      PylonDeviceGetStreamGrabber(hDevGigaAry[baslerccdno], 0, &hStg);

      // 改變Shutter/Gain
      rgCCDShutter->ItemIndex = scA1300ShutterAry[baslerccdno];
      //rgCCDShutterClick(this);
      lbGiga->Items->Add("Basler CCD Gain: " + IntToStr(scA1300GainAry[baslerccdno]));
      tbCCDGain->Position = scA1300GainAry[baslerccdno];
      //tbCCDGainChange(this);

      lbGiga->Items->Add("Setup CCD Ok.");
   }
   //---------------------------------------------------------------------------
//

   return;
}
//---------------------------------------------------------------------------
// 2021 5 16 - chc Check Range
// sx,sy: 目前可視區域的起點: Scrollbar的Position值
void __fastcall TfrnMain::CheckRange(int *sx, int *sy)
{
bool boolover;

   boolover = false;
   // X
   if(*sx < 0) {
      *sx = 0;
      boolover = true;
   }
   if(*sx > (CCDDx-1)) {
      *sx = CCDDx-1;
      boolover = true;
   }
   // Y
   if(*sy < 0) {
      *sy = 0;
      boolover = true;
   }
   if(*sy > (CCDDy-1)) {
      *sy = CCDDy-1;
      boolover = true;
   }
   // Over
   /*
   if(boolover == true) {
      if(pnlLaserCenterPosition->Color == 0x003C9F82)
         pnlLaserCenterPosition->Color = 0x00FF8080;
   }
   // Fit
   else {
      if(pnlLaserCenterPosition->Color != 0x003C9F82)
         pnlLaserCenterPosition->Color = 0x003C9F82;
   }
   */
}
//---------------------------------------------------------------------------
// 取得影像區域
// width,height: CCD解析度
// sx,sy: 目前可視區域的起點, Scrollbar的Position值
// w,h: imCCD解析度
void __fastcall TfrnMain::GetImageXY(int width,int height,int sx,int sy,int w,int h,int *x,int *y)
{
int px,py;

   if((sx + w) >= width)
      px = width - w;
   else
      px = sx;
   if((sy + h) >= height)
      py = height - h;
   else
      py = sy;
   *x = px;
   *y = py;
}
//---------------------------------------------------------------------------
void TfrnMain::GetTimeTic(long *time, short *millitm)
{
struct timeb t;

   ftime(&t);
   *time = t.time;
   *millitm = t.millitm;
}
//---------------------------------------------------------------------------
// 2021 5 16 - chc Init ImagingSource CCD
void __fastcall TfrnMain::MakeDeviceSettings()
{

   // 2021 4 19 - chc Log
   WriteSystemLog("MakeDeviceSettings()...");

   // Set the color format to monochrome
   //ICImagingControl1->MemoryCurrentGrabberColorformat = TIS.Imaging.ICImagingControlColorformats.ICY8;
   ICImagingControl1->MemoryCurrentGrabberColorformat = ICRGB24;

   // Set the ring buffer size to 5. This ensures that the last 5
   // acquired images are in memory.
   ICImagingControl1->ImageRingBufferSize = 5;

   // LiveCaptureContinuous = True means that every frame is
   // copied to the ring buffer.
   ICImagingControl1->LiveCaptureContinuous = true;

   // Do not save the last image, if liveStop is called
   ICImagingControl1->LiveCaptureLastImage = false;

   // Disable the live display. This allows to display images
   // from the ring buffer in ICImagingControl//s control window.
   ICImagingControl1->LiveDisplay = false;
   ICImagingControl1->LiveDisplayDefault = false;
   ICImagingControl1->LiveShowLastBuffer = false;

   // 2021 4 19 - chc 降至15fps: max 20fps
   //ICImagingControl1->DeviceFrameRate = 22;
   ICImagingControl1->DeviceFrameRate = 15;

   // 2016 12 5 - chc Exposure time(default=100), Move時要調高至1000-8000
   ICImagingControl1->ExposureAuto = false;
   ICImagingControl1->Exposure = 10000;

   // 2016 12 8 - chc Gain(default = 0)
   ICImagingControl1->GainAuto = false;
   //ICImagingControl1->Gain = 0;

   // 2016 12 15 - chc 設定Contrast值(Default = 0): -10 ~ 30(對比度)
   // => 沒用!!
   //ICImagingControl1->Contrast = 0;
   ICImagingControl1->Sharpness = 12;

   try {
      ICImagingControl1->ZoomAuto = false;
   }
   catch(Exception& e) {
      ;
   }
   ICImagingControl1->ScrollbarsEnabled = false;

   // Set the size of ICImagingControl to the width and height
   // of the currently selected video format.
   ICImagingControl1->Width = ICImagingControl1->ImageWidth;
   ICImagingControl1->Height = ICImagingControl1->ImageHeight;

   // 2021 4 19 - chc Log
   WriteSystemLog("MakeDeviceSettings().");

}
//---------------------------------------------------------------------------
// 2022 12 26 - chc Init ImagingSource CCD
void __fastcall TfrnMain::MakeDeviceSettings_2()
{

   WriteSystemLog("MakeDeviceSettings_2()...");

   // Set the color format to monochrome
   //ICImagingControl1->MemoryCurrentGrabberColorformat = TIS.Imaging.ICImagingControlColorformats.ICY8;
   ICImagingControl2->MemoryCurrentGrabberColorformat = ICRGB24;

   // Set the ring buffer size to 5. This ensures that the last 5
   // acquired images are in memory.
   ICImagingControl2->ImageRingBufferSize = 5;

   // LiveCaptureContinuous = True means that every frame is
   // copied to the ring buffer.
   ICImagingControl2->LiveCaptureContinuous = true;

   // Do not save the last image, if liveStop is called
   ICImagingControl2->LiveCaptureLastImage = false;

   // Disable the live display. This allows to display images
   // from the ring buffer in ICImagingControl//s control window.
   ICImagingControl2->LiveDisplay = false;
   ICImagingControl2->LiveDisplayDefault = false;
   ICImagingControl2->LiveShowLastBuffer = false;

   // 降至15fps: max 20fps
   ICImagingControl2->DeviceFrameRate = 15;

   // Exposure time(default=100), Move時要調高至1000-8000
   ICImagingControl2->ExposureAuto = false;
   ICImagingControl2->Exposure = 10000;

   // Gain(default = 0)
   ICImagingControl2->GainAuto = false;
   //ICImagingControl2->Gain = 0;

   // 設定Contrast值(Default = 0): -10 ~ 30(對比度)
   // => 沒用!!
   //ICImagingControl2->Contrast = 0;
   ICImagingControl2->Sharpness = 12;

   try {
      ICImagingControl2->ZoomAuto = false;
   }
   catch(Exception& e) {
      ;
   }
   ICImagingControl2->ScrollbarsEnabled = false;

   // Set the size of ICImagingControl to the width and height
   // of the currently selected video format.
   ICImagingControl2->Width = ICImagingControl2->ImageWidth;
   ICImagingControl2->Height = ICImagingControl2->ImageHeight;

   WriteSystemLog("MakeDeviceSettings_2().");

}
//---------------------------------------------------------------------------
// 2022 12 26 - chc Init ImagingSource CCD
void __fastcall TfrnMain::MakeDeviceSettings_3()
{

   WriteSystemLog("MakeDeviceSettings_3()...");

   // Set the color format to monochrome
   //ICImagingControl1->MemoryCurrentGrabberColorformat = TIS.Imaging.ICImagingControlColorformats.ICY8;
   ICImagingControl3->MemoryCurrentGrabberColorformat = ICRGB24;

   // Set the ring buffer size to 5. This ensures that the last 5
   // acquired images are in memory.
   ICImagingControl3->ImageRingBufferSize = 5;

   // LiveCaptureContinuous = True means that every frame is
   // copied to the ring buffer.
   ICImagingControl3->LiveCaptureContinuous = true;

   // Do not save the last image, if liveStop is called
   ICImagingControl3->LiveCaptureLastImage = false;

   // Disable the live display. This allows to display images
   // from the ring buffer in ICImagingControl//s control window.
   ICImagingControl3->LiveDisplay = false;
   ICImagingControl3->LiveDisplayDefault = false;
   ICImagingControl3->LiveShowLastBuffer = false;

   // 降至15fps: max 20fps
   ICImagingControl3->DeviceFrameRate = 15;

   // Exposure time(default=100), Move時要調高至1000-8000
   ICImagingControl3->ExposureAuto = false;
   ICImagingControl3->Exposure = 10000;

   // Gain(default = 0)
   ICImagingControl3->GainAuto = false;
   //ICImagingControl3->Gain = 0;

   // 設定Contrast值(Default = 0): -10 ~ 30(對比度)
   // => 沒用!!
   //ICImagingControl3->Contrast = 0;
   ICImagingControl3->Sharpness = 12;

   try {
      ICImagingControl3->ZoomAuto = false;
   }
   catch(Exception& e) {
      ;
   }
   ICImagingControl3->ScrollbarsEnabled = false;

   // Set the size of ICImagingControl to the width and height
   // of the currently selected video format.
   ICImagingControl3->Width = ICImagingControl3->ImageWidth;
   ICImagingControl3->Height = ICImagingControl3->ImageHeight;

   WriteSystemLog("MakeDeviceSettings_3().");

}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::rgCCDShutterClick(TObject *Sender)
{
int us;
double dus;

   // ImagingSource
   if(combCCDSelect->ItemIndex == 0) {
      if(pnlISCCDStaus->Color != clLime) {
         WriteSystemLog("CCD尚未偵測, 無法設定Shutter!");
         return;
      }
   }
   else if(combCCDSelect->ItemIndex == 1) {
      if(pnlISCCD2Staus->Color != clLime) {
         WriteSystemLog("CCD2尚未偵測, 無法設定Shutter!");
         return;
      }
   }
   else if(combCCDSelect->ItemIndex == 2) {
      if(pnlISCCD3Staus->Color != clLime) {
         WriteSystemLog("CCD3尚未偵測, 無法設定Shutter!");
         return;
      }
   }

   WriteSystemLog("rgCCDShutterClick() Enter...");
   us = rgCCDShutter->ItemIndex;
   if(us == 0)
      us = 1000000 / 2;
   else if(us == 1)
      us = 1000000 / 5;
   else if(us == 2)
      us = 1000000 / 15;
   else if(us == 3)
      us = 1000000 / 30;
   else if(us == 4)
      us = 1000000 / 60;
   else if(us == 5)
      us = 1000000 / 100;
   else if(us == 6)
      us = 1000000 / 200;
   else if(us == 7)
      us = 1000000 / 500;
   else if(us == 8)
      us = 1000000 / 1000;
   else if(us == 9)
      us = 1000000 / 2000;
   else if(us == 10)
      us = 1000000 / 4000;
   else if(us == 11)
      us = 1000000 / 6000;
   else if(us == 12)
      us = 1000000 / 8000;
   else if(us == 13)
      us = 1000000 / 10000;
   else if(us == 14)
      us = 1000000 / 12000;
   else if(us == 15)
      us = 1000000 / 15000;
   if(us < 60)
      us = 60;
   else if(us > 500000)
      us = 500000;

   // Set Exposure : us
   if(CCDType == CCD_TYPE_BASLER) {
      int no = 0;
      // hDevGigaAry[baslerccdno]
      //PylonDeviceSetFloatFeature(hDevscA1300, STRING_PAR const char *pName, double value);
      res = PylonDeviceSetFloatFeature( hDevGigaAry[no], "ExposureTimeAbs", dus );
      WriteSystemLog("Set Basler CCD Shutter to " + IntToStr(rgCCDShutter->ItemIndex));
      pnlSystemMessage->Caption = "Set Basler CCD Shutter to " + IntToStr(rgCCDShutter->ItemIndex);
      lbGiga->Items->Add("Basler CCD Shutter: " + IntToStr(rgCCDShutter->ItemIndex));
      scA1300ShutterAry[0] = rgCCDShutter->ItemIndex;
      CCDShutter = rgCCDShutter->ItemIndex;
   }
   else {
      WriteSystemLog("Set IS CCD" + IntToStr(combCCDSelect->ItemIndex+1) + " Shutter to " + IntToStr(rgCCDShutter->ItemIndex));
      if(combCCDSelect->ItemIndex == 0)
         ICImagingControl1->Exposure = us;
      else if(combCCDSelect->ItemIndex == 1)
         ICImagingControl2->Exposure = us;
      else if(combCCDSelect->ItemIndex == 2)
         ICImagingControl3->Exposure = us;
      WriteSystemLog((AnsiString)"Set IS CCD Shutter to " + IntToStr(rgCCDShutter->ItemIndex) + " Done.");
   }
   return;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::tbCCDGainChange(TObject *Sender)
{
int gain;
double fgain;

   // 2023 1 3 - chc @@@@@
   WriteSystemLog("tbCCDGainChange() Enter...");

   // ImagingSource
   if(combCCDSelect->ItemIndex == 0) {
      if(pnlISCCDStaus->Color != clLime)
         return;
   }
   else if(combCCDSelect->ItemIndex == 1) {
      if(pnlISCCD2Staus->Color != clLime)
         return;
   }
   else if(combCCDSelect->ItemIndex == 2) {
      if(pnlISCCD3Staus->Color != clLime)
         return;
   }

   gain = tbCCDGain->Position;
   pnlCCDGain->Caption = IntToStr(gain);

   // Gain[175 ~ 1020]
   if(CCDType == CCD_TYPE_IS) {
      // 0 - 9.21(0-921 ?)
      try {
         WriteSystemLog("Set IS CCD Gain to " + IntToStr(gain));

         if(combCCDSelect->ItemIndex == 0)
            ICImagingControl1->Gain = gain;
         else if(combCCDSelect->ItemIndex == 1)
            ICImagingControl2->Gain = gain;
         else if(combCCDSelect->ItemIndex == 2)
            ICImagingControl3->Gain = gain;

         pnlSystemMessage->Caption = "Gain Changed.";
      }
      catch(Exception &e) {
         WriteSystemLog(">>Error(GainChange): " + IntToStr(gain) + "," + e.Message);
         pnlSystemMessage->Caption = "GainChange: " + IntToStr(gain) + "," + e.Message;
      }
   }
   else {
      if(gain < 300) {
         gain = 300;
      }
      else if(gain > 850) {
         gain = 850;
      }
      int no = 0;
      res = PylonDeviceFeatureFromString( hDevGigaAry[no], "GainSelector", "GainSelector_All");
      res = PylonDeviceSetIntegerFeature( hDevGigaAry[no], "GainRaw", gain);
      WriteSystemLog("Set Basler CCD Gain to " + IntToStr(gain));
      pnlSystemMessage->Caption = "Set Basler CCD Gain to " + IntToStr(gain);
      lbGiga->Items->Add("Basler CCD Gain: " + IntToStr(gain));
      scA1300GainAry[0] = gain;
      CCDGain = gain;
   }

   // 2023 1 3 - chc @@@@@
   WriteSystemLog("tbCCDGainChange() Done.");

   return;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::rgRulerColorClick(TObject *Sender)
{

   // 畫出New尺規: imGrid
   DrawRuler();
}
//---------------------------------------------------------------------------
// 畫出New尺規: imGrid
void __fastcall TfrnMain::DrawRuler()
{
int index,width,height,dy,dx,y,no,x,cx,cy;
int d = 10;

   DrawGridRuler();
}
//---------------------------------------------------------------------------
// 畫出New尺規: imGrid
void __fastcall TfrnMain::DrawGridRuler()
{
int index,width,height,dy,dx,y,no,x,cx,cy;
int d = 10;

   // Clear imGrid
   ClearGridImage();

   index = rgRulerType->ItemIndex;
   imGrid->Canvas->Pen->Color = clRed;
   imGrid->Canvas->Pen->Width = 1;
   imGrid->Canvas->Brush->Color = clMaroon;
   width = imGrid->Width;
   height = imGrid->Height;
   imGrid->Canvas->Pen->Style = psSolid;
   imGrid->Canvas->Pen->Mode = pmCopy;
   cx = width / 2;
   cy = height / 2;
   switch(rgRulerColor->ItemIndex) {
      case 0:
         imGrid->Canvas->Pen->Color = clRed;
         break;
      case 1:
         imGrid->Canvas->Pen->Color = clBlue;
         break;
      case 2:
         imGrid->Canvas->Pen->Color = clLime;
         break;
      case 3:
         imGrid->Canvas->Pen->Color = clBlack;
         break;
      case 4:
         imGrid->Canvas->Pen->Color = clWhite;
         break;
      case 5:
         imGrid->Canvas->Pen->Color = clYellow;
         break;
      case 6:
         imGrid->Canvas->Pen->Color = clFuchsia;
         break;
   }
   switch(index) {
      // 十字線
      case 0:
         shHorizontal->Pen->Color = imGrid->Canvas->Pen->Color;
         shHorizontal->Visible = true;
         shVertical->Pen->Color = imGrid->Canvas->Pen->Color;
         shVertical->Visible = true;
         break;
      // 網格
      case 1:
         shHorizontal->Visible = false;
         shVertical->Visible = false;
         imGrid->Canvas->Pen->Style = psDot;
         imGrid->Canvas->Pen->Mode = pmCopy;
         dy = 40;
         y = height / 2;
         no = 0;
         while(y > no*dy) {
            imGrid->Canvas->MoveTo(0      ,y-no*dy);
            imGrid->Canvas->LineTo(width-1,y-no*dy);
            imGrid->Canvas->MoveTo(0      ,y+no*dy);
            imGrid->Canvas->LineTo(width-1,y+no*dy);
            no++;
         }
         dx = 40;
         x = width / 2;
         no = 0;
         while(x > no*dx) {
            imGrid->Canvas->MoveTo(x-no*dx,0);
            imGrid->Canvas->LineTo(x-no*dx,height-1);
            imGrid->Canvas->MoveTo(x+no*dx,0);
            imGrid->Canvas->LineTo(x+no*dx,height-1);
            no++;
         }
         break;
      // 一字線
      case 2:
         shHorizontal->Pen->Color = imGrid->Canvas->Pen->Color;
         shHorizontal->Visible = true;
         shVertical->Visible = false;

         break;
      // 十字線 + 中心
      case 3:
         shHorizontal->Pen->Color = imGrid->Canvas->Pen->Color;
         shHorizontal->Visible = true;
         shVertical->Pen->Color = imGrid->Canvas->Pen->Color;
         shVertical->Visible = true;

         imGrid->Canvas->MoveTo(cx-d*3  ,cy-d);
         imGrid->Canvas->LineTo(cx-d    ,cy-d);
         imGrid->Canvas->MoveTo(cx-d    ,cy-d*3);
         imGrid->Canvas->LineTo(cx-d    ,cy-d);

         imGrid->Canvas->MoveTo(cx+d*3  ,cy-d);
         imGrid->Canvas->LineTo(cx+d    ,cy-d);
         imGrid->Canvas->MoveTo(cx+d    ,cy-d*3);
         imGrid->Canvas->LineTo(cx+d    ,cy-d);

         imGrid->Canvas->MoveTo(cx-d*3  ,cy+d);
         imGrid->Canvas->LineTo(cx-d    ,cy+d);
         imGrid->Canvas->MoveTo(cx-d    ,cy+d*3);
         imGrid->Canvas->LineTo(cx-d    ,cy+d);

         imGrid->Canvas->MoveTo(cx+d*3  ,cy+d);
         imGrid->Canvas->LineTo(cx+d    ,cy+d);
         imGrid->Canvas->MoveTo(cx+d    ,cy+d*3);
         imGrid->Canvas->LineTo(cx+d    ,cy+d);
         break;
      case 4:
         shHorizontal->Visible = false;
         shVertical->Visible = false;
         ClearGridImage();
         break;
   }

   // 獨立尺標
   if(cbRuler->Checked == true) {
      dy = 5;
      y = height / 2;
      no = 0;
      int value = 0;
      while((height/2) > no*dy) {
         dx = 12;
         if((no % 5) == 0)
            dx = 20;
         if((no % 10) == 0)
            dx = 30;
         imGrid->Canvas->MoveTo(0 ,height/2-no*dy);
         imGrid->Canvas->LineTo(dx,height/2-no*dy);
         imGrid->Canvas->MoveTo(0 ,height/2+no*dy);
         imGrid->Canvas->LineTo(dx,height/2+no*dy);

         imGrid->Canvas->MoveTo(width-0 ,height/2-no*dy);
         imGrid->Canvas->LineTo(width-dx,height/2-no*dy);
         imGrid->Canvas->MoveTo(width-0 ,height/2+no*dy);
         imGrid->Canvas->LineTo(width-dx,height/2+no*dy);

         if(dx == 30) {
            imGrid->Canvas->Font->Size = 14;
            imGrid->Canvas->Font->Name = "Arial";
            imGrid->Canvas->Font->Color = clRed;
            imGrid->Canvas->Pen->Width = 2;
            //imGrid->Canvas->Pen->Color = 0x003988FD;
            imGrid->Canvas->Brush->Color = clWhite;
            imGrid->Canvas->Brush->Style = bsClear;
            imGrid->Canvas->TextOutA(dx+5,height/2-no*dy-11,IntToStr(value));
            imGrid->Canvas->TextOutA(dx+5,height/2+no*dy-11,IntToStr(value));
            imGrid->Canvas->TextOutA(width-dx-15,height/2-no*dy-11,IntToStr(value));
            imGrid->Canvas->TextOutA(width-dx-15,height/2+no*dy-11,IntToStr(value));
            value++;
         }

         no++;
      }
   }

   // 2022 7 20 - chc 變更Measure十字顏色
   pnlHorizontal->Color = imGrid->Canvas->Pen->Color;
   pnlVertical->Color = imGrid->Canvas->Pen->Color;
   
}
//---------------------------------------------------------------------------
// Clear imGrid
#define TRANS_PARENT_COLOR  0x123456
void __fastcall TfrnMain::ClearGridImage()
{

   imGrid->Picture->Bitmap->Transparent = true;
   imGrid->Picture->Bitmap->TransparentColor     = (TColor) TRANS_PARENT_COLOR;
   imGrid->Picture->Bitmap->Canvas->Brush->Style = bsSolid;
   imGrid->Picture->Bitmap->Canvas->Brush->Color = (TColor) TRANS_PARENT_COLOR;
   imGrid->Picture->Bitmap->Canvas->Pen->Color   = (TColor) TRANS_PARENT_COLOR;
   imGrid->Picture->Bitmap->Canvas->Rectangle(0, 0, imGrid->Width, imGrid->Height);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::tbContrastChange(TObject *Sender)
{
int contrast;

   // 2023 1 3 - chc @@@@@
   WriteSystemLog("tbContrastChange() Enter...");

   // ImagingSource
   if(pnlISCCDStaus->Color != clLime)
      return;
   contrast = tbContrast->Position;
   ICImagingControl1->Sharpness = contrast;
   pnlContrast->Caption = IntToStr(contrast);

   // 2023 1 3 - chc @@@@@
   WriteSystemLog("tbContrastChange() Done.");

   return;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::rgRulerAuxChange(TObject *Sender,
      int ButtonIndex)
{
int no,pitch,dy,pdy;
double resolution;

   resolution = edCCDPrecision->Text.ToDouble();
   no = rgRulerAux->ItemIndex;
   pitch = pnlYPitchOP->Caption.ToInt();
   switch(no) {
      // 1/4 Pitch
      case 1:
         dy = pitch / 4;
         break;
      // 1/2 Pitch
      case 2:
         dy = pitch / 2;
         break;
      // 1 Pitch
      case 3:
         dy = pitch / 1;
         break;
   }
   pdy = dy / resolution;
   if(shHorizontal->Top - pdy > 0)
      shHorizontalUp->Top = shHorizontal->Top - pdy;
   else
      shHorizontalUp->Top = 10;
   if(shHorizontal->Top + pdy < CCDInfoAry[0].Height)
      shHorizontalDown->Top = shHorizontal->Top + pdy;
   else
      shHorizontalDown->Top = CCDInfoAry[0].Height - 10;

   if(cbRuler->Checked == true && no != 0) {
      shHorizontalUp->Visible = true;
      shHorizontalDown->Visible = true;
   }
   else {
      shHorizontalUp->Visible = false;
      shHorizontalDown->Visible = false;
   }
}
//---------------------------------------------------------------------------
int ImageFactor = 1;
int ImageSX = 0;
int ImageSY = 0;

void __fastcall TfrnMain::btnReviewLoadClick(TObject *Sender)
{
int no,width,height,sx,sy,x,y,w,h;

   // 固定為0
   no = 0;

   // for test
   ImageFactor = 1;
   frmInspection->ImageFactor = 1;
   pnlMainFactor->Caption = IntToStr(ImageFactor);
   ImageSX = 0;
   ImageSY = 0;
   if(boolForTest == true) {
      GigaWidth = 2448;
      GigaHeight = 2048;
      CCDInfoAry[no].Type = CCD_COLOR;
      CCDInfoAry[no].Width = 2448;
      CCDInfoAry[no].Height = 2048;
      //CCDImageAry[no].SetSize(GigaWidth,GigaHeight);
      //CCDImageROIAry[no].Detach();
      //CCDImageROIAry[no].Attach(&CCDImageAry[no]);
      usb_ImageAry[no].SetSize(GigaWidth,GigaHeight);
      usb_ImageROIAry[no].Detach();
      usb_ImageROIAry[no].Attach(&usb_ImageAry[no]);
      cbCCDFullImage->Checked = true;
   }

   frmInspection->cbCCDFullImage->Checked = true;
   frmRecipeSet->cbCCDFullImage->Checked = true;
   frmInspection->cbFreeze->Checked = true;
   frmRecipeSet->cbFreeze->Checked = true;

   width = CCDInfoAry[no].Width;
   height = CCDInfoAry[no].Height;
   w = imCCD->Width;
   h = imCCD->Height;

   // Lasr Cneter
   sx = LaserCenterX;
   sy = LaserCenterY;

   // Check Range
   CheckRange(&sx,&sy);

   opCCDImage->InitialDir = BitmapDirectory;
   if(opCCDImage->Execute()) {
      if(CCDInfoAry[no].Type == CCD_BW) {
         CCDImageAry[no].Load(opCCDImage->FileName.c_str());
         // imCCD
         w = imCCD->Width;
         h = imCCD->Height;
         if(cbCCDFullImage->Checked == true) {
            w = width;
            h = height;
         }
         sx = (width - imCCD->Width) / 2;
         sy = (height - imCCD->Height) / 2;
         LaserCenterX = sx;
         LaserCenterY = sy;
         CCDRangeX = sx;
         CCDRangeY = sy;
         imCCD->Picture->Bitmap->Width = w;
         imCCD->Picture->Bitmap->Height = h;
         CCDImageROIAry[no].Detach();
         CCDImageROIAry[no].Attach(&CCDImageAry[no]);
         GetImageXY(width,height,sx,sy,w,h,&x,&y);
         CCDImageROIAry[no].SetPlacement(x,y,w,h);
         CCDImageROIAry[no].Draw(imCCD->Canvas->Handle);
         // imOpeation
         w = imOperation->Width;
         h = imOperation->Height;
         if(cbCCDFullImage->Checked == true) {
            w = width;
            h = height;
         }
         sx = (width - imOperation->Width) / 2;
         sy = (height - imOperation->Height) / 2;
         LaserCenterX = sx;
         LaserCenterY = sy;
         CCDRangeX = sx;
         CCDRangeY = sy;
         imOperation->Picture->Bitmap->Width = w;
         imOperation->Picture->Bitmap->Height = h;
         CCDImageROIAry[no].Detach();
         CCDImageROIAry[no].Attach(&CCDImageAry[no]);
         GetImageXY(width,height,sx,sy,w,h,&x,&y);
         CCDImageROIAry[no].SetPlacement(x,y,w,h);
         CCDImageROIAry[no].Draw(imOperation->Canvas->Handle);
         // frmInspection->imInspection
         w = frmInspection->imInspection->Width;
         h = frmInspection->imInspection->Height;
         if(frmInspection->cbCCDFullImage->Checked == true) {
            w = width;
            h = height;
         }
         sx = (width - frmInspection->imInspection->Width) / 2;
         sy = (height - frmInspection->imInspection->Height) / 2;
         frmInspection->LaserCenterX = sx;
         frmInspection->LaserCenterY = sy;
         frmInspection->CCDRangeX = sx;
         frmInspection->CCDRangeY = sy;
         frmInspection->imInspection->Picture->Bitmap->Width = w;
         frmInspection->imInspection->Picture->Bitmap->Height = h;
         CCDImageROIAry[no].Detach();
         CCDImageROIAry[no].Attach(&CCDImageAry[no]);
         GetImageXY(width,height,sx,sy,w,h,&x,&y);
         CCDImageROIAry[no].SetPlacement(x,y,w,h);
         CCDImageROIAry[no].Draw(frmInspection->imInspection->Canvas->Handle);
         // frmRecipeSet->imInspection
         w = frmRecipeSet->imInspection->Width;
         h = frmRecipeSet->imInspection->Height;
         if(frmRecipeSet->cbCCDFullImage->Checked == true) {
            w = width;
            h = height;
         }
         sx = (width - frmRecipeSet->imInspection->Width) / 2;
         sy = (height - frmRecipeSet->imInspection->Height) / 2;
         frmRecipeSet->LaserCenterX = sx;
         frmRecipeSet->LaserCenterY = sy;
         frmRecipeSet->CCDRangeX = sx;
         frmRecipeSet->CCDRangeY = sy;
         frmRecipeSet->imInspection->Picture->Bitmap->Width = w;
         frmRecipeSet->imInspection->Picture->Bitmap->Height = h;
         CCDImageROIAry[no].Detach();
         CCDImageROIAry[no].Attach(&CCDImageAry[no]);
         GetImageXY(width,height,sx,sy,w,h,&x,&y);
         CCDImageROIAry[no].SetPlacement(x,y,w,h);
         CCDImageROIAry[no].Draw(frmRecipeSet->imInspection->Canvas->Handle);
      }
      else {
         usb_ImageAry[no].Load(opCCDImage->FileName.c_str());
         // imCCD
         w = imCCD->Width;
         h = imCCD->Height;
         if(cbCCDFullImage->Checked == true) {
            w = width;
            h = height;
         }
         sx = (width - imCCD->Width) / 2;
         sy = (height - imCCD->Height) / 2;
         LaserCenterX = sx;
         LaserCenterY = sy;
         CCDRangeX = sx;
         CCDRangeY = sy;
         imCCD->Picture->Bitmap->Width = w;
         imCCD->Picture->Bitmap->Height = h;
         usb_ImageROIAry[no].Detach();
         usb_ImageROIAry[no].Attach(&usb_ImageAry[no]);
         GetImageXY(width,height,sx,sy,w,h,&x,&y);
         usb_ImageROIAry[no].SetPlacement(x,y,w,h);
         usb_ImageROIAry[no].Draw(imCCD->Canvas->Handle);
         // imOperation
         w = imOperation->Width;
         h = imOperation->Height;
         if(cbCCDFullImage->Checked == true) {
            w = width;
            h = height;
         }
         sx = (width - imOperation->Width) / 2;
         sy = (height - imOperation->Height) / 2;
         LaserCenterX = sx;
         LaserCenterY = sy;
         CCDRangeX = sx;
         CCDRangeY = sy;
         imOperation->Picture->Bitmap->Width = w;
         imOperation->Picture->Bitmap->Height = h;
         usb_ImageROIAry[no].Detach();
         usb_ImageROIAry[no].Attach(&usb_ImageAry[no]);
         GetImageXY(width,height,sx,sy,w,h,&x,&y);
         usb_ImageROIAry[no].SetPlacement(x,y,w,h);
         usb_ImageROIAry[no].Draw(imOperation->Canvas->Handle);
         // frmInspection->imInspection
         w = frmInspection->imInspection->Width;
         h = frmInspection->imInspection->Height;
         if(frmInspection->cbCCDFullImage->Checked == true) {
            w = width;
            h = height;
         }
         sx = (width - frmInspection->imInspection->Width) / 2;
         sy = (height - frmInspection->imInspection->Height) / 2;
         frmInspection->LaserCenterX = sx;
         frmInspection->LaserCenterY = sy;
         frmInspection->CCDRangeX = sx;
         frmInspection->CCDRangeY = sy;
         frmInspection->imInspection->Picture->Bitmap->Width = w;
         frmInspection->imInspection->Picture->Bitmap->Height = h;
         usb_ImageROIAry[no].Detach();
         usb_ImageROIAry[no].Attach(&usb_ImageAry[no]);
         GetImageXY(width,height,sx,sy,w,h,&x,&y);
         usb_ImageROIAry[no].SetPlacement(x,y,w,h);
         usb_ImageROIAry[no].Draw(frmInspection->imInspection->Canvas->Handle);
         // frmRecipeSet->imInspection
         w = frmRecipeSet->imInspection->Width;
         h = frmRecipeSet->imInspection->Height;
         if(frmRecipeSet->cbCCDFullImage->Checked == true) {
            w = width;
            h = height;
         }
         sx = (width - frmRecipeSet->imInspection->Width) / 2;
         sy = (height - frmRecipeSet->imInspection->Height) / 2;
         frmRecipeSet->LaserCenterX = sx;
         frmRecipeSet->LaserCenterY = sy;
         frmRecipeSet->CCDRangeX = sx;
         frmRecipeSet->CCDRangeY = sy;
         frmRecipeSet->imInspection->Picture->Bitmap->Width = w;
         frmRecipeSet->imInspection->Picture->Bitmap->Height = h;
         usb_ImageROIAry[no].Detach();
         usb_ImageROIAry[no].Attach(&usb_ImageAry[no]);
         GetImageXY(width,height,sx,sy,w,h,&x,&y);
         usb_ImageROIAry[no].SetPlacement(x,y,w,h);
         usb_ImageROIAry[no].Draw(frmRecipeSet->imInspection->Canvas->Handle);
         //
         imOperation->Refresh();
         frmInspection->Refresh();
         frmRecipeSet->Refresh();

      }
      // 若沒有Refresh就不會顯示
      imCCD->Refresh();

      boolCCDImageLoadedAry[no] = true;
      pnlSystemMessage->Caption = "Image Loaded.";
   }

}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnReviewSaveClick(TObject *Sender)
{
AnsiString filename,partfilename;
int no;

   // 固定為0
   no = 0;

   // 2021 9 3 - chc 強制為True
   boolCCDImageLoadedAry[no] = true;

   if(boolCCDImageLoadedAry[no]) {
      spCCDImage->InitialDir = BitmapDirectory;
      // 設定filtet
      spCCDImage->Filter = "BMP(*.bmp)|*.bmp";
      if(spCCDImage->Execute()) {
         // 改變副檔名
         filename = ChangeFileExt(spCCDImage->FileName,".bmp");
         // 是Gray才對
         if(CCDInfoAry[no].Type == CCD_BW) {
            CCDImageAry[no].Save(filename.c_str(),E_FILE_FORMAT_GRAY_LEVEL_BMP);

            // 2021 9 4 - chc 區分Full or part(CCDImageROIAry)
            // => 為與Load Image搭配, 固定做Full
            // => Full & Part都存
            partfilename = ChangeFileExt(spCCDImage->FileName,"-p.bmp");
            CCDImageROIAry[no].Save(partfilename.c_str(),E_FILE_FORMAT_GRAY_LEVEL_BMP);

         }
         else
            usb_ImageROIAry[no].Save(filename.c_str(),E_FILE_FORMAT_COLOR_BMP);
         pnlSystemMessage->Caption = "Image Saved.";
      }
   }
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::cbRulerChange(TObject *Sender)
{

   DrawGridRuler();
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnLampControl1Click(TObject *Sender)
{

   try {
      ybLampControl1->SettingsDialog(this,true);
      if(LampControlStatus1 == false)
         ybLampControl1->Active = true;
      LampControlStatus1 = true;
   }
   catch(Exception &e) {
      ShowMessage("ybLampControl1: " + e.Message);
      LampControlStatus1 = false;
      pnlSystemMessage->Caption = "COM Port(LED1) 啟動失敗!";
      WriteSystemLog(pnlSystemMessage->Caption);
   }
   UpdateLampStatus1();
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnSaveLED2Click(TObject *Sender)
{
TIniFile *pSystemFile;
AnsiString msg,fname;

   // Write to .ini
   pnlSystemMessage->Caption = "LED1 Parameters Updating...";
   fname = RecipeDirectory + "\\" + RecipeName + LED_INI_FILENAME;

   // 若Path尚未建立, 要自動產生
   AnsiString path = RecipeDirectory + "\\" + RecipeName;
   if(!DirectoryExists(path))
      mkdir(path.c_str());

   // ini檔名與目錄
   pSystemFile = new TIniFile(fname);

   // 要取得目前值
   LED2CH1Value = tbLED2CH1->Position;
   LED2CH2Value = tbLED2CH2->Position;
   LED2CH3Value = tbLED2CH3->Position;
   LED2CH4Value = tbLED2CH4->Position;
   WriteSystemLog("LED Save, ch1,ch2= " + IntToStr(LED2CH1Value) + "," + IntToStr(LED2CH2Value));

   pSystemFile->WriteInteger(LED_PARAMETER_SECTION,LED2_CH1_VALUE     ,LED2CH1Value);
   pSystemFile->WriteInteger(LED_PARAMETER_SECTION,LED2_CH2_VALUE     ,LED2CH2Value);
   pSystemFile->WriteInteger(LED_PARAMETER_SECTION,LED2_CH3_VALUE     ,LED2CH3Value);
   pSystemFile->WriteInteger(LED_PARAMETER_SECTION,LED2_CH4_VALUE     ,LED2CH4Value);

   pSystemFile->UpdateFile();

   delete pSystemFile;
}
//---------------------------------------------------------------------------
// LED Lamp Active
void __fastcall TfrnMain::UpdateLampStatus2()
{

   if(LampControlStatus2 == true) {
      pnlLampControl2->Color = clLime;
      pnlAOILamp->Color = clLime;
      pnlRightMacroLamp->Color = clLime;
   }
   else {
      pnlLampControl2->Color = clRed;
      pnlAOILamp->Color = clRed;
      pnlRightMacroLamp->Color = clRed;
   }
}
//---------------------------------------------------------------------------
// LED Lamp Active
void __fastcall TfrnMain::UpdateLampStatus1()
{

   if(LampControlStatus1 == true) {
      pnlLampControl1->Color = clLime;
      pnlAOILamp->Color = clLime;
      pnlLeftMacroLamp->Color = clLime;
   }
   else {
      pnlLampControl1->Color = clRed;
      pnlAOILamp->Color = clRed;
      pnlLeftMacroLamp->Color = clRed;
   }
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::tbLED2CH1Change(TObject *Sender)
{

   pnlLED2CH1->Caption = IntToStr(tbLED2CH1->Position);
   LED2CH1Value = tbLED2CH1->Position;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::tbLED2CH1MouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   pnlLED2CH1->Caption = IntToStr(tbLED2CH1->Position);
   LED2CH1Value = tbLED2CH1->Position;
   SetLED2Value(1,LED2CH1Value);
}
//---------------------------------------------------------------------------
// LED2 設定亮度值
// 0205001F 64 00 00 00 83 00(100%,0,0,0) / 0205001F 00 32 00 00 51 00(0,50%,0,0)
// 02 - Start
// 05 00 - Length(In the sequence of low byte to high byte)
// 1F - Set Brightness Command
// 64 00 00 00 - Set the Brightness Value(0 to 100%) in the order of CH1, 2,3 and4
// 83 00 - Checksum (In the sequence of low byte to high byte), Checksum= CommandText= 1F +64 + 00 + 00 + 00 = 0083H
//
// Omron 溫控器: 010300000002C40B
// Ack: 01 03 04 00 00 03 E8 [FA 8D]
//
// for test
//  chno: 1 - LED(光原) - Nport 5150A RS232/TCP Server(port=4100)
//        2 - 溫控(Omron) - MGate MB3170, Modbus RTU (port=502)
//
//
// 3AM: Ch1
// : 01 06 0001 0080  78  CR LF
//      W   Reg Value LRC
// : 01 03 0001  0001 FA  CR LF
//      R  Start  No  LRC
int NportID;
bool boolNport = false;
void __fastcall TfrnMain::SetLED2Value(int chno, int value)
{
int no,len;
unsigned char str[50],code,strtcp[20];
AnsiString msg;
unsigned int checksum;

   unsigned char lrc;
   unsigned char header = 0x3A;
   unsigned char add = 0x01;
   unsigned char fun = 0x06;
   unsigned char regh = 0x00;
   unsigned char regl = 0x01;
   unsigned char vh = 0x00;
   unsigned char vl = value & 0xff;

   if(value < 0)
      value = 0;
   if(value > 255)
      value = 255;
   lrc = 0xff - (add + fun + regh + regl + vh + vl) + 0x01;
   sprintf(str,":01060001%04X%02X%c%c",value,lrc,0x0d,0x0a);
   len = strlen(str);
   if(chno == 1)
      ybLampControl1->Write(str, len);
   else
      ybLampControl2->Write(str, len);
   return;


   // LED
   if(chno == 1 || chno == 2 || chno == 3 || chno == 4) {
      // MGate
      strtcp[0] = 00;
      strtcp[1] = 00;
      strtcp[2] = 00;
      strtcp[3] = 00;
      strtcp[4] = 00;
      strtcp[5] = 0x0A;
      // NPort
      str[0] = 02;
      str[1] = 05;
      str[2] = 00;
      str[3] = 0x1F;
      str[4] = pnlLED2CH1->Caption.ToInt();                                        // Ch1
      str[5] = pnlLED2CH2->Caption.ToInt();                                        // Ch2
      str[6] = pnlLED2CH3->Caption.ToInt();                                        // Ch3
      str[7] = pnlLED2CH4->Caption.ToInt();                                        // Ch4
      checksum = 0;
      for(int i=3 ; i<8 ; i++)
         checksum += str[i];
      str[8] = (checksum & 0x00ff);                                                // CheckSum
      str[9] = ((checksum & 0xff00) >> 8);                                         // CheckSum
      len = 10;
   }
   // 溫控(Reserved: 實際完整碼已刪除)
   else {
      // Omron: 00 00 00 00 00 06 - 01 03 00 00 00 02 - [C40B]
      // Modbus TCP 標準Command格式
      strtcp[0] = 00;
      strtcp[1] = 00;
      strtcp[2] = 00;
      strtcp[3] = 00;
      strtcp[4] = 00;
      strtcp[5] = 06;
      str[0] = 01;
      str[1] = 03;
      str[2] = 00;
      str[3] = 00;
      str[4] = 00;
      str[5] = 02;
      len = 6;
      unsigned int reg_crc = 0xFFFF;
      unsigned char *data;
      data = &str[0];
      while(len--) {
         reg_crc ^= *data++;
         for(int j=0 ; j<8 ; j++) {
            if(reg_crc & 0x01)                                                     // LSB(b0)=1
               reg_crc = (reg_crc>>1) ^ 0xA001;
            else
               reg_crc = reg_crc >>1;
         }
      }
      str[6] = (reg_crc & 0x00ff);
      str[7] = ((reg_crc & 0xff00) >> 8);
      len = 8;
   }

   ybLampControl2->Write(str, len);
}
//---------------------------------------------------------------------------
// LED2
void __fastcall TfrnMain::InitLampControl2()
{

   ybLampControl2->Active = false;
   Sleep(500);
   LampControlStatus2 = false;

   try {
      ybLampControl2->PortNo = combLED2Comport->ItemIndex+1;
      ybLampControl2->Active = true;
      LampControlStatus2 = true;
   }
   catch(Exception &e) {
      //ShowMessage("ybLampControl2: " + e.Message);
      LampControlStatus2 = false;
   }

   if(LampControlStatus2 == false) {
      sbSystem->Panels->Items[1]->Text = "COM-LED2 啟動失敗!";
      //pnlRightLamp->Color = clRed;
      pnlLampControl2->Color = clRed;
      pnlAOILamp->Color = clRed;
      return;
   }
   pnlLampControl2->Color = clLime;
   pnlAOILamp->Color = clLime;

}
//---------------------------------------------------------------------------
// LED1
void __fastcall TfrnMain::InitLampControl1()
{

   ybLampControl1->Active = false;
   Sleep(500);
   LampControlStatus1 = false;

   try {
      ybLampControl1->PortNo = combLED1Comport->ItemIndex+1;
      ybLampControl1->Active = true;
      LampControlStatus1 = true;
   }
   catch(Exception &e) {
      //ShowMessage("ybLampControl1: " + e.Message);
      LampControlStatus1 = false;
   }

   if(LampControlStatus1 == false) {
      sbSystem->Panels->Items[1]->Text = "COM-LED1 啟動失敗!";
      //pnlRightLamp->Color = clRed;
      pnlLampControl1->Color = clRed;
      pnlAOILamp->Color = clRed;
      return;
   }
   pnlLampControl1->Color = clLime;
   pnlAOILamp->Color = clLime;

}
//---------------------------------------------------------------------------
// 讀取亮度值: LEDParameter.ini
void __fastcall TfrnMain::ReadLEDValue()
{
TIniFile *pSystemFile;
AnsiString msg,fname;

   // ini檔名與目錄
   // 用LED Parameter file
   //pSystemFile = new TIniFile(MotionINIFilename);
   pnlSystemMessage->Caption = "LED Parameters Reading...";
   fname = RecipeDirectory + "\\" + RecipeName + LED_INI_FILENAME;
   pSystemFile = new TIniFile(fname);

   LED2CH1Value = pSystemFile->ReadInteger(LED_PARAMETER_SECTION,LED2_CH1_VALUE    ,20);
   LED2CH2Value = pSystemFile->ReadInteger(LED_PARAMETER_SECTION,LED2_CH2_VALUE    ,20);
   LED2CH3Value = pSystemFile->ReadInteger(LED_PARAMETER_SECTION,LED2_CH3_VALUE    ,20);
   LED2CH4Value = pSystemFile->ReadInteger(LED_PARAMETER_SECTION,LED2_CH4_VALUE    ,20);

   pnlLED2CH1->Caption = IntToStr(LED2CH1Value);
   pnlLED2CH2->Caption = IntToStr(LED2CH2Value);
   pnlLED2CH3->Caption = IntToStr(LED2CH3Value);
   pnlLED2CH4->Caption = IntToStr(LED2CH4Value);
   tbLED2CH1->Position = LED2CH1Value;
   tbLED2CH2->Position = LED2CH2Value;
   tbLED2CH3->Position = LED2CH3Value;
   tbLED2CH4->Position = LED2CH4Value;

   pnlSystemMessage->Caption = "LED Parameters Setting...";

   // Set LED
   SetLED2Value(1,LED2CH1Value);
   Sleep(200);
   SetLED2Value(1,LED2CH2Value);
   Sleep(200);
   SetLED2Value(1,LED2CH3Value);
   Sleep(200);
   SetLED2Value(1,LED2CH4Value);

   pnlSystemMessage->Caption = "LED Parameter Done.";

   delete pSystemFile;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::tbLED2CH2Change(TObject *Sender)
{

   pnlLED2CH2->Caption = IntToStr(tbLED2CH2->Position);
   LED2CH2Value = tbLED2CH2->Position;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::tbLED2CH2MouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   pnlLED2CH2->Caption = IntToStr(tbLED2CH2->Position);
   LED2CH2Value = tbLED2CH2->Position;
   SetLED2Value(2,LED2CH2Value);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::tbLED2CH3Change(TObject *Sender)
{

   pnlLED2CH3->Caption = IntToStr(tbLED2CH3->Position);
   LED2CH3Value = tbLED2CH3->Position;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::tbLED2CH4Change(TObject *Sender)
{

   pnlLED2CH4->Caption = IntToStr(tbLED2CH4->Position);
   LED2CH4Value = tbLED2CH4->Position;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::tbLED2CH3MouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   pnlLED2CH3->Caption = IntToStr(tbLED2CH3->Position);
   LED2CH3Value = tbLED2CH3->Position;
   SetLED2Value(3,LED2CH3Value);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::tbLED2CH4MouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   pnlLED2CH4->Caption = IntToStr(tbLED2CH4->Position);
   LED2CH4Value = tbLED2CH4->Position;
   SetLED2Value(4,LED2CH4Value);
}
//---------------------------------------------------------------------------
// Motion
void __fastcall TfrnMain::SetupMotion()
{

   // 由motion.cpp負責
   InitMotion();
   CurrentAxisNo = X_AXIS;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::tmMotionPollingTimer(TObject *Sender)
{
// first 1000ms => 100ms
bool boolfirst = true;

   // 2021 8 17 - chc 由矽品改過來
   tmMotionPolling->Enabled = false;
   // first 1000ms => 100ms
   // 可能XML尚未設定完成
   if(boolfirst == true)
      tmMotionPolling->Interval = 100;
   boolfirst = false;

   // 由Motion負責
   if(boolInMotionUpdate == false)
      UpdateMotionStatus();

   // 2022 6 19 - chc 更新Table位置對應圖
   UpdateTablePosition();

   // 2021 8 17 - chc 由矽品改過來
   tmMotionPolling->Enabled = true;

}
//---------------------------------------------------------------------------


void __fastcall TfrnMain::btnReviewLiveClick(TObject *Sender)
{

   // 暫不提供     
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnToCenterPositionClick(TObject *Sender)
{

   // 禁操作
   pcSystem->Enabled = false;
   pnlStartMessage->Caption = "Moving to Center...";
   pnlStartMessage->Visible = true;
   pnlStartMessage->Refresh();
   // 到入料點/原點用最高速
   boolUseMaxSpeed = true;

   MotionStatus(false);
   ToCenterPosition();
   MotionStatus(true);

   // 禁操作
   pcSystem->Enabled = true;
   pnlStartMessage->Visible = false;
   // 到入料點/原點用最高速
   boolUseMaxSpeed = false;

}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnCenterPositionClick(TObject *Sender)
{

   SetCenterPosition();
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnHomeClick(TObject *Sender)
{
F64 Posi,Dist,StartVel,MaxVel,Tacc,Tdec,xpos,ypos,HomeVel;
I16 Done;
int cnt,timeoutcnt;
U16 io_sts;
static bool first = true;

   // 是否Motion Ready?
   if(pnlPCI7856->Color == clRed) {
      pnlSystemMessage->Caption = "Motion未備妥, 無法執行Home作業!";
      pnlAlarmMessage->Caption = pnlSystemMessage->Caption;
      pnlMainMessage->Caption = "Motion Not Ready!";
      Beep(500);
      return;
   }

   // 光柵Status
   if(frnMain->pnlID3Bit15->Color == clLime) {
      pnlSystemMessage->Caption = "光柵啟動!, 無法執行Home作業!";
      pnlAlarmMessage->Caption = pnlSystemMessage->Caption;
      pnlMainMessage->Caption = "Safety Light Detected!";
      Beep(500);
      return;
   }

   // 變動訊息
   if(pnlStartMessage->Visible == true) {
      pnlStartMessage->Caption = "[原點復歸]執行中...";
      pnlStartMessage->Refresh();
   }
   WriteSystemLog(">進入HomeAll");
   btnHome2->Enabled = false;

   // Blinking
   boolStartState = false;
   boolAllHomeState = false;
   btnHome2->Font->Color = clNavy;

   // 2022 12 6 - chc Logo Form
   if(frmLogo->Visible == true) {
      //frmLogo->pnlHome3->Font->Color = clNavy;
      frmLogo->pnlMicroUnit->Caption = "Initializing...";
   }

   boolAllHome = false;
   AllHome();
   WriteSystemLog(">離開HomeAll");

   // 啟動所有Motion功能: boolHomeDone
   SetMotionStatus();

   // 若AllHome成功才起動Start
   if(boolHomeDone == true && boolAllHome == true) {

      // 不啟動Start, 等入料才啟動
      //btnStartCut->Enabled = true;

      // 若host已連線則為Ready
      if(pnlQRCodeConnect->Color == clLime && pnlPCI7856->Color == clLime && pnlCCDStatus1->Color == clLime && pnlAOILamp->Color == clLime)
         pnlRun->Caption = "Ready";

      // 設黃燈: Idle
      SetLight(SYSTEM_IDLE);

      // 2022 7 5 - chc Set True
      btnUpdateMotionParameter->Enabled = true;

   }
   else
      SetLight(SYSTEM_ALARM);

   WriteSystemLog(">離開SetMotionStatus");
   // 沒有Home不可以作動
   if(first == true) {
      first = false;
   }

   // 2022 8 26 - chc 檢查YuanLi連線
   // 2022 12 5 - chc 不測
   /*
   bool boolyuanli;
   pnlMoving->Caption = "通訊測試...";
   pnlStartMessage->Caption = "YuanLi通訊測試...";
   pnlStartMessage->Visible = true;
   pnlMoving->Visible = true;
   pnlStartMessage->Refresh();
   pnlMoving->Refresh();
   boolyuanli = YuanLiConnect();
   if(boolyuanli == false) {
      pnlAlarmMessage->Caption = "YuanLi無法連線(Timeout), 請檢查.";

      // 2022 9 22 - chc not display
      //pnlStartMessage->Caption = "YuanLi Scan系統無法連線!";
      //pnlStartMessage->Refresh();
      //pnlMoving->Caption = "Scan系統異常";
      //pnlMoving->Refresh();

   }
   */

   // 2022 9 22 - chc not display
   pnlStartMessage->Visible = false;
   pnlMoving->Visible = false;

   return;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::imCCDMouseMove(TObject *Sender,
      TShiftState Shift, int X, int Y)
{
int gray,sx,sy;

   // 主畫面
   unsigned char r,g,b;
   TColor color;
   sx = 0;
   sy = 0;
   color = imCCD->Canvas->Pixels[X][Y];
   b = (color & 0xff0000) >> 16;
   g = (color & 0x00ff00) >> 8;
   r = color & 0x0000ff;
   // 顯示游標值
   pnlCCDR->Caption = r;
   pnlCCDG->Caption = g;
   pnlCCDB->Caption = b;
   pnlCCDX->Caption = X + sx;
   pnlCCDY->Caption = Y + sy;
   AnsiString str;
   str.sprintf("XY:(%d,%d)",X,Y);
   sbSystem->Panels->Items[3]->Text = str;

   // 2021 5 20 - chc Gray Value
   str.sprintf("RGB:(%3d,%3d,%3d)",r,g,b);
   //str.sprintf("G:(%3d)",g);

   sbSystem->Panels->Items[4]->Text = str;

   // 2022 7 15 - chc Measure
   if(MeasureState == 1 && cbMeasure->Checked == true) {
      Mx2 = X;
      My2 = Y;
      int w,h,l,t;
      if(Mx1 < Mx2)
         l = Mx1;
      else
         l = Mx2;
      if(My1 < My2)
         t = My1;
      else
         t = My2;
      w = abs(Mx2 - Mx1);
      h = abs(My2 - My1);
      shMeasure->Left = l + imCCD->Left;
      shMeasure->Top = t + imCCD->Top;
      shMeasure->Width = w;
      shMeasure->Height = h;

      // Realtime display
      double wvalue,hvalue,lvalue,dx;
      AnsiString msg;
      dx = GetLensPrecision();
      // Width
      wvalue = (abs(Mx2 - Mx1)+1) * dx;
      // Height
      hvalue = (abs(My2 - My1)+1) * dx;

      // Length
      lvalue = sqrt(wvalue*wvalue + hvalue*hvalue);
      if(pnlUnit->Caption == "um")
         msg.sprintf("(um)W:%.2f  H:%.2f  L:%.2f  A:%.2f  a:%.2f",wvalue,hvalue,lvalue,wvalue*hvalue,((wvalue*hvalue)/4)*M_PI);
      else {
         wvalue /= MM_TO_UM;
         hvalue /= MM_TO_UM;
         lvalue /= MM_TO_UM;
         msg.sprintf("(mm)W:%.3f  H:%.3f  L:%.3f  A:%.4f  a:%.4f",wvalue,hvalue,lvalue,wvalue*hvalue,((wvalue*hvalue)/4)*M_PI);
      }
      pnlMeasureResult->Caption = msg;
      shEllipse->Left = shMeasure->Left;
      shEllipse->Top = shMeasure->Top;
      shEllipse->Width = shMeasure->Width;
      shEllipse->Height = shMeasure->Height;
      shEllipse->Visible = true;
   }

}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnMoveClick(TObject *Sender)
{

   // @@ Test
   WriteSystemLog("Joystcik: 1.Set Disable");

   // 2022 6 16 - chc 不使用搖桿
   SetJoystickActive(false);

   // 連動
   if(cbContinueMove->Checked == true)
      return;
   MoveForward();
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnMoveMouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   // 指定Axis
   CurrentAxisNo = combAxis->ItemIndex;

   if(cbContinueMove->Checked == false)
      return;

   // 記錄在move中, 不可以同時Continue move
   if(boolInAxisMove == false) {
      boolJogMove = true;

      // @@ Test
      WriteSystemLog("Joystcik: 2.Set Disable");

      // 2022 6 16 - chc 不使用搖桿
      SetJoystickActive(false);

      // 2022 6 16a - chc define type value: 0-wait, 1-nowait(for UpdateMotionStatus())
      //AxisMove(0);
      AxisMove(0,0);

   }
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnMoveMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   if(cbContinueMove->Checked == false)
      return;
   boolJogMove = false;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnBackwardClick(TObject *Sender)
{

   // @@ Test
   WriteSystemLog("Joystcik: 3.Set Disable");

   // 2022 6 16 - chc 不使用搖桿
   SetJoystickActive(false);

   // 連動
   if(cbContinueMove->Checked == true)
      return;
   MoveBackward();
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnBackwardMouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   // 指定Axis
   CurrentAxisNo = combAxis->ItemIndex;

   if(cbContinueMove->Checked == false)
      return;

   // 記錄在move中, 不可以同時Continue move
   if(boolInAxisMove == false) {
      boolJogMove = true;

      // @@ Test
      WriteSystemLog("Joystcik: 4.Set Disable");

      // 2022 6 16 - chc 不使用搖桿
      SetJoystickActive(false);

      // 2022 6 16a - chc define type value: 0-wait, 1-nowait(for UpdateMotionStatus())
      //AxisMove(1);
      AxisMove(1,0);

   }
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnBackwardMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   if(cbContinueMove->Checked == false)
      return;
   boolJogMove = false;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnHomeOneAxisClick(TObject *Sender)
{

   HomeOneAxis();
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnAlarmOnClick(TObject *Sender)
{

   CurrentAxisNo = combAxis->ItemIndex;
   SetAlmOn();
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnAlarmOffClick(TObject *Sender)
{

   CurrentAxisNo = combAxis->ItemIndex;
   SetAlmOff();
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnServoOnClick(TObject *Sender)
{

   CurrentAxisNo = combAxis->ItemIndex;
   SetServoOn();
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnServoOffClick(TObject *Sender)
{

   CurrentAxisNo = combAxis->ItemIndex;
   SetServoOff();
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnDOOnClick(TObject *Sender)
{

   CurrentAxisNo = combAxis->ItemIndex;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnDOOffClick(TObject *Sender)
{

   CurrentAxisNo = combAxis->ItemIndex;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnBackwardXClick(TObject *Sender)
{

   btnBackwardX->Enabled = false;

   // Log
   //WriteSystemLog(">btnBackwardX->Enabled = false - btnBackwardXClick");

   if(cbContinueMove->Checked == true)
      return;

   // 設定為Y軸, 做後退動作
   combAxis->ItemIndex = X_AXIS;
   btnBackwardClick(this);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnBackwardXMouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   // 指定軸
   combAxis->ItemIndex = X_AXIS;
   btnBackwardMouseDown(this,Button, Shift, X, Y);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnBackwardXMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   // Log
   //WriteSystemLog(">btnBackwardX->Enabled = true - btnBackwardXMouseUp");

   btnBackwardX->Enabled = true;
   if(cbContinueMove->Checked == false)
      return;
   boolJogMove = false;

   // Log
   //WriteSystemLog(">boolJogMove=false - btnBackwardXMouseUp");

   // 立即停止
   pnlSystemMessage->Caption = "X軸停止.";
   pnlSystemMessage->Refresh();
   StopOneAxis(X_AXIS);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnBackwardYClick(TObject *Sender)
{

   btnBackwardY->Enabled = false;

   // Log
   //WriteSystemLog(">btnBackwardY->Enabled = false - btnBackwardYClick");

   if(cbContinueMove->Checked == true)
      return;

   // 設定為Y軸, 做後退動作
   combAxis->ItemIndex = Y_AXIS;
   btnBackwardClick(this);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnBackwardYMouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   // 指定軸
   combAxis->ItemIndex = Y_AXIS;
   btnBackwardMouseDown(this,Button, Shift, X, Y);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnBackwardYMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   // Log
   //WriteSystemLog(">btnBackwardY->Enabled = true - btnBackwardYMouseUp");

   btnBackwardY->Enabled = true;
   if(cbContinueMove->Checked == false)
      return;
   boolJogMove = false;

   // Log
   //WriteSystemLog(">boolJogMove=false - btnBackwardYMouseUp");

   // 立即停止
   pnlSystemMessage->Caption = "Y軸停止.";
   pnlSystemMessage->Refresh();
   StopOneAxis(Y_AXIS);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnMoveYClick(TObject *Sender)
{

   btnMoveY->Enabled = false;
   if(cbContinueMove->Checked == true)
      return;

   // 設定為Y軸, 做後退動作
   combAxis->ItemIndex = Y_AXIS;
   btnMoveClick(this);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnMoveYMouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   // 指定軸
   combAxis->ItemIndex = Y_AXIS;
   btnMoveMouseDown(this,Button, Shift, X, Y);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnMoveYMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   btnMoveY->Enabled = true;
   if(cbContinueMove->Checked == false)
      return;
   boolJogMove = false;

   // Log
   //WriteSystemLog(">boolJogMove=false - btnMoveYMouseUp");

   // 立即停止
   pnlSystemMessage->Caption = "Y軸停止.";
   pnlSystemMessage->Refresh();
   StopOneAxis(Y_AXIS);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnMoveXClick(TObject *Sender)
{

   btnMoveX->Enabled = false;

   if(cbContinueMove->Checked == true)
      return;

   // 設定為Y軸, 做後退動作
   combAxis->ItemIndex = X_AXIS;
   btnMoveClick(this);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnMoveXMouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   // 指定軸
   combAxis->ItemIndex = X_AXIS;
   btnMoveMouseDown(this,Button, Shift, X, Y);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnMoveXMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   btnMoveX->Enabled = true;
   if(cbContinueMove->Checked == false)
      return;
   boolJogMove = false;

   // Log
   //WriteSystemLog(">boolJogMove=false - btnMoveXMouseUp");

   // 立即停止
   pnlSystemMessage->Caption = "X軸停止.";
   pnlSystemMessage->Refresh();
   StopOneAxis(X_AXIS);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnMoveTClick(TObject *Sender)
{

   btnMoveT->Enabled = false;
   if(cbContinueMove->Checked == true)
      return;

   // 設定為Y軸, 做後退動作
   combAxis->ItemIndex = T_AXIS;

   // 相反
   btnMoveClick(this);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnMoveTMouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   // 指定軸
   combAxis->ItemIndex = T_AXIS;

   // 相反
   btnMoveMouseDown(this,Button, Shift, X, Y);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnMoveTMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   btnMoveT->Enabled = true;
   if(cbContinueMove->Checked == false)
      return;
   boolJogMove = false;

   // Log
   //WriteSystemLog(">boolJogMove=false - btnMoveTMouseUp");

   // 立即停止
   pnlSystemMessage->Caption = "T軸停止.";
   pnlSystemMessage->Refresh();
   StopOneAxis(T_AXIS);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnBackwardZClick(TObject *Sender)
{

   btnBackwardZ->Enabled = false;
   if(cbContinueMove->Checked == true)
      return;

   // 設定為Y軸, 做後退動作
   combAxis->ItemIndex = Z_AXIS;
   btnBackwardClick(this);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnBackwardZMouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   // 指定軸
   combAxis->ItemIndex = Z_AXIS;
   btnBackwardMouseDown(this,Button, Shift, X, Y);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnBackwardZMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   btnBackwardZ->Enabled = true;
   if(cbContinueMove->Checked == false)
      return;
   boolJogMove = false;

   // Log
   //WriteSystemLog(">boolJogMove=false - btnBackwardZMouseUp");

   // 立即停止
   pnlSystemMessage->Caption = "Z軸停止.";
   pnlSystemMessage->Refresh();
   StopOneAxis(Z_AXIS);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnMoveZClick(TObject *Sender)
{

   btnMoveZ->Enabled = false;
   if(cbContinueMove->Checked == true)
      return;

   // 設定為Y軸, 做後退動作
   combAxis->ItemIndex = Z_AXIS;
   btnMoveClick(this);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnMoveZMouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   // 指定軸
   combAxis->ItemIndex = Z_AXIS;
   btnMoveMouseDown(this,Button, Shift, X, Y);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnMoveZMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   btnMoveZ->Enabled = true;
   if(cbContinueMove->Checked == false)
      return;
   boolJogMove = false;

   // Log
   //WriteSystemLog(">boolJogMove=false - btnMoveZMouseUp");

   // 立即停止
   pnlSystemMessage->Caption = "Z軸停止.";
   pnlSystemMessage->Refresh();
   StopOneAxis(Z_AXIS);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnBackwardTClick(TObject *Sender)
{
        
   btnBackwardT->Enabled = false;
   if(cbContinueMove->Checked == true)
      return;

   // 設定為Y軸, 做後退動作
   combAxis->ItemIndex = T_AXIS;

   // 相反
   btnBackwardClick(this);
   //btnMoveClick(this);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnBackwardTMouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   // 指定軸
   combAxis->ItemIndex = T_AXIS;

   // 相反
   btnBackwardMouseDown(this,Button, Shift, X, Y);
   //btnMoveMouseDown(this,Button, Shift, X, Y);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnBackwardTMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   btnBackwardT->Enabled = true;
   if(cbContinueMove->Checked == false)
      return;
   boolJogMove = false;

   // Log
   //WriteSystemLog(">boolJogMove=false - btnBackwardTMouseUp");

   // 立即停止
   pnlSystemMessage->Caption = "T軸停止.";
   pnlSystemMessage->Refresh();
   StopOneAxis(T_AXIS);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnStopClick(TObject *Sender)
{

   StopAxis(combAxis->ItemIndex);

   // 停止運作
   if(cbContinueMove->Checked == true) {
      boolJogMove = false;

      //WriteSystemLog(">boolJogMove=false - btnStopClick");

   }
   MotionStatus(true);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnMoveAbsoluteClick(TObject *Sender)
{

   if(MoveAbsolute(combAxis->ItemIndex) == false) {
      pnlSystemMessage->Caption = "Absolut Move失敗!";
   }
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnStopAbsoluteClick(TObject *Sender)
{

   StopAxis(combAxis->ItemIndex);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::cbContinueMoveChange(TObject *Sender)
{

   cbContinueMove1->Checked = cbContinueMove->Checked;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::cbContinueMove1Change(TObject *Sender)
{

   cbContinueMove->Checked = cbContinueMove1->Checked;
}
//---------------------------------------------------------------------------
// Motion Protect
void __fastcall TfrnMain::MotionStatus(bool mode)
{

   // 連動時不可以Disable否則不會停
   if(mode == true || cbContinueMove->Checked == false) {
      btnMove->Enabled = mode;
      btnBackward->Enabled = mode;
      btnMoveX->Enabled = mode;
      btnBackwardX->Enabled = mode;
      btnMoveY->Enabled = mode;
      btnBackwardY->Enabled = mode;
      btnMoveT->Enabled = mode;
      btnBackwardT->Enabled = mode;
      btnMoveZ->Enabled = mode;
      btnBackwardZ->Enabled = mode;
      btnMoveR->Enabled = mode;
      btnBackwardR->Enabled = mode;
   }

   // Stop要可以運作
   //rgAbsoluteMove->Enabled = mode;
   btnMoveAbsolute->Enabled = mode;

   rgHomeMove->Enabled = mode;
   gbSetting->Enabled = mode;

   gbAOICenter->Enabled = mode;
   tsDO->Enabled = mode;
   rgRelativeMove->Enabled = mode;

   // Home要管制
   btnHomeOneAxis->Enabled = mode;
   btnHome->Enabled = mode;
   combAxis->Enabled = mode;

}
//---------------------------------------------------------------------------
// 是否執行過Home? - boolHomeDone
void __fastcall TfrnMain::SetMotionStatus()
{

   MotionStatus(boolHomeDone);
}
//---------------------------------------------------------------------------
// 若HomeDone檢查Vacuum, CDA
// 設定boolCDAVacuum: false-Error, true-Success
bool __fastcall TfrnMain::CheckCDAVacuum()
{

   // 記錄是否開始做DIO
   if(boolDIO == false) {
      WriteSystemLog("CheckCDAVacuum: 尚未做過DIO更新, 不執行.");
      boolCDAVacuum = false;
      return false;
   }

   if(HSL_DI_InStatus1[3] == false) {
      WriteSystemLog("System CDA Error!");
      pnlSystemMessage->Caption = "系統CDA異常! 停止操作.";
      boolCDAVacuum = false;
      return false;
   }
   else {
      if(pnlSystemMessage->Caption == "系統CDA異常! 停止操作.")
         pnlSystemMessage->Caption = "";
   }

   if(HSL_DI_InStatus1[4] == false) {
      WriteSystemLog("System Vacuum Error!");
      pnlSystemMessage->Caption = "系統Vacuum異常! 停止操作.";
      boolCDAVacuum = false;
      return false;
   }
   else {
      if(pnlSystemMessage->Caption == "系統Vacuum異常! 停止操作.")
         pnlSystemMessage->Caption = "";
   }

   boolCDAVacuum = true;
   return true;
}
//---------------------------------------------------------------------------
// For Motion
void __fastcall TfrnMain::MoveMouseUp()
{
TMouseButton Button;
TShiftState Shift;
int X;
int Y;

   btnMoveMouseUp(this, Button, Shift, X, Y);
}
//---------------------------------------------------------------------------
// For Motion
void __fastcall TfrnMain::BackwardMouseUp()
{
TMouseButton Button;
TShiftState Shift;
int X;
int Y;

   btnBackwardMouseUp(this,Button,Shift,X,Y);
}
//---------------------------------------------------------------------------
// 播放賓效
void __fastcall TfrnMain::AlarmSound()
{
char fname[180];

   //sprintf(fname,"%s\\Powerup.WAV",SystemDirectory);
   sprintf(fname,"%s\\notify.WAV",SystemDirectory);
   PlaySound(fname,0,SND_ASYNC);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::pnlWidthValueClick(TObject *Sender)
{

   pcSystem->Enabled = true;
   pcRobot->Enabled = true;
   btnHome->Enabled = true;
   btnHome2->Enabled = true;
   btnMove->Enabled = true;
   btnBackward->Enabled = true;
   pcMotion->Enabled = true;
   tsMotion->Enabled = true;
   gbMotion->Enabled = true;
   tsMotionSetting->Enabled = true;
   tsDO->Enabled = true;
   tsDI->Enabled = true;
   pnlEFEM->Enabled = true;
   pnlSystem->Visible = true;
   btnCassetteLoad->Enabled = true;
   btnCassette2Load->Enabled = true;
   frmRecipe->btnCassetteLoad->Enabled = true;
   frmRecipe->btnCassette2Load->Enabled = true;
   pnlMain->Enabled = true;
   pnlMainRecipe->Enabled = true;
   pnlMainInspection->Enabled = true;
   pnlMainDevice->Enabled = true;
   pnlMainMaintenance->Enabled = true;
   pnlMain->Color = ENABLE_COLOR;
   pnlMainRecipe->Color = ENABLE_COLOR;
   pnlMainInspection->Color = ENABLE_COLOR;
   pnlMainDevice->Color = ENABLE_COLOR;
   pnlMainMaintenance->Color = ENABLE_COLOR;
   MotionStatus(true);
   tsCCD->TabVisible = true;
   frmLogo->btnMainHardwareSetup->Enabled = true;
   frmLogo->btnMainRecipeSetup->Enabled = true;
   pnlEFEM2->Visible = true;
   frmLogo->Enabled = true;
   pnlBXFM->Enabled = true;

   double fvalue,degree;
   fvalue = 0.08;
   degree = (atan(fvalue) * 360.0) / (2*M_PI);
   fvalue = 1;
   degree = (atan(fvalue) * 360.0) / (2*M_PI);
}
//---------------------------------------------------------------------------
// 2022 12 7 - chc Mouse Position
int SysMousePosX = -1;
int SysMousePosY = -1;
int MousePosX = -1;
int MousePosY = -1;

// 2022 8 10 - chc 記錄取退片中
bool boolInLoad = false;
bool boolInUnLoad = false;

long OPStartTime,OPStopTime,OPElapsedms;
short OPStartTick,OPStopTick;

int iImageWidth,iImageHeight;

// 2022 9 15 - chc 記錄是否在做Z1 Up
bool boolZ1InUp = false;
bool boolZ1InDown = false;

void __fastcall TfrnMain::tmSystemTimer(TObject *Sender)
{
AnsiString dateString,timeString;
static int alarmno = 0;
static int clientcount = 0;
static int cnt = 0;

// Thread Resume在此做, 進行SetupMotion時間: 2sec後
static int SetupTimeCount = 0;
static bool boolSetupTime = false;

   // 偵測系統異常
   static int CCDIdleCount = 0;

   // 2022 12 7 - chc StartTime
   if(PriorityLevel > PRIORITY_OP) {
      if(SysMousePosX != MousePosX || SysMousePosX != MousePosX) {
         GetTimeTic(&LevelStartTime,&LevelStartTick);
         SysMousePosX = MousePosX;
         SysMousePosY = MousePosY;
      }
      else {
         GetTimeTic(&LevelStopTime,&LevelStopTick);
         LevelElapsedms = ((LevelStopTime*1000+LevelStopTick) - (LevelStartTime*1000+LevelStartTick));
         // 5 min
         if((LevelElapsedms/1000) > 15*60) {
            PriorityLevel = PRIORITY_OP;
            SwitchLevel();
         }   
      }
   }

   // 2022 8 12 - chc Timer
   // 2022 8 14 - chc 是boolInLoad才對
   //if(boolInLoadWafer == true || boolInUnLoad == true) {
   if(boolInLoad == true || boolInUnLoad == true) {

      GetTimeTic(&OPStopTime,&OPStopTick);
      OPElapsedms = ((OPStopTime*1000+OPStopTick) - (OPStartTime*1000+OPStartTick));
      timeString.sprintf("%.2f",(double)OPElapsedms / 1000);
      pnlOperationTime->Caption = timeString;
   }

   // 作業訊息閃爍顯示
   if(pnlStartMessage->Visible == true) {
      if(pnlStartMessage->Font->Color == clWhite)
         pnlStartMessage->Font->Color = clNavy;
      else
         pnlStartMessage->Font->Color = clWhite;
   }

   // 2022 9 12a - chc 加做
   if(boolInMotionUpdate == false) {
      UpdateMotionStatus();

      // 2022 9 15 - chc 記錄是否在做Z1 Up
      if(boolZ1InUp == true)
         WriteSystemLog("Z1 Up(SystemTimer): 做DI更新");

      // 2022 9 23 - chc 記錄是否在做Z1 Down
      if(boolZ1InDown == true)
         WriteSystemLog("Z1 Down(SystemTimer): 做DI更新");

   }

   // 作業訊息閃爍顯示
   if(pnlMoving->Visible == true) {
      if(pnlMoving->Font->Color == clWhite)
         pnlMoving->Font->Color = clYellow;
      else
         pnlMoving->Font->Color = clWhite;
   }

   // Thread Resume在此做, 進行SetupMotion時間: 2sec後
   SetupTimeCount++;
   if(SetupTimeCount >= 2 && boolSetupTime == false) {
      boolSetupTime = true;
      // Motion Init
      if(bool_APS_Status == true) {
         pnl7856Status->Color = clLime;
         pnlSystemMessage->Caption = "等待Motion SVON...";
         WriteSystemLog(">tmSystemTimer : Do AxisSVON()");
         AxisSVON();
         if(btnHome->Enabled == true)
            pnlSystemMessage->Caption = "Motion SVON OK.";
         else
            pnlSystemMessage->Caption = "Motion SVON Fail!";
      }
      // 往上移動
      frnMain->Top = 0;

      // 2022 7 18 - chc 有CCD才啟動
      // 3個CCD
      for(int i=0 ; i<3 ; i++) {
         if(bool_scA1300_StatusAry[i] == true)
            scA1300ThreadAry[i]->Resume();
      }

      // 2022 7 25 - chc 也做BXFM的設定
      // Control/LMP/OB/CUBE/LMPSelect/Switch/AS/Filter Wheel
      SetBXFMValue();

   }

   // 是否離開程式?
   //if(ExitYes == true) {
   //   Close();
   //}

   // 更新設備狀態
   UpdateDeviceStatus();

   // EMO異常!
   if(pnlEMOAlarm->Color == clRed) {
      if(pnlEMO->Visible == false) {
         //pnlEMO->Visible = true;
         pnlEMO->Caption = "EMO Pressed! Motion Stop.";
         pnlAlarm->Caption = pnlEMO->Caption;
         AddMainLog("EMO Pressed!", EMO_ERR,true);
         // 設定為要等Motion Home
         boolHomeDone = false;
         pnlAllHomeStatus->Color = clSilver;
         MotionStatus(false);
         SetRedLamp(true);
         Beep(500);
      }
      if(pnlEMO->Font->Color == clWhite)
         pnlEMO->Font->Color = clSilver;
      else
         pnlEMO->Font->Color = clWhite;
   }
   else {
      if(pnlEMO->Visible == true) {
         // 要執行Home才能繼續
         // 軸控無異常才能Enable
         boolHomeDone = false;
         pnlAllHomeStatus->Color = clSilver;
         // 記錄是否有開門或按下EMC
         boolDoorEMO = true;
      }
   }

   // 軸控異常!
   if(pnlAxisError->Visible == true) {
      if(pnlAxisError->Font->Color == clWhite)
         pnlAxisError->Font->Color = clSilver;
      else
         pnlAxisError->Font->Color = clWhite;
   }

   // Process alarm
   UpdateAlarmStatus();

   // 2022 9 23 - chc 做更新
   //=> 不做, 由tm400ms做
   //Application->ProcessMessages();

}
//---------------------------------------------------------------------------
// PCI-7856(APS_)
void __fastcall TfrnMain::AxisSVON()
{
int hslret;
int rdycnt = 0;

static bool boolfirst = true;

   if(boolfirst == false) {
      // Load 參數檔(會少IPT_MODE/OPT_MODE/IPT_LOGIC等項...)
      AnsiString fname = frnMain->SystemDirectory + "\\Motion.xml";
      int ret = APS_load_param_from_file(fname.c_str());
      // 確認是否有讀取?
      if(ret != ERR_NoError)
         Application->MessageBox((AnsiString("XML檔讀取失敗!") + fname + ":" + IntToStr(ret)).c_str(),"XML檔寫入作業    ",MB_OK);
      Sleep(500);
   }

   // I/O: 在InitMotion()中已建立
   if(bool_IO_Status == true) {
      // 初始Input點
      for(int i=0 ; i<16 ; i++) {
         HSL_DI_InStatus1[i] = false;
         HSL_DI_InStatus2[i] = false;
      }
      for(int i=0 ; i<32 ; i++) {
         HSL_DI_InStatus3[i] = false;
      }

      // DO Reset 0
      if(boolfirst == true) {

         frnMain->WriteSystemLog(">Motion : Reset DO");
         InitDO();
      }
   }

   // 啟動Timer
   if(bool_IO_Status == true && tmMotionPolling->Enabled == false) {
      tmMotionPolling->Enabled = true;
      WriteSystemLog(">AxisSVON : DIO ok, Polling");
   }

   Sleep(500);
   WriteSystemLog(">Motion : Servo On...");
   // 啟動Motion: Servo on
   if(bool_APS_Status == true) {
      for(int axisno=0 ; axisno<MAX_AXIS_NO ; axisno++) {
         if(DOServoOnOff(axisno,3) == true)
            rdycnt++;
      }
   }

   if(rdycnt >= MAX_AXIS_NO) {
      Sleep(1000);
      // 先等候SVON才做Home
      btnHome->Enabled = true;
      btnHome2->Enabled = true;
      pnlStartMessage->Visible = true;
      pnlStartMessage->Caption = "請先執行[原點復歸]...";
      pnlStartMessage->Refresh();
      // 設定Blinking: 要在SVON後做
      boolAllHomeState = true;
      if(pnlAxisError->Visible == true && pnlAxisError->Caption.Pos("Axis-") > 0) {
         pnlAxisError->Visible = false;
      }

   }
   else {
      btnHome->Enabled = false;
      btnHome2->Enabled = false;
      pnlAxisError->Caption = "軸控異常(無法SVON)! 請重新啟動系統.";
      //pnlAxisError->Visible = true;
      pnlAlarm->Caption = pnlAxisError->Caption;
      pnlSystemMessage->Caption = pnlAxisError->Caption;
      //pnl7856Status->Color = clRed;
      //pnlPCI7856->Color = clRed;
      shMotionStatus->Brush->Color = clRed;

   }

   // 軸編號: 0~3
   CurrentAxisNo = X_AXIS;
   combAxis->ItemIndex = 0;
   boolfirst = false;
}
//---------------------------------------------------------------------------
// 更新設備狀態
void __fastcall TfrnMain::UpdateDeviceStatus()
{

   if(pnlCCD->Color == clRed || pnlAOILamp->Color == clRed || pnlPCI7856->Color == clRed)
      shDeviceStatus->Brush->Color = clRed;
   else
      shDeviceStatus->Brush->Color = clLime;

   // 上燈源狀態
   shUpLamp->Brush->Color = pnlAOILamp->Color;
   // 無下燈源
   shDownLamp->Brush->Color = clSilver;

}
//---------------------------------------------------------------------------
// 先SERVO off, DO off 再 DO on, SERVO on
bool __fastcall TfrnMain::DOServoOnOff(int axisno, int cnt)
{
I32 io_sts;

static bool boolfirst = true;

   WriteSystemLog(">DOServoOnOff() : Enter");

   // 連做三次
   io_sts = APS_motion_io_status(axisno+StartAxisNo);
   WriteSystemLog(">DOServoOnOff() : Got sts");
   for(int i=0 ; i<cnt ; i++) {

      // Alm(Bit0): Fail
      //if(axisno == X_AXIS || axisno == Y_AXIS || axisno == Z_AXIS) {
         if(io_sts & 0x0001) {
            WriteSystemLog(">DOServoOnOff() : Axis" + IntToStr(axisno) + " ALM! 不做SVON.");
            // Servo Off
            APS_set_servo_on(axisno+StartAxisNo, 0);
            return false;
         }
      //}
      //else {
      //   if((io_sts & 0x0001) == 0) {
      //      WriteSystemLog(">DOServoOnOff() : Axis" + IntToStr(axisno) + " ALM! 不做SVON.");
      //      // Servo Off
      //      APS_set_servo_on(axisno+StartAxisNo, 0);
      //      return false;
      //   }
      //}

      if(boolfirst == false) {
         APS_set_servo_on(axisno+StartAxisNo, 0);
         DelayTime(300);
      }

      // Servo On
      APS_set_servo_on(axisno+StartAxisNo, 1);
      DelayTime(500);

      // 確認RDY(Bit8): IO Status
      io_sts = APS_motion_io_status(axisno+StartAxisNo);

      // 也要檢查SVON(bit7): (io_sts & 0x0080)
      //if(axisno == X_AXIS || axisno == Y_AXIS || axisno == Z_AXIS) {
         if((io_sts & 0x0100) != 0 && (io_sts & 0x0080) != 0) {
            WriteSystemLog(">DOServoOnOff() : Axis" + IntToStr(axisno) + " RDY,SVON.");
            return true;
         }
      //}
      //else {
      //   if((io_sts & 0x0100) == 0 && (io_sts & 0x0080) != 0) {
      //      WriteSystemLog(">DOServoOnOff() : Axis" + IntToStr(axisno) + " RDY,SVON.");
      //      return true;
      //   }
      //}

      //if(axisno == X_AXIS || axisno == Y_AXIS || axisno == Z_AXIS) {
         if((io_sts & 0x0100) == 0)
            WriteSystemLog(">DOServoOnOff() : Axis" + IntToStr(axisno) + " Not Ready! 再做一次.");
      //}
      //else {
      //   if((io_sts & 0x0100) != 0)
      //      WriteSystemLog(">DOServoOnOff() : Axis" + IntToStr(axisno) + " Not Ready! 再做一次.");
      //}

      if((io_sts & 0x0080) == 0)
         WriteSystemLog(">DOServoOnOff() : Axis" + IntToStr(axisno) + " Not SVON! 再做一次.");

      // Servo Off
      APS_set_servo_on(axisno+StartAxisNo, 0);
      // 連做三次; 間隔1500ms
      DelayTime(1500);
   }
   WriteSystemLog(">DOServoOnOff() : Axis" + IntToStr(axisno) + " SVON無法RDY!");
   // Servo Off
   APS_set_servo_on(axisno+StartAxisNo, 0);
   boolfirst = false;
   return false;

}
//---------------------------------------------------------------------------
// 10ms一次
void __fastcall DelayTime(int no)
{
long starttime,stoptime,elapsedms;
short starttick,stoptick;
int cnt = 0;

   frnMain->GetTimeTic(&starttime,&starttick);
   while(1) {
      Application->ProcessMessages();
      Sleep(HOST_SLEEP_TIME);
      cnt++;
      if(cnt >= 20) {
         // 延長Delay Time
         Sleep(1);
         cnt = 0;
         frnMain->GetTimeTic(&stoptime,&stoptick);
         elapsedms = ((stoptime*1000+stoptick) - (starttime*1000+starttick));
         if(elapsedms > no)
            return;
      }
   }
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::tm400msTimer(TObject *Sender)
{

   if(boolAllHomeState == true) {
      if(btnHome2->Font->Color == clNavy) {
         btnHome2->Font->Color = clSilver;
      }
      else {
         btnHome2->Font->Color = clNavy;
      }

      // 2022 12 6 - chc Logo Form
      //if(frmLogo->Visible == true) {
      //   if(frmLogo->pnlHome3->Font->Color == clNavy) {
      //      frmLogo->pnlHome3->Font->Color = clSilver;
      //   }
      //   else {
      //      frmLogo->pnlHome3->Font->Color = clNavy;
      //   }
      //}

   }

   // 2022 9 23 - chc Message
   Application->ProcessMessages();

}
//---------------------------------------------------------------------------
// WVQuartz.ini
void __fastcall TfrnMain::btnSavePositionClick(TObject *Sender)
{
TIniFile *pSystemFile;
AnsiString axisname;

   pSystemFile = new TIniFile(SystemINIFilename);

   // [Position Parameter]各點位置 : X/Y/Z/T
   TLMDEdit *editx,*edity,*editz,*editt;
   for(int no=0 ; no<MAX_POSITION_NO ; no++) {
      if(no == POSITION_CENTER)
         axisname = "Center";
      else if(no == POSITION_45)
         axisname = "45";
      else if(no == POSITION_0)
         axisname = "0";
      else if(no == POSITION_LOAD)
         axisname = "Load";
      else if(no == POSITION_ORIGINAL)
         axisname = "Original";
      else if(no == POSITION_CCD)
         axisname = "CCD";
      else if(no == POSITION_R45)
         axisname = "R45";
      editx = (TLMDEdit *)(FindComponent("ed" + axisname + "X"));
      Position[no].X = editx->Text.ToInt();
      pSystemFile->WriteInteger(POSITION_PARAMETER_SECTION,axisname+" PositionX" ,Position[no].X);
      edity = (TLMDEdit *)(FindComponent("ed" + axisname + "Y"));
      Position[no].Y = edity->Text.ToInt();
      pSystemFile->WriteInteger(POSITION_PARAMETER_SECTION,axisname+" PositionY" ,Position[no].Y);
      editz = (TLMDEdit *)(FindComponent("ed" + axisname + "Z"));
      Position[no].Z = editz->Text.ToInt();
      pSystemFile->WriteInteger(POSITION_PARAMETER_SECTION,axisname+" PositionZ" ,Position[no].Z);
      editt = (TLMDEdit *)(FindComponent("ed" + axisname + "T"));
      Position[no].T = editt->Text.ToInt();
      pSystemFile->WriteInteger(POSITION_PARAMETER_SECTION,axisname+" PositionT" ,Position[no].T);
   }

   // CCD X Direction
   boolCCDXDirection = cbCCDXDirection->Checked;
   pSystemFile->WriteBool("System Parameter","bool CCD X Direction"             ,boolCCDXDirection);
   // CCD Y Direction
   boolCCDYDirection = cbCCDYDirection->Checked;
   pSystemFile->WriteBool("System Parameter","bool CCD Y Direction"             ,boolCCDYDirection);
   // Lens X Direction
   boolLensXDirection = cbLensXDirection->Checked;
   pSystemFile->WriteBool("System Parameter","bool Lens X Direction"             ,boolLensXDirection);
   // Lens Y Direction
   boolLensYDirection = cbLensYDirection->Checked;
   pSystemFile->WriteBool("System Parameter","bool Lens Y Direction"             ,boolLensYDirection);

   // T轉動時的Z最低高度(最大值): edTMoveZMax
   int maxz = edTMoveZMax->Text.ToInt();
   pSystemFile->WriteInteger(POSITION_PARAMETER_SECTION,"TMoveMaxZ" ,maxz);

   delete pSystemFile;
}
//---------------------------------------------------------------------------
// WVQuartz.ini
void __fastcall TfrnMain::btnSaveMotionParameterClick(TObject *Sender)
{
TIniFile *pSystemFile;
AnsiString axisname;

   pSystemFile = new TIniFile(SystemINIFilename);

   // [Motion Information] 各軸資訊
   //struct MOTION_STRU   {
   //   int StartVel,MaxVel,Distance,Position,HomeVel,ReviewVel,UpLimit,HomeMode,LowDistance;
   //   bool ORGLogic;
   //   double Tacc,Tdec;
   //};
   //struct MOTION_STRU   MotionParameter[MAX_AXIS_NO];
   TLMDEdit *edit;
   TLMDCheckBox *checkbox;
   TLMDComboBox *combobox;
   for(int i=0 ; i<MAX_AXIS_NO ; i++) {
      GetAxisName(i);
      axisname = AxisName;

      edit = (TLMDEdit *)(FindComponent("edStartVel" + axisname));
      MotionParameter[i].StartVel = edit->Text.ToInt();
      pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,axisname+START_VEL       ,MotionParameter[i].StartVel);
      edit = (TLMDEdit *)(FindComponent("edMaxVel" + axisname));
      MotionParameter[i].MaxVel = edit->Text.ToInt();
      pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,axisname+MAX_VEL         ,MotionParameter[i].MaxVel);
      edit = (TLMDEdit *)(FindComponent("edDistance" + axisname));
      MotionParameter[i].Distance = edit->Text.ToInt();
      pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,axisname+DISTANCE        ,MotionParameter[i].Distance);
      edit = (TLMDEdit *)(FindComponent("edPosition" + axisname));
      MotionParameter[i].Position = edit->Text.ToInt();
      pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,axisname+POSITION        ,MotionParameter[i].Position);
      edit = (TLMDEdit *)(FindComponent("edHomeVel" + axisname));
      MotionParameter[i].HomeVel = edit->Text.ToInt();
      pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,axisname+HOME_VEL        ,MotionParameter[i].HomeVel);
      edit = (TLMDEdit *)(FindComponent("edReviewVel" + axisname));
      MotionParameter[i].ReviewVel = edit->Text.ToInt();
      pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,axisname+REVIEW_VEL      ,MotionParameter[i].ReviewVel);
      edit = (TLMDEdit *)(FindComponent("edUpLimit" + axisname));
      MotionParameter[i].UpLimit = edit->Text.ToInt();
      pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,axisname+UP_LIMIT        ,MotionParameter[i].UpLimit);
      edit = (TLMDEdit *)(FindComponent("edTacc" + axisname));
      MotionParameter[i].Tacc = edit->Text.ToDouble();
      pSystemFile->WriteFloat(MOTION_INFORMATION_SECTION  ,axisname+TACC            ,MotionParameter[i].Tacc);
      edit = (TLMDEdit *)(FindComponent("edTdec" + axisname));
      MotionParameter[i].Tdec = edit->Text.ToDouble();
      pSystemFile->WriteFloat(MOTION_INFORMATION_SECTION  ,axisname+TDEC            ,MotionParameter[i].Tdec);

      edit = (TLMDEdit *)(FindComponent("edLowDistance" + axisname));
      MotionParameter[i].LowDistance = edit->Text.ToInt();
      pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION  ,axisname+LOW_DISTANCE  ,MotionParameter[i].LowDistance);

      combobox = (TLMDComboBox *)(FindComponent("combHomeMode" + axisname));
      MotionParameter[i].HomeMode = combobox->Text.ToInt();
      pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,axisname+HOME_MODE       ,MotionParameter[i].HomeMode);
   }

   int zmin,zmax;
   double tresolution;
   // Z
   zmin = edMinZPosition->Text.ToInt();
   zmax = edMaxZPosition->Text.ToInt();
   tresolution = edTResolution->Text.ToDouble();
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,"Z Min"                     ,zmin);
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,"Z Max"                     ,zmax);
   pSystemFile->WriteFloat(MOTION_INFORMATION_SECTION  ,"T Resolution"              ,tresolution);
   // T
   int tmin,tmax;
   tmin = edMinTPosition->Text.ToInt();
   tmax = edMaxTPosition->Text.ToInt();
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,"T Min"                     ,tmin);
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,"T Max"                     ,tmax);

   // 2022 8 4 - chc 加入X/Y Min/Max
   int xmin,xmax;
   xmin = edMinXPosition->Text.ToInt();
   xmax = edMaxXPosition->Text.ToInt();
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,"X Min"                     ,xmin);
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,"X Max"                     ,xmax);
   int ymin,ymax;
   ymin = edMinYPosition->Text.ToInt();
   ymax = edMaxYPosition->Text.ToInt();
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,"Y Min"                     ,ymin);
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,"Y Max"                     ,ymax);

   delete pSystemFile;
}
//---------------------------------------------------------------------------
// WVQuartz.ini
void __fastcall TfrnMain::btnSaveCCDClick(TObject *Sender)
{
TIniFile *pSystemFile;
AnsiString str;
double fvalue;
int ivalue;
int ccdno;

   ccdno = combCCDSelect->ItemIndex;
   try {
      pSystemFile = new TIniFile(SystemINIFilename);

      // CCD Precision
      fvalue = edCCDPrecision->Text.ToDouble();
      CCDPrecision = fvalue;
      pSystemFile->WriteFloat("CCD" ,CCD_PRECISION                                 ,CCDPrecision);
      Set400Width();

      // GridPixel
      GridPixel = edGridPixel->Text.ToInt();
      pSystemFile->WriteInteger("CCD" ,"Grid Pixel"                                ,GridPixel);

      // Ruler Color
      iRulerColor = rgRulerColor->ItemIndex;
      pSystemFile->WriteInteger("CCD","int Ruler Color"                            ,iRulerColor);

      // Cross Mark
      iCrossMark = rgRulerType->ItemIndex;
      pSystemFile->WriteInteger("CCD","int Cross Mark"                             ,iCrossMark);
      // edStdGray
      int stdgray = edStdGray->Text.ToInt();
      pSystemFile->WriteInteger("CCD","Std Gray"                                   ,stdgray);
      int stdgraytolerance = edStdGrayTolerance->Text.ToInt();
      pSystemFile->WriteInteger("CCD","Std Gray Tolerance"                         ,stdgraytolerance);

      // Multi CCD
      if(ccdno == CCD_TOP) {
         // 設定Gain/Shutter: CCDShutterAry, CCDGainAry, CCDContrastAry
         CCDShutterAry[ccdno] = rgCCDShutter->ItemIndex;
         CCDGainAry[ccdno] = tbCCDGain->Position;
         CCDContrastAry[ccdno] = tbContrast->Position;
         pSystemFile->WriteInteger("CCD","Shutter"                                    ,CCDShutterAry[ccdno]);
         pSystemFile->WriteInteger("CCD","Gain"                                       ,CCDGainAry[ccdno]);
         pSystemFile->WriteInteger("CCD","Contrast"                                   ,CCDContrastAry[ccdno]);

         // 2023 1 3 - chc White Balance
         CCDWBAuto[ccdno] = cbWBAuto->Checked;
         pSystemFile->WriteBool("CCD","Bool White Balance Auto"                    ,CCDWBAuto[ccdno]);
      }
      else if(ccdno == CCD_LEFT) {
         // 設定Gain/Shutter: CCDShutterAry, CCDGainAry, CCDContrastAry
         CCDShutterAry[ccdno] = rgCCDShutter->ItemIndex;
         CCDGainAry[ccdno] = tbCCDGain->Position;
         CCDContrastAry[ccdno] = tbContrast->Position;
         pSystemFile->WriteInteger("CCDLeft","Shutter"                                    ,CCDShutterAry[ccdno]);
         pSystemFile->WriteInteger("CCDLeft","Gain"                                       ,CCDGainAry[ccdno]);
         pSystemFile->WriteInteger("CCDLeft","Contrast"                                   ,CCDContrastAry[ccdno]);
         // White Balance
         CCDWBAuto[ccdno] = cbWBAuto->Checked;
         pSystemFile->WriteBool("CCDLeft","Bool White Balance Auto"                    ,CCDWBAuto[ccdno]);
      }
      else if(ccdno == CCD_RIGHT) {
         // 設定Gain/Shutter: CCDShutterAry, CCDGainAry, CCDContrastAry
         CCDShutterAry[ccdno] = rgCCDShutter->ItemIndex;
         CCDGainAry[ccdno] = tbCCDGain->Position;
         CCDContrastAry[ccdno] = tbContrast->Position;
         pSystemFile->WriteInteger("CCDRight","Shutter"                                    ,CCDShutterAry[ccdno]);
         pSystemFile->WriteInteger("CCDRight","Gain"                                       ,CCDGainAry[ccdno]);
         pSystemFile->WriteInteger("CCDRight","Contrast"                                   ,CCDContrastAry[ccdno]);
         // White Balance
         CCDWBAuto[ccdno] = cbWBAuto->Checked;
         pSystemFile->WriteBool("CCDRight","Bool White Balance Auto"                    ,CCDWBAuto[ccdno]);
      }

      delete pSystemFile;

   }
   catch(Exception &e) {
      WriteSystemLog("SaveCCDParameter() - Error");
      sbSystem->Panels->Items[1]->Text = "SaveCCDParameter() - Error";
   }

}
//---------------------------------------------------------------------------
// Aligner
// WVQuartz.ini
void __fastcall TfrnMain::btnSaveQRCodeClick(TObject *Sender)
{
TIniFile *pSystemFile;
AnsiString str;
double fvalue;
int ivalue;
bool bflag;

   try {
      pSystemFile = new TIniFile(SystemINIFilename);

      // 2021 11 11 - chc 心跳包Interval
      ivalue = edInterval->Text.ToInt();
      if(ivalue < 50)
         ivalue = 50;
      else if(ivalue > 2000)
         ivalue = 2000;
      StatusInterval = ivalue;
      tmStatus->Interval = StatusInterval;
      tmStatus2->Interval = StatusInterval;
      pSystemFile->WriteInteger("QRCode" ,"Interval Time"                      ,ivalue);

      // Cognex 174: HostName = is1741_823dba
      QRCodePort1 = edQRCodePort1->Text.ToInt();
      QRCodeIP1 = edQRCodeIP1->Text;
      pSystemFile->WriteInteger("QRCode1","Port",QRCodePort1);
      pSystemFile->WriteString("QRCode1","IP",QRCodeIP1);
      QRCodePort2 = edQRCodePort2->Text.ToInt();
      QRCodeIP2 = edQRCodeIP2->Text;
      pSystemFile->WriteInteger("QRCode2","Port",QRCodePort2);
      pSystemFile->WriteString("QRCode2","IP",QRCodeIP2);

      // Degree: edQRCodeDegree
      QRCodeDegree = edQRCodeDegree->Text.ToDouble();
      pSystemFile->WriteFloat("QRCode","Degree",QRCodeDegree);

      delete pSystemFile;

   }
   catch(Exception &e) {
      WriteSystemLog("SaveQRCodeParameter() - Error");
      sbSystem->Panels->Items[1]->Text = "SaveQRCodeParameter() - Error";
   }
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::laCIMClick(TObject *Sender)
{
F64 tacc,tdec;
int dist,startvel,maxvel,homevel,reviewvel,uplimit,lowdistance,lowreviewvel;
int axisno,pos;

   axisno = T_AXIS;
   combAxis->ItemIndex = axisno;
   GetAxisData(axisno,&dist,&startvel,&maxvel,&tacc,&tdec,&homevel,&reviewvel,&uplimit,&lowdistance);
   pos = 380000;
   DoAxisTrMove(axisno, pos, startvel, lowreviewvel, tacc, tdec);
}
//---------------------------------------------------------------------------
// Performance Message
void __fastcall TfrnMain::AddPerformanceMessage(AnsiString putmsg)
{

   AnsiString msg;
   msg = Now().FormatString("hh':'nn':'ss':'zzz'-> '") + putmsg;
   //mmPerformance->Lines->Insert(0,putmsg);
   mmPerformance->Lines->Insert(0,msg);
}
//---------------------------------------------------------------------------
// 400 Pixel distance
void __fastcall TfrnMain::Set400Width()
{
double dis;
AnsiString msg;

   dis = (double)pnlWidthValue->Width * CCDPrecision;

   // 全影像比例
   double ratiox;
   ratiox = 1.0;
   if(cbCCDFullImage->Checked == true) {
      ratiox = CCDInfoAry[0].Width / imCCD->Width;
      dis *= ratiox;
   }

   msg.sprintf("%.2fum",dis);
   pnlWidthValue->Caption = msg;
}
//---------------------------------------------------------------------------
// 2021 8 17a - chc 自動調光

void __fastcall TfrnMain::edCCDPrecisionExit(TObject *Sender)
{

   Set400Width();
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::pnlQRCodeConnectClick(TObject *Sender)
{

   pnlVersionClick(this);
   return;
}
//---------------------------------------------------------------------------
// mode: true - 動作中
void __fastcall TfrnMain::SetMoving(bool mode)
{

   if(mode == true) {
      pcSystem->Enabled = false;
      //pnlMoving->Visible = true;
      pnlAlarm->Caption = pnlMoving->Caption;
   }
   else {
      pcSystem->Enabled = true;
      //pnlMoving->Visible = false;
      if(pnlAlarm->Caption == pnlMoving->Caption)
         pnlAlarm->Caption = "";
   }
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::cbBit0Click(TObject *Sender)
{

   WriteDO(IO1_ID);
}
//---------------------------------------------------------------------------
void __fastcall TfrnMain::ComputeAverageGray()
{
int stdgray,x1,y1,x2,y2,row,col,cnt,sum,average;
unsigned char *ptr;

   x1 = imCCD->Width / 4;
   x2 = x1 + imCCD->Width / 2;
   y2 = imCCD->Height - 50;
   y1 = y2 - 50;
   cnt = 0;
   sum = 0;
   average = 0;

   for(row=y1 ; row<y2 ; row+=2) {
      ptr = (unsigned char *)CCDImageAry[0].GetImagePtr(0,row);
      for(col=x1 ; col<x2 ; col+=2) {
         cnt++;
         sum += ptr[col];
      }
   }
   if(cnt > 0)
      average = sum / cnt;

   pnlAverageGray->Caption = IntToStr(average);
}
//---------------------------------------------------------------------------
// 心跳包: 1Sec
void __fastcall TfrnMain::tmStatusTimer(TObject *Sender)
{
char sendbuf[50];

   if(pnlSocketConnect->Color != clLime)
      return;
   if(cbTrigger->Checked == false)
      return;

   // Disable
   tmStatus->Enabled = false;

   pnlMessage->Caption = "送出QRCode";
   WriteSystemLog("送出QRCode");
   sprintf(sendbuf,"QRCode");
   SendSocket(sendbuf);
   AddMessage(pnlMessage->Caption);

   // Disable
   tmStatus->Enabled = true;

}
//---------------------------------------------------------------------------
void __fastcall TfrnMain::FormClose(TObject *Sender, TCloseAction &Action)
{

   //if(ExitYes == true)
   //   goto toexit;

   // 2021 9 9 - chc close
   if(Application->MessageBox("Sure to Exit System?      ", "Motion Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
      Action = caNone;
      return;
   }

   // 2021 9 1 - chc 取消心跳包
   tmStatus->Enabled = false;
   tmStatus2->Enabled = false;

   // 強制停止
   if(iAxisMove[X_AXIS] != NO_MOVE) {
      WriteSystemLog("X軸尚未停止! 強制停止");
      iAxisMove[X_AXIS] = NO_MOVE;
   }
   if(iAxisMove[Y_AXIS] != NO_MOVE) {
      WriteSystemLog("Y軸尚未停止! 強制停止");
      iAxisMove[Y_AXIS] = NO_MOVE;
   }
   if(iAxisMove[Z_AXIS] != NO_MOVE) {
      WriteSystemLog("Z軸尚未停止! 強制停止");
      iAxisMove[Z_AXIS] = NO_MOVE;
   }
   if(iAxisMove[T_AXIS] != NO_MOVE) {
      WriteSystemLog("T軸尚未停止! 強制停止");
      iAxisMove[T_AXIS] = NO_MOVE;
   }
   StopAllAxis();
   if(MoveDirection != 0) {
      WriteSystemLog("MoveDirection不為0: " + IntToStr(MoveDirection));
      MoveDirection = 0;
      WriteSystemLog("MoveDirection = 0 => 2");
   }

   // 2020 3 4 - chc 關閉前強制到原點或入料點
   ForceToOriginal();

   // 2016 5 20 - chc 加入Try-Catch
   try {
      if(boolJoystick == true) {
         FreeJoystick();
         tmJoystick->Enabled = false;
      }
      CloseAllTimer();
      if(bool_APS_Status == true) {
         // DO Reset 0
         InitDO();
         WriteSystemLog("Close DO");
         APS_close();
         WriteSystemLog("Close APS Function");
      }

      // 2022 8 23 - chc 若有A2M要AF off
      if(pnlBXFMStatus->Color == clLime) {
         pnlMainOperation->Caption = "AF Off...(5 sec)";
         WriteSystemLog("A2M: AF OFF...");
         rgA2MAFMode->ItemIndex = 2;
         btnA2MAFClick(this);
         WriteSystemLog("A2M: AF OFF.");
         if(pnlA2MAF->Color == clLime)
            pnlMainOperation->Caption = "AF Off Done.";
         else
            pnlMainOperation->Caption = "AF Off Fail!";
      }

   }
   catch(Exception &e) {
      pnlSystemMessage->Caption = "Motion Error!";
   }
}
//---------------------------------------------------------------------------
// 切換Password
bool boolWaitLog;
void __fastcall TfrnMain::btnPasswordClick(TObject *Sender)
{

   // 清除記錄
   edLogName->Text = "";
   medCurrentPassword->Text = "";

   pnlPassword->Visible = true;
   pcSystem->Enabled = false;
   edLogName->SetFocus();

   // 等待輸入Log On
   boolWaitLog = false;
   while(1) {
      if(boolWaitLog == true) {
         WriteSystemLog("boolWaitLog = true Done.");
         break;
      }
      DelayTime(100);
   }

   WriteSystemLog("End Log1.");
   pcSystem->Enabled = true;
   WriteSystemLog("End Log2.");
   pnlPassword->Visible = false;
   WriteSystemLog("End Log3.");
   Application->ProcessMessages();
   WriteSystemLog("End Log.");
}
//---------------------------------------------------------------------------
// 按下LogOn
void __fastcall TfrnMain::btnLogClick(TObject *Sender)
{
AnsiString name,password;
bool boolset = false;
// 是否存在?
bool boolmatch = false;

   // 比對
   name = edLogName->Text;
   password = medCurrentPassword->Text;

   // License code
   //===========================================================================
   AnsiString licensecode;
   licensecode = GetPasswordCode(password);
   password = licensecode;
   //===========================================================================

   for(int i=0 ; i<UserNums ; i++) {
      if(name == UserList[i].Name && password == UserList[i].Password) {
         // 是否存在?
         boolmatch = true;
         PriorityLevel = PRIORITY_OP;
         if(UserList[i].Level == "PE") {
            PriorityLevel = PRIORITY_PE;
            boolset = true;
         }
         else if(UserList[i].Level == "AD") {
            PriorityLevel = PRIORITY_AD;
            boolset = true;
         }
         else if(UserList[i].Level == "EE") {
            PriorityLevel = PRIORITY_EE;
            boolset = true;
         }
         else {
            boolset = false;
         }

         // 2022 6 20 - chc 不需要呼叫SetLevel
         //SetLevel(boolset);
         SwitchLevel();
         break;
      }
   }

   // 是否存在?
   if(boolmatch == false) {
      boolset = false;
      PriorityLevel = PRIORITY_OP;

      // 2022 6 20 - chc 不需要呼叫SetLevel
      //SetLevel(boolset);
      SwitchLevel();

   }
   if(PriorityLevel == PRIORITY_OP) {
      pcSystem->ActivePage = tsSystemInformation;
   }

   WriteSystemLog("Logged. Set boolWaitLog to true.");
   boolWaitLog = true;

   // 2022 12 5 - chc Main
   SetST(ST_LEVEL,false);

}
//---------------------------------------------------------------------------
// boolset
// 共用Routine
void __fastcall TfrnMain::SetLevel(bool boolset)
{

   // OP只可動X/Y/Z
   tsMotion->TabVisible = boolset;
   tsCCD->TabVisible = boolset;
   tsBXFM->TabVisible = boolset;
   pnlSystem->Enabled = boolset;

}
//---------------------------------------------------------------------------
// 切換Priority: PriorityLevel
//   #define PRIORITY_OP          0
//   #define PRIORITY_PE          1
//   #define PRIORITY_AD          2
//   #define PRIORITY_EE          3
void __fastcall TfrnMain::SwitchLevel()
{

   // 啟動UI
   // 2022 6 20 - chc 個別設定
   //if(PriorityLevel != PRIORITY_OP) {
   //   tsMotion->TabVisible = true;
   //   tsCCD->TabVisible = true;
   //   pnlSystem->Enabled = true;
   //}
   //else {
   //   tsMotion->TabVisible = false;
   //   tsCCD->TabVisible = false;
   //   tsBXFM->TabVisible = false;
   //   pnlSystem->Enabled = false;
   //}

   if(PriorityLevel == PRIORITY_OP) {
      tsSystemInformation->TabVisible = true;
      tsMotion->TabVisible = false;
      tsRecipe->TabVisible = false;
      tsCCD->TabVisible = false;
      tsLED->TabVisible = true;
      tsBXFM->TabVisible = false;
      tsFocus->TabVisible = false;
      tsUser->TabVisible = false;
      tsHirata->TabVisible = false;
      btnPassword->Caption = "Operator";
      btnReCalibration->Visible = false;
      pnlReCalibration->Visible = false;
      //btnCassetteLoad->Enabled = false;
      //btnCassette2Load->Enabled = false;
      //frmRecipe->btnCassetteLoad->Enabled = false;
      //frmRecipe->btnCassette2Load->Enabled = false;
      // DISABLE_COLOR
      pnlMain->Enabled = false;
      pnlMainRecipe->Enabled = false;
      pnlMainInspection->Enabled = false;
      pnlMainDevice->Enabled = true;
      pnlMainMaintenance->Enabled = false;
      pnlMain->Color = DISABLE_COLOR;
      pnlMainRecipe->Color = DISABLE_COLOR;
      pnlMainInspection->Color = DISABLE_COLOR;
      pnlMainDevice->Color = ENABLE_COLOR;
      pnlMainMaintenance->Color = DISABLE_COLOR;
      frmLogo->btnMainHardwareSetup->Enabled = false;
      frmLogo->btnMainRecipeSetup->Enabled = false;
   }
   else if(PriorityLevel == PRIORITY_PE) {
      tsSystemInformation->TabVisible = true;
      tsMotion->TabVisible = true;
      tsRecipe->TabVisible = true;
      if(boolCCD == true)
         tsCCD->TabVisible = true;
      tsLED->TabVisible = true;
      tsBXFM->TabVisible = true;
      tsFocus->TabVisible = true;
      tsUser->TabVisible = false;
      tsHirata->TabVisible = true;
      btnPassword->Caption = "Engineer";
      btnCassetteLoad->Enabled = true;
      btnCassette2Load->Enabled = true;
      frmRecipe->btnCassetteLoad->Enabled = true;
      frmRecipe->btnCassette2Load->Enabled = true;
      pnlMain->Enabled = false;
      pnlMainRecipe->Enabled = true;
      pnlMainInspection->Enabled = true;
      pnlMainDevice->Enabled = true;
      pnlMainMaintenance->Enabled = false;
      pnlMain->Color = DISABLE_COLOR;
      pnlMainRecipe->Color = ENABLE_COLOR;
      pnlMainInspection->Color = ENABLE_COLOR;
      pnlMainDevice->Color = ENABLE_COLOR;
      pnlMainMaintenance->Color = DISABLE_COLOR;
      frmLogo->btnMainHardwareSetup->Enabled = false;
      frmLogo->btnMainRecipeSetup->Enabled = true;
   }
   else if(PriorityLevel == PRIORITY_AD) {
      tsSystemInformation->TabVisible = true;
      tsMotion->TabVisible = true;
      tsRecipe->TabVisible = true;
      if(boolCCD == true)
         tsCCD->TabVisible = true;
      tsLED->TabVisible = true;
      tsBXFM->TabVisible = true;
      tsFocus->TabVisible = true;
      tsUser->TabVisible = true;
      tsHirata->TabVisible = true;
      btnPassword->Caption = "Administrator";
      btnCassetteLoad->Enabled = true;
      btnCassette2Load->Enabled = true;
      frmRecipe->btnCassetteLoad->Enabled = true;
      frmRecipe->btnCassette2Load->Enabled = true;
      pnlMain->Enabled = true;
      pnlMainRecipe->Enabled = true;
      pnlMainInspection->Enabled = true;
      pnlMainDevice->Enabled = true;
      pnlMainMaintenance->Enabled = true;
      pnlMain->Color = ENABLE_COLOR;
      pnlMainRecipe->Color = ENABLE_COLOR;
      pnlMainInspection->Color = ENABLE_COLOR;
      pnlMainDevice->Color = ENABLE_COLOR;
      pnlMainMaintenance->Color = ENABLE_COLOR;
      frmLogo->btnMainHardwareSetup->Enabled = true;
      frmLogo->btnMainRecipeSetup->Enabled = true;
   }
   else {
      tsSystemInformation->TabVisible = true;
      tsMotion->TabVisible = true;
      tsRecipe->TabVisible = true;
      tsCCD->TabVisible = true;
      tsLED->TabVisible = true;
      tsBXFM->TabVisible = true;
      tsFocus->TabVisible = true;
      tsUser->TabVisible = true;
      tsHirata->TabVisible = true;
      btnPassword->Caption = "Manufacturer";
      btnCassetteLoad->Enabled = true;
      btnCassette2Load->Enabled = true;
      frmRecipe->btnCassetteLoad->Enabled = true;
      frmRecipe->btnCassette2Load->Enabled = true;
      pnlMain->Enabled = true;
      pnlMainRecipe->Enabled = true;
      pnlMainInspection->Enabled = true;
      pnlMainDevice->Enabled = true;
      pnlMainMaintenance->Enabled = true;
      pnlMain->Color = ENABLE_COLOR;
      pnlMainRecipe->Color = ENABLE_COLOR;
      pnlMainInspection->Color = ENABLE_COLOR;
      pnlMainDevice->Color = ENABLE_COLOR;
      pnlMainMaintenance->Color = ENABLE_COLOR;
      frmLogo->btnMainHardwareSetup->Enabled = true;
      frmLogo->btnMainRecipeSetup->Enabled = true;
   }

   // 2022 12 7 - chc Start Time
   if(PriorityLevel > PRIORITY_OP) {
      GetTimeTic(&LevelStartTime,&LevelStartTick);
      SysMousePosX = MousePosX;
      SysMousePosY = MousePosY;
   }

   // 2022 12 5 - chc User
   pnlMainUser->Caption = btnPassword->Caption + "." + IntToStr(PriorityLevel+1);
   frmLogo->pnlLogoUser->Caption = pnlMainUser->Caption;

   pcSystem->Refresh();
}
//---------------------------------------------------------------------------
// New/Modify
void __fastcall TfrnMain::btnUserNewClick(TObject *Sender)
{
AnsiString name,password;
bool modified;

   modified = false;
   name = edUserName->Text;
   password = edUserPassword->Text;
   for(int i=0 ; i<UserNums ; i++) {
      // Modify
      if(UserList[i].Name == name) {
         UserList[i].Level = rgLotNoGenerate->Items->Strings[rgLotNoGenerate->ItemIndex];
         UserList[i].Password = password;
         modified = true;
         break;
      }
   }
   // New
   if(modified == false) {
      if(UserNums < MAX_USER) {
         UserList[UserNums].Name = name;

         // 2021 6 24 - chc License code
         AnsiString licensecode;
         licensecode = GetPasswordCode(password);
         password = licensecode;

         UserList[UserNums].Password = password;
         UserList[UserNums].Level = rgLotNoGenerate->Items->Strings[rgLotNoGenerate->ItemIndex];
         UserNums++;
      }
   }
   // Update to .ini & sgUser
   SaveUser();
   LoadUser();
}
//---------------------------------------------------------------------------
// 填上sgUser抬頭
// Data: Name, Password, Level
//#define USER_FIELD_NO                  0               // No
//#define USER_FIELD_NAME                1               // Name
//#define USER_FIELD_PASSWORD            2               // Password
//#define USER_FIELD_LEVEL               3               // Level
void __fastcall TfrnMain::UserTitle()
{

   sgUser->Cells[USER_FIELD_NO][0]            = "No";
   sgUser->Cells[USER_FIELD_NAME][0]          = "Name";
   sgUser->Cells[USER_FIELD_PASSWORD][0]      = "Password";
   sgUser->Cells[USER_FIELD_LEVEL][0]         = "Level";

   // 寬度
   sgUser->ColWidths[USER_FIELD_NO]           = 50;
   sgUser->ColWidths[USER_FIELD_NAME]         = 120;
   sgUser->ColWidths[USER_FIELD_PASSWORD]     = 280;
   sgUser->ColWidths[USER_FIELD_LEVEL]        = 80;

   // 清除sgUser
   sgUser->RowCount = 2;
   sgUser->Cells[USER_FIELD_NO][1]            = "";
   sgUser->Cells[USER_FIELD_NAME][1]          = "";
   sgUser->Cells[USER_FIELD_PASSWORD][1]      = "";
   sgUser->Cells[USER_FIELD_LEVEL][1]         = "";

}
//---------------------------------------------------------------------------
// Password: User.ini
void __fastcall TfrnMain::LoadUser()
{
TIniFile *pSystemFile;
AnsiString str,fname;

   // 清除sgUser
   sgUser->RowCount = 2;
   sgUser->Cells[USER_FIELD_NO][1]            = "";
   sgUser->Cells[USER_FIELD_NAME][1]          = "";
   sgUser->Cells[USER_FIELD_PASSWORD][1]      = "";
   sgUser->Cells[USER_FIELD_LEVEL][1]         = "";

   // ini檔名與目錄: User.ini
   fname = SystemDirectory + "\\User.ini" ;
   if(!FileExists(fname)) {
      sbSystem->Panels->Items[1]->Text = "User.ini Not Existed!";
      return;
   }
   // 載入ini檔
   pSystemFile = new TIniFile(fname);

   UserNums        = pSystemFile->ReadInteger(PASSWORD_SECTION,USER_NUMS        ,0);
   for(int i=0 ; i<UserNums ; i++) {
      UserList[i].Name     = pSystemFile->ReadString(PASSWORD_SECTION,USER+IntToStr(i+1)+NAME            ,"A1");
      UserList[i].Level    = pSystemFile->ReadString(PASSWORD_SECTION,USER+IntToStr(i+1)+LEVEL           ,"OP");
      UserList[i].Password = pSystemFile->ReadString(PASSWORD_SECTION,USER+IntToStr(i+1)+PASSWORD        ,"1234");

      // 加入sgUser
      sgUser->Cells[USER_FIELD_NO][sgUser->RowCount-1]                          = IntToStr(i+1);
      sgUser->Cells[USER_FIELD_NAME][sgUser->RowCount-1]                        = UserList[i].Name;
      sgUser->Cells[USER_FIELD_PASSWORD][sgUser->RowCount-1]                    = UserList[i].Password;
      sgUser->Cells[USER_FIELD_LEVEL][sgUser->RowCount-1]                       = UserList[i].Level;
      sgUser->RowCount++;
      // 清除最後一Row
      sgUser->Cells[USER_FIELD_NO][sgUser->RowCount-1]                        = "";
      sgUser->Cells[USER_FIELD_NAME][sgUser->RowCount-1]                      = "";
      sgUser->Cells[USER_FIELD_PASSWORD][sgUser->RowCount-1]                  = "";
      sgUser->Cells[USER_FIELD_LEVEL][sgUser->RowCount-1]                     = "";
      // 指到最後一筆
      sgUser->Row = sgUser->RowCount-1;
   }
   sgUser->Refresh();

   delete pSystemFile;
}
//---------------------------------------------------------------------------
// Password: User.ini
void __fastcall TfrnMain::SaveUser()
{
TIniFile *pSystemFile;
AnsiString str,fname;

   // ini檔名與目錄: User.ini
   fname = SystemDirectory + "\\User.ini" ;
   // 刪除
   if(FileExists(fname)) {
      DeleteFile(fname.c_str());
   }
   pSystemFile = new TIniFile(fname);

   pSystemFile->WriteInteger(PASSWORD_SECTION,USER_NUMS        ,UserNums);
   for(int i=0 ; i<UserNums ; i++) {
      pSystemFile->WriteString(PASSWORD_SECTION,USER+IntToStr(i+1)+NAME            ,UserList[i].Name);
      pSystemFile->WriteString(PASSWORD_SECTION,USER+IntToStr(i+1)+LEVEL           ,UserList[i].Level);
      pSystemFile->WriteString(PASSWORD_SECTION,USER+IntToStr(i+1)+PASSWORD        ,UserList[i].Password);
   }

   delete pSystemFile;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnUserDeleteClick(TObject *Sender)
{

   if(sgUser->Row > 0 && sgUser->Row <= UserNums) {
      for(int i=sgUser->Row ; i<UserNums ; i++) {
         UserList[i-1].Name = UserList[i].Name;
         UserList[i-1].Password = UserList[i].Password;
         UserList[i-1].Level = UserList[i].Level;
      }
      UserNums--;
      // Update to .ini & sgUser
      SaveUser();
      LoadUser();
   }
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnUserRefreshClick(TObject *Sender)
{

   LoadUser();
}
//---------------------------------------------------------------------------
// License code
AnsiString __fastcall TfrnMain::GetPasswordCode(AnsiString password)
{
AnsiString licensecode;

   WVCodeGenerate *GetLicenseCode = NULL;
   AnsiString LicenseCode;
   GetLicenseCode = new WVCodeGenerate();
   GetLicenseCode->SetCode(password);
   licensecode = GetLicenseCode->GetCode(0);
   return licensecode;
}
//---------------------------------------------------------------------------
// 2021 9 4 - chc Alt-P Print Screen(Current Windows)
void __fastcall TfrnMain::FormKeyDown(TObject *Sender, WORD &Key,
      TShiftState Shift)
{

   if(Key == 80 && Shift.Contains(ssAlt)){                                      // Alt-P
      SaveWindowScreen(frnMain);
      return;
   }
}
//---------------------------------------------------------------------------
void __fastcall TfrnMain::SaveWindowScreen(TForm *Form)
{
Graphics::TBitmap *FormImage;
AnsiString fullpath,filename,path;

   path = SystemDirectory + "\\WayBMP";
   if(!DirectoryExists(path))
      mkdir(path.c_str());

   Printer()->Title = "儲存視窗圖檔";
   FormImage = Form->GetFormImage();
   Application->ProcessMessages();

   filename = filename.sprintf("WayBMP%04d.bmp",SaveBMPSerialNo);
   fullpath = path + "\\" + filename;
   sbSystem->Panels->Items[1]->Text = filename + "存檔中...";
   FormImage->SaveToFile(fullpath.c_str());
   sbSystem->Panels->Items[1]->Text = filename + "存檔結束.";
   SaveBMPSerialNo++;

   delete FormImage;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnStopMotionClick(TObject *Sender)
{

   StopAxis(X_AXIS);
   Sleep(100);
   StopAxis(Y_AXIS);
   Sleep(100);
   StopAxis(Z_AXIS);
   Sleep(100);
   StopAxis(T_AXIS);
   Sleep(100);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnToOriginalPositionClick(TObject *Sender)
{

   // 禁操作
   pcSystem->Enabled = false;
   pnlStartMessage->Caption = "Moving to Origin...";
   pnlStartMessage->Visible = true;
   pnlStartMessage->Refresh();
   // 到入料點/原點用最高速
   boolUseMaxSpeed = true;

   MotionStatus(false);
   ToOriginalPosition();
   MotionStatus(true);

   // 禁操作
   pcSystem->Enabled = true;
   pnlStartMessage->Visible = false;
   // 到入料點/原點用最高速
   boolUseMaxSpeed = false;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnPos1SetClick(TObject *Sender)
{

   SetUserPosition(1);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnPos2SetClick(TObject *Sender)
{

   SetUserPosition(2);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnPos3SetClick(TObject *Sender)
{

   SetUserPosition(3);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnPos4SetClick(TObject *Sender)
{

   SetUserPosition(4);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnPos5SetClick(TObject *Sender)
{

   SetUserPosition(5);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnPos6SetClick(TObject *Sender)
{

   SetUserPosition(6);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnPos7SetClick(TObject *Sender)
{

   SetUserPosition(7);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnPos8SetClick(TObject *Sender)
{

   SetUserPosition(8);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnPos9SetClick(TObject *Sender)
{

   SetUserPosition(9);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnPos10SetClick(TObject *Sender)
{

   SetUserPosition(10);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnPos1GoClick(TObject *Sender)
{

   ToUserPositionFun(1);
}
//---------------------------------------------------------------------------
void __fastcall TfrnMain::ToUserPositionFun(int no)
{

   pcOperation->Enabled = false;
   MotionStatus(false);

   pnlStartMessage->Caption = "第" + IntToStr(no) + "點移動中...";
   pnlStartMessage->Visible = true;
   pnlStartMessage->Refresh();
   ToUserPosition(no);
   pnlStartMessage->Visible = false;

   MotionStatus(true);
   pcOperation->Enabled = true;

   // 2022 8 12 - chc 強制為clLime
   pnlToUserPosition->Color = clLime;
   
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnPos2GoClick(TObject *Sender)
{

   ToUserPositionFun(2);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnPos3GoClick(TObject *Sender)
{

   ToUserPositionFun(3);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnPos4GoClick(TObject *Sender)
{

   ToUserPositionFun(4);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnPos5GoClick(TObject *Sender)
{

   ToUserPositionFun(5);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnPos6GoClick(TObject *Sender)
{

   ToUserPositionFun(6);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnPos7GoClick(TObject *Sender)
{

   ToUserPositionFun(7);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnPos8GoClick(TObject *Sender)
{

   ToUserPositionFun(8);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnPos9GoClick(TObject *Sender)
{

   ToUserPositionFun(9);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnPos10GoClick(TObject *Sender)
{

   ToUserPositionFun(10);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnToOriginalClick(TObject *Sender)
{

   btnToOriginalPositionClick(this);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnToInputClick(TObject *Sender)
{

   btnToLoadPositionClick(this);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnToLoadPositionClick(TObject *Sender)
{

   // 禁操作
   pcSystem->Enabled = false;
   pnlStartMessage->Caption = "Moving to Load...";
   pnlStartMessage->Visible = true;
   pnlStartMessage->Refresh();
   // 到入料點/原點用最高速
   boolUseMaxSpeed = true;

   MotionStatus(false);
   ToLoadPosition();
   MotionStatus(true);

   // 禁操作
   pcSystem->Enabled = true;
   pnlStartMessage->Visible = false;
   // 到入料點/原點用最高速
   boolUseMaxSpeed = false;

}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnLeftUpClick(TObject *Sender)
{

   if(rgRangeMode->ItemIndex == 0)
      SetSaveRange(1);
   else
      SetSaveRange(3);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnRightDownClick(TObject *Sender)
{

   if(rgRangeMode->ItemIndex == 0)
      SetSaveRange(2);
   else
      SetSaveRange(4);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnRangeSaveClick(TObject *Sender)
{
TIniFile *pSystemFile;
AnsiString fname;

   fname = SystemDirectory + "\\Stage.ini";
   pSystemFile = new TIniFile(fname);

   // Motion CCD
   Tx1 = pnlLeftUpMX->Caption.ToInt();
   Ty1 = pnlLeftUpMY->Caption.ToInt();
   Tx2 = pnlRightDownMX->Caption.ToInt();
   Ty2 = pnlRightDownMY->Caption.ToInt();

   // DSX CCD
   Vx1 = pnlLeftUpBX->Caption.ToInt();
   Vy1 = pnlLeftUpBY->Caption.ToInt();
   Vx2 = pnlRightDownBX->Caption.ToInt();
   Vy2 = pnlRightDownBY->Caption.ToInt();

   pSystemFile->WriteInteger("Range Motion" ,"X1"                               ,Tx1);
   pSystemFile->WriteInteger("Range Motion" ,"Y1"                               ,Ty1);
   pSystemFile->WriteInteger("Range Motion" ,"X2"                               ,Tx2);
   pSystemFile->WriteInteger("Range Motion" ,"Y2"                               ,Ty2);

   pSystemFile->WriteInteger("Range DSX" ,"X1"                                  ,Vx1);
   pSystemFile->WriteInteger("Range DSX" ,"Y1"                                  ,Vy1);
   pSystemFile->WriteInteger("Range DSX" ,"X2"                                  ,Vx2);
   pSystemFile->WriteInteger("Range DSX" ,"Y2"                                  ,Vy2);

   delete pSystemFile;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::rgJoystickSpeedClick(TObject *Sender)
{

   JogSpeed = rgSpeed->ItemIndex;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::rgJoystickDefaultSpeedChange(TObject *Sender,
      int ButtonIndex)
{
TIniFile *pSystemFile;
AnsiString str;

   pSystemFile = new TIniFile(SystemINIFilename);

   JoystickDefaultSpeed = rgJoystickDefaultSpeed->ItemIndex;
   pSystemFile->WriteInteger("System Parameter" ,JOYSTICK_DEFAULT_SPEED         ,JoystickDefaultSpeed);

   delete pSystemFile;
}
//---------------------------------------------------------------------------
// 2022 6 16 - chc Joystick參數儲存
void __fastcall TfrnMain::LoadJoystickDefaultSpeed()
{
TIniFile *pSystemFile;
AnsiString str;

   pSystemFile = new TIniFile(SystemINIFilename);

   JoystickDefaultSpeed = pSystemFile->ReadInteger("System Parameter" ,JOYSTICK_DEFAULT_SPEED    ,0);
   rgJoystickDefaultSpeed->ItemIndex = JoystickDefaultSpeed;

   delete pSystemFile;
}
//---------------------------------------------------------------------------
// 2022 6 16 - chc Joystick參數儲存
void __fastcall TfrnMain::LoadJoystick()
{
TIniFile *pSystemFile;
AnsiString str;

   pSystemFile = new TIniFile(SystemINIFilename);

   JoystickStart = pSystemFile->ReadInteger("System Parameter" ,JOYSTICK_START  ,900);
   JoystickStop = pSystemFile->ReadInteger("System Parameter" ,JOYSTICK_STOP    ,100);
   edJoystickStart->Text = IntToStr(JoystickStart);
   edJoystickStop->Text = IntToStr(JoystickStop);

   // 2022 8 15 - chc 速度參數: edJoystickLowSpeed
   //
   double speed;
   speed = pSystemFile->ReadFloat("System Parameter" ,JOYSTICK_LOW_SPEED             ,1.0);
   str.sprintf("%.2f",speed);
   edJoystickLowSpeed->Text = str;
   speed = pSystemFile->ReadFloat("System Parameter" ,JOYSTICK_HIGH_SPEED            ,50.0);
   str.sprintf("%.2f",speed);
   edJoystickHighSpeed->Text = str;
   //
   
   // AI
   AISpeedStart = pSystemFile->ReadInteger("System Parameter" ,AISPEED_START    ,150);
   AISpeedChange = pSystemFile->ReadInteger("System Parameter" ,AISPEED_CHANGE  ,50);
   edAISpeedStart->Text = IntToStr(AISpeedStart);
   edAISpeedChange->Text = IntToStr(AISpeedChange);
   boolAISpeed = pSystemFile->ReadBool("System Parameter" ,BOOL_AISPEED         ,false);
   cbAISpeed->Checked = boolAISpeed;

   delete pSystemFile;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::pnlJoystick7Click(TObject *Sender)
{

   JoystickEnabledKey = 7;
   SetJoystickEnabledKey();
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::pnlJoystick8Click(TObject *Sender)
{

   JoystickEnabledKey = 8;
   SetJoystickEnabledKey();
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::pnlJoystick9Click(TObject *Sender)
{

   JoystickEnabledKey = 9;
   SetJoystickEnabledKey();
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::pnlJoystick10Click(TObject *Sender)
{

   JoystickEnabledKey = 10;
   SetJoystickEnabledKey();
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::rgJoystickEnabledChange(TObject *Sender,
      int ButtonIndex)
{
TIniFile *pSystemFile;

   JoystickEnabledMode = rgJoystickEnabled->ItemIndex;
   // ini檔名與目錄: LaserMotion.ini
   pSystemFile = new TIniFile(SystemINIFilename);
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,"Joystick Enable Mode"   ,rgJoystickEnabled->ItemIndex);
   delete pSystemFile;

   SetJoystickEnabledName();
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnJoystickSaveClick(TObject *Sender)
{
TIniFile *pSystemFile;
AnsiString str;

   pSystemFile = new TIniFile(SystemINIFilename);

   JoystickStart = edJoystickStart->Text.ToInt();
   JoystickStop = edJoystickStop->Text.ToInt();
   pSystemFile->WriteInteger("System Parameter" ,JOYSTICK_START                 ,JoystickStart);
   pSystemFile->WriteInteger("System Parameter" ,JOYSTICK_STOP                  ,JoystickStop);

   // 2022 8 15 - chc 速度參數: edJoystickLowSpeed
   //
   double speed;
   speed = edJoystickLowSpeed->Text.ToDouble();
   pSystemFile->WriteFloat("System Parameter" ,JOYSTICK_LOW_SPEED             ,speed);
   speed = edJoystickHighSpeed->Text.ToDouble();
   pSystemFile->WriteFloat("System Parameter" ,JOYSTICK_HIGH_SPEED            ,speed);
   //
   
   delete pSystemFile;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnJoystickSaveAIClick(TObject *Sender)
{
TIniFile *pSystemFile;
AnsiString str;

   pSystemFile = new TIniFile(SystemINIFilename);

   AISpeedStart = edAISpeedStart->Text.ToInt();
   AISpeedChange = edAISpeedChange->Text.ToInt();
   pSystemFile->WriteInteger("System Parameter" ,AISPEED_START                  ,AISpeedStart);
   pSystemFile->WriteInteger("System Parameter" ,AISPEED_CHANGE                 ,AISpeedChange);
   boolAISpeed = cbAISpeed->Checked;
   pSystemFile->WriteBool("System Parameter" ,BOOL_AISPEED                      ,boolAISpeed);

   delete pSystemFile;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::imTableMouseMove(TObject *Sender,
      TShiftState Shift, int X, int Y)
{
int x1,y1,x2,y2,wx1,wy1,wx2,wy2,wdx,wdy,dx,dy,x,y;

   wx1 = 0;
   wy1 = 0;
   wx2 = imTable->Width - 1;
   wy2 = imTable->Height - 1;
   wdx = wx2 - wx1;
   wdy = wy2 - wy1;

   // 量測CCD
   if(rgTableCCDMode->ItemIndex == 1) {
      x1 = Vx1;
      y1 = Vy1;
      x2 = Vx2;
      y2 = Vy2;
   }
   // 對位CCD
   else {
      x1 = Tx1;
      y1 = Ty1;
      x2 = Tx2;
      y2 = Ty2;
   }
   dx = x2 - x1;
   dy = y2 - y1;
   x = x1 + (X - wx1) * dx / wdx;
   y = y1 + (Y - wy1) * dy / wdy;
   pnlTableX->Caption = IntToStr(x);
   pnlTableY->Caption = IntToStr(y);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::imTableMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{
int x1,y1,x2,y2,wx1,wy1,wx2,wy2,wdx,wdy,dx,dy,x,y;
AnsiString msg;

   wx1 = 0;
   wy1 = 0;
   wx2 = imTable->Width - 1;
   wy2 = imTable->Height - 1;
   wdx = wx2 - wx1;
   wdy = wy2 - wy1;

   // Review CCD
   if(rgTableCCDMode->ItemIndex == 1) {
      x1 = Vx1;
      y1 = Vy1;
      x2 = Vx2;
      y2 = Vy2;
   }
   else {

      x1 = Tx1;
      y1 = Ty1;
      x2 = Tx2;
      y2 = Ty2;
   }
   dx = x2 - x1;
   dy = y2 - y1;
   x = x1 + (X - wx1) * dx / wdx;
   y = y1 + (Y - wy1) * dy / wdy;

   pnlTableX->Caption = IntToStr(x);
   pnlTableY->Caption = IntToStr(y);
   // Move
   msg.sprintf("[Absolute]XY Move: %d,%d-%d,%d",X,Y,x,y);
   WriteSystemLog(msg);
   MoveToXY(x,y);
}
//---------------------------------------------------------------------------


void __fastcall TfrnMain::btn45PositionClick(TObject *Sender)
{

   Set45Position();
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btn0PositionClick(TObject *Sender)
{

   Set0Position();
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnLoadPositionClick(TObject *Sender)
{

   SetLoadPosition();
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnOriginalPositionClick(TObject *Sender)
{

   SetOriginalPosition();
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnCCDPositionClick(TObject *Sender)
{

   SetCCDPosition();
}
//---------------------------------------------------------------------------
// 2022 6 16 - chc Joystick Active
void __fastcall TfrnMain::SetJoystickActive(bool flag)
{

   if(flag == true) {
      pnlJoystickActive->Color = clLime;
      pnlSpeed->Color = clTeal;
      // @@ Test
      WriteSystemLog("Joystcik: Enable");
   }
   else {
      pnlJoystickActive->Color = clSilver;
      pnlSpeed->Color = clGray;
      // @@ Test
      WriteSystemLog("Joystcik: Disable");
   }

   // 可設定初始速度
   if(rgJoystickDefaultSpeed->ItemIndex == 1) {
      rgJoystickSpeed->ItemIndex = 1;
      pnlSpeed->Caption = "高速";
   }
   else {

      rgJoystickSpeed->ItemIndex = 0;
      pnlSpeed->Caption = "低速";
   }
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnTo45PositionClick(TObject *Sender)
{

   // 禁操作
   pcSystem->Enabled = false;
   pnlStartMessage->Caption = "Moving to 45...";
   pnlStartMessage->Visible = true;
   pnlStartMessage->Refresh();
   // 到入料點/原點用最高速
   boolUseMaxSpeed = true;

   MotionStatus(false);
   To45Position(1);
   MotionStatus(true);

   // 禁操作
   pcSystem->Enabled = true;
   pnlStartMessage->Visible = false;
   // 到入料點/原點用最高速
   boolUseMaxSpeed = false;
   
}
//---------------------------------------------------------------------------


void __fastcall TfrnMain::btnToCCDPositionClick(TObject *Sender)
{

   // 禁操作
   pcSystem->Enabled = false;
   pnlStartMessage->Caption = "Moving to CCD...";
   pnlStartMessage->Visible = true;
   pnlStartMessage->Refresh();
   // 到入料點/原點用最高速
   boolUseMaxSpeed = true;

   MotionStatus(false);
   ToCCDPosition();
   MotionStatus(true);

   // 禁操作
   pcSystem->Enabled = true;
   pnlStartMessage->Visible = false;
   // 到入料點/原點用最高速
   boolUseMaxSpeed = false;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnTo0PositionClick(TObject *Sender)
{

   // 禁操作
   pcSystem->Enabled = false;
   pnlStartMessage->Caption = "Moving to 0...";
   pnlStartMessage->Visible = true;
   pnlStartMessage->Refresh();

   MotionStatus(false);
   To0Position(1);
   MotionStatus(true);

   // 禁操作
   pcSystem->Enabled = true;
   pnlStartMessage->Visible = false;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnSpeedUpdateClick(TObject *Sender)
{
AnsiString msg;
TIniFile *pSystemFile;

   // 速度切換(低/中/高): 低速(0.5%), 中速(20%), 高速(100%)
   msg.sprintf("低速-%s\%",edSpeedGeneralLow->Text.c_str());
   rgSpeed->Items->Strings[0] = msg;
   msg.sprintf("中速-%s\%",edSpeedGeneralMiddle->Text.c_str());
   rgSpeed->Items->Strings[1] = msg;
   msg.sprintf("高速-%s\%",edSpeedGeneralHigh->Text.c_str());
   rgSpeed->Items->Strings[2] = msg;
   // Z軸速度
   msg.sprintf("低速-%s\%",edSpeedZLow->Text.c_str());
   rgBrukerZSpeed->Items->Strings[0] = msg;
   msg.sprintf("中速-%s\%",edSpeedZMiddle->Text.c_str());
   rgBrukerZSpeed->Items->Strings[1] = msg;
   msg.sprintf("高速-%s\%",edSpeedZHigh->Text.c_str());
   rgBrukerZSpeed->Items->Strings[2] = msg;

   // Write to .ini
   pnlSystemMessage->Caption = "更新速度參數...";
   // ini檔名與目錄
   pSystemFile = new TIniFile(SpeedINIFilename);

   // General
   pSystemFile->WriteString(SPEED_INFORMATION_SECTION,"General Low"            ,edSpeedGeneralLow->Text);
   pSystemFile->WriteString(SPEED_INFORMATION_SECTION,"General Middle"         ,edSpeedGeneralMiddle->Text);
   pSystemFile->WriteString(SPEED_INFORMATION_SECTION,"General High"           ,edSpeedGeneralHigh->Text);
   // Turbo
   pSystemFile->WriteString(SPEED_INFORMATION_SECTION,"Turbo Low"              ,edSpeedTurboLow->Text);
   pSystemFile->WriteString(SPEED_INFORMATION_SECTION,"Turbo Middle"           ,edSpeedTurboMiddle->Text);
   pSystemFile->WriteString(SPEED_INFORMATION_SECTION,"Turbo High"             ,edSpeedTurboHigh->Text);
   // Z
   pSystemFile->WriteString(SPEED_INFORMATION_SECTION,"Z Low"                  ,edSpeedZLow->Text);
   pSystemFile->WriteString(SPEED_INFORMATION_SECTION,"Z Middle"               ,edSpeedZMiddle->Text);
   pSystemFile->WriteString(SPEED_INFORMATION_SECTION,"Z High"                 ,edSpeedZHigh->Text);

   delete pSystemFile;
   pnlSystemMessage->Caption = "更新速度參數完成.";
}
//---------------------------------------------------------------------------
// 2022 6 16 - chc Load Speed Parameter
void __fastcall TfrnMain::LoadSpeedParameter()
{
AnsiString msg;
TIniFile *pSystemFile;
AnsiString sgenerallow,sgeneralmiddle,sgeneralhigh,sturbolow,sturbomiddle,sturbohigh,szlow,szmiddle,szhigh;

   // Read .ini
   pnlSystemMessage->Caption = "載入速度參數...";
   // ini檔名與目錄
   pSystemFile = new TIniFile(SpeedINIFilename);

   // General: 0.01,0.1,1
   sgenerallow = pSystemFile->ReadString(SPEED_INFORMATION_SECTION,"General Low"            ,"10");
   sgeneralmiddle = pSystemFile->ReadString(SPEED_INFORMATION_SECTION,"General Middle"      ,"50");
   sgeneralhigh = pSystemFile->ReadString(SPEED_INFORMATION_SECTION,"General High"          ,"100");
   // Turbo: 0.5,20,100
   sturbolow = pSystemFile->ReadString(SPEED_INFORMATION_SECTION,"Turbo Low"                ,"10");
   sturbomiddle = pSystemFile->ReadString(SPEED_INFORMATION_SECTION,"Turbo Middle"          ,"30");
   sturbohigh = pSystemFile->ReadString(SPEED_INFORMATION_SECTION,"Turbo High"              ,"60");
   // Z: 0.3,15,100
   szlow = pSystemFile->ReadString(SPEED_INFORMATION_SECTION,"Z Low"                        ,"10");
   szmiddle = pSystemFile->ReadString(SPEED_INFORMATION_SECTION,"Z Middle"                  ,"20");
   szhigh = pSystemFile->ReadString(SPEED_INFORMATION_SECTION,"Z High"                      ,"50");

   delete pSystemFile;

   // 填入元件
   // General
   edSpeedGeneralLow->Text = sgenerallow;
   edSpeedGeneralMiddle->Text = sgeneralmiddle;
   edSpeedGeneralHigh->Text = sgeneralhigh;
   // Turbo
   edSpeedTurboLow->Text = sturbolow;
   edSpeedTurboMiddle->Text = sturbomiddle;
   edSpeedTurboHigh->Text = sturbohigh;
   // Z
   edSpeedZLow->Text = szlow;
   edSpeedZMiddle->Text = szmiddle;
   edSpeedZHigh->Text = szhigh;

   // 速度切換(低/中/高): 低速(0.5%), 中速(20%), 高速(100%)
   msg.sprintf("低速-%s\%",edSpeedGeneralLow->Text.c_str());
   rgSpeed->Items->Strings[0] = msg;
   msg.sprintf("中速-%s\%",edSpeedGeneralMiddle->Text.c_str());
   rgSpeed->Items->Strings[1] = msg;
   msg.sprintf("高速-%s\%",edSpeedGeneralHigh->Text.c_str());
   rgSpeed->Items->Strings[2] = msg;
   // Z軸速度
   msg.sprintf("低速-%s\%",edSpeedZLow->Text.c_str());
   rgBrukerZSpeed->Items->Strings[0] = msg;
   msg.sprintf("中速-%s\%",edSpeedZMiddle->Text.c_str());
   rgBrukerZSpeed->Items->Strings[1] = msg;
   msg.sprintf("高速-%s\%",edSpeedZHigh->Text.c_str());
   rgBrukerZSpeed->Items->Strings[2] = msg;

   pnlSystemMessage->Caption = "載入速度參數完成.";
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnAutoFocusClick(TObject *Sender)
{

   btnAutoFocus->Enabled = false;
   AutoFocus();
   btnAutoFocus->Enabled = true;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::tmJoystickTimer(TObject *Sender)
{

   tmJoystick->Enabled = false;

   UpdateJoystick();

   if(tmJoystick->Interval == 500)
      tmTrigger->Enabled = true;
   tmJoystick->Interval = 50;
   tmJoystick->Enabled = true;
}
//---------------------------------------------------------------------------
// 2020 2 12 - chc Joystick Active
int XMode;
void __fastcall TfrnMain::DoMoveX()
{

   XMode = 1;
   tmX->Enabled = true;
}
//---------------------------------------------------------------------------
void __fastcall TfrnMain::DoBackwardX()
{

   XMode = 2;
   tmX->Enabled = true;
}
//---------------------------------------------------------------------------
// 2020 2 12 - chc Joystick Active
int YMode;
void __fastcall TfrnMain::DoMoveY()
{

   YMode = 1;
   tmY->Enabled = true;
}
//---------------------------------------------------------------------------
void __fastcall TfrnMain::DoBackwardY()
{

   YMode = 2;
   tmY->Enabled = true;
}
//---------------------------------------------------------------------------
// 2020 2 12 - chc Joystick Active
int ZMode;
void __fastcall TfrnMain::DoMoveZ()
{

   ZMode = 1;
   tmZ->Enabled = true;
}
//---------------------------------------------------------------------------
void __fastcall TfrnMain::DoBackwardZ()
{

   ZMode = 2;
   tmZ->Enabled = true;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::tmTriggerTimer(TObject *Sender)
{

   tmTrigger->Enabled = false;
   Application->ProcessMessages();
   PostMessage(frnMain->Handle, WM_LBUTTONDOWN, 0, 0);

   pnlHome2->Visible = true;
   pnlStartMessage->Caption = "請執行原點復歸...";
   pnlStartMessage->Refresh();
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::tmXTimer(TObject *Sender)
{
bool bcontinue;

   // 2022 6 19 - chc 強制為連動
   bcontinue = cbContinueMove1->Checked;
   cbContinueMove->Checked = true;

   tmX->Enabled = false;
   if(XMode == 1) {
      WriteSystemLog(">>Joystick: DoMoveX()...");
      // 指定軸
      combAxis->ItemIndex = X_AXIS;
      // Table方向
      if(cbTableDirection->Checked == true) {
         // 指定Axis
         CurrentAxisNo = combAxis->ItemIndex;
         if(cbContinueMove->Checked == false)
            return;
         // 記錄在move中, 不可以同時Continue move
         if(boolInAxisMove == false) {
            boolJogMove = true;
            WriteSystemLog(">>Joystick: DoMoveX(), 呼叫AxisMove(0,0)前");
            AxisMove(0,0);
            WriteSystemLog(">>Joystick: DoMoveX(), 呼叫AxisMove(0,0)後");
         }
      }
      else {
         // 指定Axis
         CurrentAxisNo = combAxis->ItemIndex;
         if(cbContinueMove->Checked == false)
            return;
         // 記錄在move中, 不可以同時Continue move
         if(boolInAxisMove == false) {
            boolJogMove = true;
            WriteSystemLog(">>Joystick: DoMoveX(), 呼叫AxisMove(1,0)前");
            AxisMove(1,0);
            WriteSystemLog(">>Joystick: DoMoveX(), 呼叫AxisMove(1,0)後");
         }
      }
      WriteSystemLog(">>Joystick: DoMoveX().");
   }
   else {
      WriteSystemLog(">>Joystick: DoBackwardX()...");
      // 指定軸
      combAxis->ItemIndex = X_AXIS;
      if(cbTableDirection->Checked == true) {
         // 指定Axis
         CurrentAxisNo = combAxis->ItemIndex;
         if(cbContinueMove->Checked == false)
            return;
         // 記錄在move中, 不可以同時Continue move
         if(boolInAxisMove == false) {
            WriteSystemLog(">>Joystick: DoBackwardX(), 呼叫AxisMove(1,0)前");
            boolJogMove = true;
            AxisMove(1,0);
            WriteSystemLog(">>Joystick: DoBackwardX(), 呼叫AxisMove(1,0)後");
         }
      }
      else {
         // 指定Axis
         CurrentAxisNo = combAxis->ItemIndex;
         if(cbContinueMove->Checked == false)
            return;
         // 記錄在move中, 不可以同時Continue move
         if(boolInAxisMove == false) {
            boolJogMove = true;
            WriteSystemLog(">>Joystick: DoBackwardX(), 呼叫AxisMove(0,0)前");
            AxisMove(0,0);
            WriteSystemLog(">>Joystick: DoBackwardX(), 呼叫AxisMove(0,0)後");
         }
      }
      WriteSystemLog(">>Joystick: DoBackwardX().");
   }

   // 2022 6 19 - chc 強制為連動
   cbContinueMove->Checked = bcontinue;

}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::tmYTimer(TObject *Sender)
{
bool bcontinue;

   // 2022 6 19 - chc 強制為連動
   bcontinue = cbContinueMove1->Checked;
   cbContinueMove->Checked = true;

   tmY->Enabled = false;
   if(YMode == 1) {
      combAxis->ItemIndex = Y_AXIS;
      // 指定Axis
      CurrentAxisNo = combAxis->ItemIndex;
      if(cbContinueMove->Checked == false)
         return;
      // 記錄在move中, 不可以同時Continue move
      if(boolInAxisMove == false) {
         boolJogMove = true;
         WriteSystemLog(">>Joystick: DoMoveY(), 呼叫AxisMove(0,0)前");
         AxisMove(0,0);
         WriteSystemLog(">>Joystick: DoMoveY(), 呼叫AxisMove(0,0)後");
      }
   }
   else {
      combAxis->ItemIndex = Y_AXIS;
      // 指定Axis
      CurrentAxisNo = combAxis->ItemIndex;
      if(cbContinueMove->Checked == false)
         return;
      // 記錄在move中, 不可以同時Continue move
      if(boolInAxisMove == false) {
         boolJogMove = true;
         WriteSystemLog(">>Joystick: DoBackwardY(), 呼叫AxisMove(1,0)前");
         AxisMove(1,0);
         WriteSystemLog(">>Joystick: DoBackwardY(), 呼叫AxisMove(1,0)後");
      }
   }

   // 2022 6 19 - chc 強制為連動
   cbContinueMove->Checked = bcontinue;

}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::tmZTimer(TObject *Sender)
{
bool bcontinue;

   // 2022 6 19 - chc 強制為連動
   bcontinue = cbContinueMove1->Checked;
   cbContinueMove->Checked = true;

   tmZ->Enabled = false;
   if(ZMode == 1) {
      combAxis->ItemIndex = Z_AXIS;
      // 指定Axis
      CurrentAxisNo = combAxis->ItemIndex;
      if(cbContinueMove->Checked == false)
         return;
      // 記錄在move中, 不可以同時Continue move
      if(boolInAxisMove == false) {
         boolJogMove = true;
         AxisMove(0,0);
      }
   }
   else {
      combAxis->ItemIndex = Z_AXIS;
      // 指定Axis
      CurrentAxisNo = combAxis->ItemIndex;
      if(cbContinueMove->Checked == false)
         return;
      // 記錄在move中, 不可以同時Continue move
      if(boolInAxisMove == false) {
         boolJogMove = true;
         AxisMove(1,0);
      }
   }

   // 2022 6 19 - chc 強制為連動
   cbContinueMove->Checked = bcontinue;

}
//---------------------------------------------------------------------------
int DoubleClickX,DoubleClickY;

void __fastcall TfrnMain::imCCDDblClick(TObject *Sender)
{
int level;
double fdy,ccdprecision,fdx;
int axisno,position;
I32 cmd;
AnsiString msg;
int cx,cy,X,Y;
double ratiox,ratioy;

   // 要關閉, 避免重複
   imCCD->Enabled = false;

   // 全影像比例
   ratiox = 1.0;
   ratioy = 1.0;
   if(cbCCDFullImage->Checked == true) {
      ratiox = CCDInfoAry[0].Width / imCCD->Width;
      ratioy = CCDInfoAry[0].Height / imCCD->Height;
   }

   // X/Y position(set by MouseDown Event)
   X = DoubleClickX;
   Y = DoubleClickY;

   cx = imCCD->Width / 2;
   cy = imCCD->Height / 2;

   cx = shVertical->Left - imCCD->Left;
   cy = shHorizontal->Top - imCCD->Top;

   pnlSystemMessage->Caption = "Bouble Click: XYMoving...";
   WriteSystemLog(pnlSystemMessage->Caption);
   // Y軸
   pnlYMove->Color = clSilver;
   level = shHorizontal->Top;                                                   // 488
   ccdprecision = GetLensPrecision();
   fdy = (Y - (level - imCCD->Top)) * ccdprecision;

   // 全影像比例
   fdy *= ratioy;

   msg.sprintf("Y,level,top,fy= %d,%d,%d,%.4f,%.4f",Y,level,imCCD->Top,fdy,ccdprecision);
   WriteSystemLog(msg);

   if(cbCCDYDirection->Checked == true)
      fdy = 0 - fdy;
   msg.sprintf("%.3f",fdy);
   pnlYAltOffset->Caption = msg;
   // Y - absolute
   axisno = Y_AXIS;

   GetPosition(axisno, &cmd);
   position = cmd + (fdy / Y_RESOLUTION);
   if(MoveToY(position) == false) {
      pnlSystemMessage->Caption = "MouseDoubleClick: YMove Fail!";
      WriteSystemLog(pnlSystemMessage->Caption);
      pnlYMove->Color = clRed;
      // Beep聲
      Beep(500);
      pnlAlarmMessage->Caption = " Y-Axis Move Error!";
      frnMain->AddMainLog("Y-Axis Move Error!", YAXIS_MOVE_ERR,true);
   }
   else {
      pnlYMove->Color = clLime;
      pnlSystemMessage->Caption = "MouseDoubleClick: YMove Success";
   }

   // X軸
   pnlXMove->Color = clSilver;
   level = shVertical->Left;                                                    // 603
   fdx = (X - (level - imCCD->Left)) * ccdprecision;

   // 全影像比例
   fdx *= ratiox;

   msg.sprintf("X,level,left,fx= %d,%d,%d,%.4f,%.4f",X,level,imCCD->Left,fdx,ccdprecision);
   WriteSystemLog(msg);
   if(cbCCDXDirection->Checked == true)
      fdx = 0 - fdx;
   msg.sprintf("%.3f",fdx);
   pnlXAltOffset->Caption = msg;
   // X - absolute
   axisno = X_AXIS;

   GetPosition(axisno, &cmd);
   position = cmd + (fdx / X_RESOLUTION);
   if(MoveToX(position) == false) {
      pnlSystemMessage->Caption = "MouseDoubleClick: XMove Fail!";
      WriteSystemLog(pnlSystemMessage->Caption);
      pnlXMove->Color = clRed;
      // Beep聲
      Beep(500);
      pnlAlarmMessage->Caption = " X-Axis Move Error!";
      frnMain->AddMainLog("X-Axis Move Error!", XAXIS_MOVE_ERR,true);
   }
   else {
      pnlXMove->Color = clLime;
      pnlSystemMessage->Caption = "MouseDoubleClick: XMove Success";
   }

   // 強制切到X軸
   axisno = X_AXIS;
   combAxis->ItemIndex = axisno;

   // 要關閉, 避免重複
   imCCD->Enabled = true;

}
//---------------------------------------------------------------------------
// 2022 6 18 -  chc LeftUp移動
bool boolCenterLeftUpMove = false;
int CenterLeftUpX,CenterLeftUpY;
void __fastcall TfrnMain::shLeftUpMouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   boolCenterLeftUpMove = true;
   CenterLeftUpX = X;
   CenterLeftUpY = Y;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::shLeftUpMouseMove(TObject *Sender,
      TShiftState Shift, int X, int Y)
{
int dx,dy,x1,y1,x2,y2,w,h,width,height,minx,miny;

   // 移動中
   minx = 20;
   miny = 20;
   if(boolCenterLeftUpMove == true) {
      // 校正中心框位置
      width = imCCD->Width;
      height = imCCD->Height;
      w = shCenter->Width;
      h = shCenter->Height;
      x1 = shCenter->Left;
      y1 = shCenter->Top;
      x2 = x1 + shCenter->Width - 1;
      y2 = y1 + shCenter->Height - 1;
      // 變化
      dx = X - CenterLeftUpX;
      dy = Y - CenterLeftUpY;
      if((x2 - (x1+dx)) >= minx) {
         x1 += dx;
      }
      if((y2 - (y1+dy)) >= miny) {
         y1 += dy;
      }
      if(x1 < 0)
         x1 = 0;
      if(y1 < 0)
         y1 = 0;
      shCenter->Left = x1;
      shCenter->Top = y1;
      shCenter->Width = x2 - x1 + 1;
      shCenter->Height = y2 - y1 + 1;
      UpdateCenterDotPosition();
   }
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::shLeftUpMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   boolCenterLeftUpMove = false;
}
//---------------------------------------------------------------------------
// 2022 6 18 - chc Left移動
bool boolCenterLeftMove = false;
int CenterLeftX,CenterLeftY;
void __fastcall TfrnMain::shLeftMouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   boolCenterLeftMove = true;
   CenterLeftX = X;
   CenterLeftY = Y;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::shLeftMouseMove(TObject *Sender,
      TShiftState Shift, int X, int Y)
{
int dx,dy,x1,y1,x2,y2,w,h,width,height,minx,miny;

   // 移動中
   minx = 20;
   miny = 20;
   if(boolCenterLeftMove == true) {
      // 校正中心框位置
      width = imCCD->Width;
      height = imCCD->Height;
      w = shCenter->Width;
      h = shCenter->Height;
      x1 = shCenter->Left;
      y1 = shCenter->Top;
      x2 = x1 + shCenter->Width - 1;
      y2 = y1 + shCenter->Height - 1;
      // 變化
      dx = X - CenterLeftX;
      if((x2 - (x1+dx)) >= minx) {
         x1 += dx;
      }
      if(x1 < 0)
         x1 = 0;
      shCenter->Left = x1;
      shCenter->Top = y1;
      shCenter->Width = x2 - x1 + 1;
      shCenter->Height = y2 - y1 + 1;
      UpdateCenterDotPosition();
   }
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::shLeftMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   boolCenterLeftMove = false;
}
//---------------------------------------------------------------------------
// 2022 6 18 - chc LeftDown移動
bool boolCenterLeftDownMove = false;
int CenterLeftDownX,CenterLeftDownY;
void __fastcall TfrnMain::shLeftDownMouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   boolCenterLeftDownMove = true;
   CenterLeftDownX = X;
   CenterLeftDownY = Y;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::shLeftDownMouseMove(TObject *Sender,
      TShiftState Shift, int X, int Y)
{
int dx,dy,x1,y1,x2,y2,w,h,width,height,minx,miny;

   // 移動中
   minx = 20;
   miny = 20;
   if(boolCenterLeftDownMove == true) {
      // 校正中心框位置
      width = imCCD->Width;
      height = imCCD->Height;
      w = shCenter->Width;
      h = shCenter->Height;
      x1 = shCenter->Left;
      y1 = shCenter->Top;
      x2 = x1 + shCenter->Width - 1;
      y2 = y1 + shCenter->Height - 1;
      // 變化
      dx = X - CenterLeftUpX;
      dy = Y - CenterLeftUpY;
      if((x2 - (x1+dx)) >= minx) {
         x1 += dx;
      }
      if(((y2+dy) - y1) >= miny) {
         y2 += dy;
      }
      if(x1 < 0)
         x1 = 0;
      if(y2 >= height)
         y2 = height - 1;
      shCenter->Left = x1;
      shCenter->Top = y1;
      shCenter->Width = x2 - x1 + 1;
      shCenter->Height = y2 - y1 + 1;
      UpdateCenterDotPosition();
   }
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::shLeftDownMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   boolCenterLeftDownMove = false;
}
//---------------------------------------------------------------------------
// 2022 6 18 - chc Up移動
bool boolCenterUpMove = false;
int CenterUpX,CenterUpY;
void __fastcall TfrnMain::shUpMouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   boolCenterUpMove = true;
   CenterUpX = X;
   CenterUpY = Y;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::shUpMouseMove(TObject *Sender, TShiftState Shift,
      int X, int Y)
{
int dx,dy,x1,y1,x2,y2,w,h,width,height,minx,miny;

   // 移動中
   minx = 20;
   miny = 20;
   if(boolCenterUpMove == true) {
      // 校正中心框位置
      width = imCCD->Width;
      height = imCCD->Height;
      w = shCenter->Width;
      h = shCenter->Height;
      x1 = shCenter->Left;
      y1 = shCenter->Top;
      x2 = x1 + shCenter->Width - 1;
      y2 = y1 + shCenter->Height - 1;
      // 變化
      dy = Y - CenterUpY;
      if((y2 - (y1+dy)) >= miny) {
         y1 += dy;
      }
      if(y1 < 0)
         y1 = 0;
      shCenter->Left = x1;
      shCenter->Top = y1;
      shCenter->Width = x2 - x1 + 1;
      shCenter->Height = y2 - y1 + 1;
      UpdateCenterDotPosition();
   }
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::shUpMouseUp(TObject *Sender, TMouseButton Button,
      TShiftState Shift, int X, int Y)
{

   boolCenterUpMove = false;
}
//---------------------------------------------------------------------------
// 2022 6 18 - chc Down移動
bool boolCenterDownMove = false;
int CenterDownX,CenterDownY;
void __fastcall TfrnMain::shDownMouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   boolCenterDownMove = true;
   CenterDownX = X;
   CenterDownY = Y;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::shDownMouseMove(TObject *Sender,
      TShiftState Shift, int X, int Y)
{
int dx,dy,x1,y1,x2,y2,w,h,width,height,minx,miny;

   // 移動中
   minx = 20;
   miny = 20;
   if(boolCenterDownMove == true) {
      // 校正中心框位置
      width = imCCD->Width;
      height = imCCD->Height;
      w = shCenter->Width;
      h = shCenter->Height;
      x1 = shCenter->Left;
      y1 = shCenter->Top;
      x2 = x1 + shCenter->Width - 1;
      y2 = y1 + shCenter->Height - 1;
      // 變化
      dy = Y - CenterDownY;
      if(((y2+dy) - y1) >= miny) {
         y2 += dy;
      }
      if(y2 >= height)
         y2 = height - 1;
      shCenter->Left = x1;
      shCenter->Top = y1;
      shCenter->Width = x2 - x1 + 1;
      shCenter->Height = y2 - y1 + 1;
      UpdateCenterDotPosition();
   }
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::shDownMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   boolCenterDownMove = false;
}
//---------------------------------------------------------------------------
// 2022 6 18 - chc RightUp移動
bool boolCenterRightUpMove = false;
int CenterRightUpX,CenterRightUpY;
void __fastcall TfrnMain::shRightUpMouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   boolCenterRightUpMove = true;
   CenterRightUpX = X;
   CenterRightUpY = Y;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::shRightUpMouseMove(TObject *Sender,
      TShiftState Shift, int X, int Y)
{

int dx,dy,x1,y1,x2,y2,w,h,width,height,minx,miny;

   // 移動中
   minx = 20;
   miny = 20;
   if(boolCenterRightUpMove == true) {
      // 校正中心框位置
      width = imCCD->Width;
      height = imCCD->Height;
      w = shCenter->Width;
      h = shCenter->Height;
      x1 = shCenter->Left;
      y1 = shCenter->Top;
      x2 = x1 + shCenter->Width - 1;
      y2 = y1 + shCenter->Height - 1;
      // 變化
      dx = X - CenterRightUpX;
      dy = Y - CenterRightUpY;
      if(((x2+dx) - x1) >= minx) {
         x2 += dx;
      }
      if((y2 - (y1+dy)) >= miny) {
         y1 += dy;
      }
      if(x2 >= width)
         x2 = width - 1;
      if(y1 < 0)
         y1 = 0;
      shCenter->Left = x1;
      shCenter->Top = y1;
      shCenter->Width = x2 - x1 + 1;
      shCenter->Height = y2 - y1 + 1;
      UpdateCenterDotPosition();
   }
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::shRightUpMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   boolCenterRightUpMove = false;
}
//---------------------------------------------------------------------------
// 2022 6 18 - chc Right移動
bool boolCenterRightMove = false;
int CenterRightX,CenterRightY;
void __fastcall TfrnMain::shRightMouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   boolCenterRightMove = true;
   CenterRightX = X;
   CenterRightY = Y;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::shRightMouseMove(TObject *Sender,
      TShiftState Shift, int X, int Y)
{
int dx,dy,x1,y1,x2,y2,w,h,width,height,minx,miny;

   // 移動中
   minx = 20;
   miny = 20;
   if(boolCenterRightMove == true) {
      // 校正中心框位置
      width = imCCD->Width;
      height = imCCD->Height;
      w = shCenter->Width;
      h = shCenter->Height;
      x1 = shCenter->Left;
      y1 = shCenter->Top;
      x2 = x1 + shCenter->Width - 1;
      y2 = y1 + shCenter->Height - 1;
      // 變化
      dx = X - CenterRightX;
      if(((x2+dx) - x1) >= minx) {
         x2 += dx;
      }
      if(x2 >= width)
         x2 = width - 1;
      shCenter->Left = x1;
      shCenter->Top = y1;
      shCenter->Width = x2 - x1 + 1;
      shCenter->Height = y2 - y1 + 1;
      UpdateCenterDotPosition();
   }
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::shRightMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   boolCenterRightMove = false;
}
//---------------------------------------------------------------------------
// 2022 6 18 - chc RightDown移動
bool boolCenterRightDownMove = false;
int CenterRightDownX,CenterRightDownY;
void __fastcall TfrnMain::shRightDownMouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   boolCenterRightDownMove = true;
   CenterRightDownX = X;
   CenterRightDownY = Y;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::shRightDownMouseMove(TObject *Sender,
      TShiftState Shift, int X, int Y)
{
int dx,dy,x1,y1,x2,y2,w,h,width,height,minx,miny;

   // 移動中
   minx = 20;
   miny = 20;
   if(boolCenterRightDownMove == true) {
      // 校正中心框位置
      width = imCCD->Width;
      height = imCCD->Height;
      w = shCenter->Width;
      h = shCenter->Height;
      x1 = shCenter->Left;
      y1 = shCenter->Top;
      x2 = x1 + shCenter->Width - 1;
      y2 = y1 + shCenter->Height - 1;
      // 變化
      dx = X - CenterRightDownX;
      dy = Y - CenterRightDownY;
      if(((x2+dx) - x1) >= minx) {
         x2 += dx;
      }
      if(((y2+dy) - y1) >= miny) {
         y2 += dy;
      }
      if(x2 >= width)
         x2 = width - 1;
      if(y2 >= height)
         y2 = height - 1;
      shCenter->Left = x1;
      shCenter->Top = y1;
      shCenter->Width = x2 - x1 + 1;
      shCenter->Height = y2 - y1 + 1;
      UpdateCenterDotPosition();
   }
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::shRightDownMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   boolCenterRightDownMove = false;
}
//---------------------------------------------------------------------------
// 2022 6 18 - chc 移動Center Pattern區
bool boolCenterMove = false;
int CenterX,CenterY;
void __fastcall TfrnMain::shCenterMouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   boolCenterMove = true;
   CenterX = X;
   CenterY = Y;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::shCenterMouseMove(TObject *Sender,
      TShiftState Shift, int X, int Y)
{
int dx,dy,x1,y1,x2,y2,w,h,width,height;

   // 移動中
   if(boolCenterMove == true) {
      // 校正中心框位置
      width = imCCD->Width;
      height = imCCD->Height;
      w = shCenter->Width;
      h = shCenter->Height;
      dx = X - CenterX;
      dy = Y - CenterY;
      x1 = shCenter->Left + dx;
      y1 = shCenter->Top + dy;
      x2 = x1 + shCenter->Width - 1;
      y2 = y1 + shCenter->Height - 1;
      if(x1 < 0) {
         x1 = 0;
         x2 = x1 + shCenter->Width - 1;
      }
      if(y1 < 0) {
         y1 = 0;
         y2 = y1 + shCenter->Height - 1;
      }
      if(x2 >= width) {
         x2 = width - 1;
         x1 = x2 - shCenter->Width + 1;
      }
      if(y2 >= height) {
         y2 = height - 1;
         y1 = y2 - shCenter->Height + 1;
      }
      shCenter->Left = x1;
      shCenter->Top = y1;
      UpdateCenterDotPosition();
   }
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::shCenterMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   boolCenterMove = false;
}
//---------------------------------------------------------------------------
// 2022 6 18 - chc 移動Center Pattern區
void __fastcall TfrnMain::UpdateCenterDotPosition()
{
int x1,y1,x2,y2,w,h,cx,cy;

   x1 = shCenter->Left;
   y1 = shCenter->Top;
   x2 = shCenter->Left + shCenter->Width;
   y2 = shCenter->Top + shCenter->Height;
   // 設定各調整點位置
   cx = (x1+x2) / 2;
   cy = (y1+y2) / 2;
   w = shLeft->Width;
   h = shLeft->Height;
   // 左
   shLeft->Left = x1 - w;
   shLeft->Top = cy - h/2;
   // 左上
   shLeftUp->Left = x1 - w;
   shLeftUp->Top = y1 - h;
   // 左下
   shLeftDown->Left = x1 - w;
   shLeftDown->Top = y2;
   // 右
   shRight->Left = x2;
   shRight->Top = cy - h/2;
   // 右上
   shRightUp->Left = x2;
   shRightUp->Top = y1 - h;
   // 右下
   shRightDown->Left = x2;
   shRightDown->Top = y2;
   // 上
   shUp->Left = cx - w/2;
   shUp->Top = y1 - h;
   // 下
   shDown->Left = cx - w/2;
   shDown->Top = y2;
}
//---------------------------------------------------------------------------
// 顯示取像框 Standard Pattern
void __fastcall TfrnMain::cbStdPatternClick(TObject *Sender)
{

   shCenter->Visible = cbStdPattern->Checked;
   shLeft->Visible = cbStdPattern->Checked;
   shRight->Visible = cbStdPattern->Checked;
   shUp->Visible = cbStdPattern->Checked;
   shDown->Visible = cbStdPattern->Checked;
   shLeftUp->Visible = cbStdPattern->Checked;
   shLeftDown->Visible = cbStdPattern->Checked;
   shRightUp->Visible = cbStdPattern->Checked;
   shRightDown->Visible = cbStdPattern->Checked;
   if(cbStdPattern->Checked == true) {
      UpdateCenterDotPosition();
   }
}
//---------------------------------------------------------------------------
// 取消對位框
void __fastcall TfrnMain::btnEraseMatchBoxClick(TObject *Sender)
{

   shMarkMatch->Visible = false;
}
//---------------------------------------------------------------------------
// 將取像框移到十字中心
void __fastcall TfrnMain::btnMatchToCenterClick(TObject *Sender)
{

   if(shCenter->Visible == false)
      return;

   shCenter->Left = shVertical->Left - shCenter->Width/2;
   shCenter->Top = shHorizontal->Top - shCenter->Height/2;
   UpdateCenterDotPosition();
}
//---------------------------------------------------------------------------
// By Recipe
void __fastcall TfrnMain::btnSaveMatchPaameterClick(TObject *Sender)
{
TIniFile *pSystemFile;
AnsiString fname,msg,recipename;
double fscore;
int minreducearea,matchmode;

   int no;
   no = combRecipe->ItemIndex;
   if(no < 0) {
      no = 0;
      combRecipe->ItemIndex = 0;
   }
   recipename = combRecipe->Text;
   fname = RecipeDirectory + "\\" + recipename + ".ini";
   pSystemFile = new TIniFile(fname);

   fscore = edMinScore->Text.ToDouble();
   if(fscore < 0)
      fscore = 0;
   else if(fscore > 1)
      fscore = 1;
   msg.sprintf("%.2f",fscore);
   edMinScore->Text = msg;
   matchmode = rgMatchMode->ItemIndex;
   minreducearea = edMinReduceArea->Text.ToInt();

   pSystemFile->WriteFloat("Match" ,"Score"                                     ,fscore);
   pSystemFile->WriteInteger("Match" ,"Mode"                                    ,matchmode);
   pSystemFile->WriteInteger("Match" ,"MinRedceArea"                            ,minreducearea);

   delete pSystemFile;
}
//---------------------------------------------------------------------------
// 變更recipe
void __fastcall TfrnMain::combRecipeChange(TObject *Sender)
{
AnsiString recipename;

   recipename = combRecipe->Text;
   ReadRecipe(recipename,MODE_EDIT);
}
//---------------------------------------------------------------------------
// mode : 1-Run, 2-Edit
bool __fastcall TfrnMain::ReadRecipe(AnsiString rfname,int mode)
{
TIniFile *pSystemFile;
AnsiString str,fname,recipename;
struct RECIPE_STRU *RecipeBuffer;

   // ini檔名與目錄
   fname = RecipeDirectory + "\\" + rfname;
   if(!FileExists(fname)) {
      sbSystem->Panels->Items[1]->Text = rfname + "Not Existed!";
      return false;
   }
   if(mode == MODE_RUN)
      RecipeBuffer = &RecipeBufferRun;
   else
      RecipeBuffer = &RecipeBufferEdit;

   // 載入ini檔
   pSystemFile = new TIniFile(fname);
   RecipeBuffer->Name               = pSystemFile->ReadString(RECIPE_INFORMATION_SECTION,RECICPE_NAME                        ,"A1");
   for(int i=0 ; i<4 ; i++) {
      RecipeBuffer->TypeWidth[i]    = pSystemFile->ReadInteger(RECIPE_INFORMATION_SECTION,"TypeWidth"+IntToStr(i+1)          ,5000);
      RecipeBuffer->TypeHeight[i]   = pSystemFile->ReadInteger(RECIPE_INFORMATION_SECTION,"TypeHeight"+IntToStr(i+1)         ,5000);
   }

   // Size
   RecipeBuffer->Size               = pSystemFile->ReadInteger(RECIPE_INFORMATION_SECTION,"Size"                             ,3);

   // 讀取Recipe: Base/Dot & Display
   for(int i=0 ; i<MAX_BASE_NO ; i++) {
      RecipeBuffer->BaseBuf[i].X    = pSystemFile->ReadInteger(RECIPE_INFORMATION_SECTION,"Base"+IntToStr(i+1)+" X"       ,20000+i);
      RecipeBuffer->BaseBuf[i].Y    = pSystemFile->ReadInteger(RECIPE_INFORMATION_SECTION,"Base"+IntToStr(i+1)+" Y"       ,20000+i);
      RecipeBuffer->BaseBuf[i].Z    = pSystemFile->ReadInteger(RECIPE_INFORMATION_SECTION,"Base"+IntToStr(i+1)+" Z"       ,20000+i);
   }

   RecipeBuffer->DotNo              = pSystemFile->ReadInteger(RECIPE_INFORMATION_SECTION,"Dot No"                        ,5);
   if(RecipeBuffer->DotNo > MAX_DOT_NO)
      RecipeBuffer->DotNo = MAX_DOT_NO;
   sgDot->RowCount = RecipeBuffer->DotNo + 2;

   for(int i=0 ; i<RecipeBuffer->DotNo ; i++) {
      RecipeBuffer->DotBuf[i].X    = pSystemFile->ReadInteger(RECIPE_INFORMATION_SECTION,"Dot"+IntToStr(i+1)+" X"       ,20000+i);
      RecipeBuffer->DotBuf[i].Y    = pSystemFile->ReadInteger(RECIPE_INFORMATION_SECTION,"Dot"+IntToStr(i+1)+" Y"       ,20000+i);
      RecipeBuffer->DotBuf[i].Z    = pSystemFile->ReadInteger(RECIPE_INFORMATION_SECTION,"Dot"+IntToStr(i+1)+" Z"       ,20000+i);
      sgDot->Cells[DOT_FIELD_INDEX][i+1] = IntToStr(i+1);
      sgDot->Cells[DOT_FIELD_X][i+1] = IntToStr(RecipeBuffer->DotBuf[i].X);
      sgDot->Cells[DOT_FIELD_Y][i+1] = IntToStr(RecipeBuffer->DotBuf[i].Y);
      sgDot->Cells[DOT_FIELD_Z][i+1] = IntToStr(RecipeBuffer->DotBuf[i].Z);
      RecipeBuffer->DotBuf[i].Recipe    = pSystemFile->ReadString(RECIPE_INFORMATION_SECTION,"Dot"+IntToStr(i+1)+" Recipe"       ,"NA");
      sgDot->Cells[DOT_FIELD_RECIPE][i+1] = RecipeBuffer->DotBuf[i].Recipe;
   }

   // 清除最後一Row
   for(int i=0 ; i<sgDot->ColCount ; i++)
      sgDot->Cells[i][sgDot->RowCount-1] = "";

   // 設定第1 Area/Dot值
   // Dot
   edDotNo->Text = "1";
   edDotTNo->Text = IntToStr(RecipeBuffer->DotNo);
   pnlDotX->Caption = IntToStr(RecipeBuffer->DotBuf[0].X);
   pnlDotY->Caption = IntToStr(RecipeBuffer->DotBuf[0].Y);
   pnlDotZ->Caption = IntToStr(RecipeBuffer->DotBuf[0].Z);
   comboSubRecipe->Text = RecipeBuffer->DotBuf[0].Recipe;
   // Base
   pnlBase1X->Caption = IntToStr(RecipeBuffer->BaseBuf[0].X);
   pnlBase1Y->Caption = IntToStr(RecipeBuffer->BaseBuf[0].Y);
   pnlBase1Z->Caption = IntToStr(RecipeBuffer->BaseBuf[0].Z);
   pnlBase2X->Caption = IntToStr(RecipeBuffer->BaseBuf[1].X);
   pnlBase2Y->Caption = IntToStr(RecipeBuffer->BaseBuf[1].Y);
   pnlBase2Z->Caption = IntToStr(RecipeBuffer->BaseBuf[1].Z);

   // LED亮度與CCD: Shutter & Gain值
   RecipeBuffer->LEDValue[0] = pSystemFile->ReadInteger(RECIPE_INFORMATION_SECTION,"LED Value1"     ,LED2CH1Value);
   RecipeBuffer->LEDValue[1] = pSystemFile->ReadInteger(RECIPE_INFORMATION_SECTION,"LED Value2"     ,LED2CH2Value);
   RecipeBuffer->Shutter = pSystemFile->ReadInteger(RECIPE_INFORMATION_SECTION,CCD_SHUTTER          ,CCDShutter);
   RecipeBuffer->Gain = pSystemFile->ReadInteger(RECIPE_INFORMATION_SECTION,CCD_GAIN                ,CCDGain);
   // 要設定LED/Gain/shutter @@

   // Match Parameter
   RecipeBuffer->MinScore = pSystemFile->ReadFloat("Match" ,"Score"                                 ,0.5);
   RecipeBuffer->MatchMode = pSystemFile->ReadInteger("Match" ,"Mode"                               ,0);
   RecipeBuffer->MinReduceArea = pSystemFile->ReadInteger("Match" ,"MinRedceArea"                   ,64);
   str.sprintf("%.2f",RecipeBuffer->MinScore);
   edMinScore->Text = str;
   rgMatchMode->ItemIndex = RecipeBuffer->MatchMode;
   edMinReduceArea->Text = IntToStr(RecipeBuffer->MinReduceArea);

   delete pSystemFile;
   return true;
}
//---------------------------------------------------------------------------
// GetLensPrecision
double __fastcall TfrnMain::GetLensPrecision()
{
double ccdprecision;

   ccdprecision = edCCDPrecision->Text.ToDouble();
   // 精度值顯示
   AnsiString msg;
   msg.sprintf("%.4f",ccdprecision);
   pnlLensPrecision->Caption = msg;

   // 400 Pixel distance
   double dis = pnlWidthValue->Width * ccdprecision;

   // 全影像比例
   double ratiox;
   ratiox = 1.0;
   if(cbCCDFullImage->Checked == true) {
      ratiox = CCDInfoAry[0].Width / imCCD->Width;
      dis *= ratiox;
   }

   msg.sprintf("%.2fum",dis);
   pnlWidthValue->Caption = msg;

   return(ccdprecision);
}
//---------------------------------------------------------------------------
// 2022 6 18 - chc 指定7/8/9/10何者為Enable/Disable: JoystickEnabledKey
void __fastcall TfrnMain::SetJoystickEnabledKey()
{
TIniFile *pSystemFile;

   // ini檔名與目錄: LaserMotion.ini
   pSystemFile = new TIniFile(SystemINIFilename);
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,"Joystick Enable Key"   ,JoystickEnabledKey);
   delete pSystemFile;

   SetJoystickEnabledName();
}
//---------------------------------------------------------------------------
// 2022 6 18 - chc 指定7/8/9/10何者為Enable/Disable: JoystickEnabledKey
void __fastcall TfrnMain::SetJoystickEnabledName()
{
AnsiString msg;
TLabel *label;

   for(int i=7 ; i<=10 ; i++) {
      msg.sprintf("%d",i);
      if(i == JoystickEnabledKey || JoystickEnabledMode == 1)
         msg += "(切換)";
      label = (TLabel*)(FindComponent("laJoystick" + IntToStr(i)));
      label->Caption = msg;
   }
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnUpdateFocusClick(TObject *Sender)
{
AnsiString msg;
TIniFile *pSystemFile;

   // Write to .ini
   pnlSystemMessage->Caption = "更新對焦參數...";
   // ini檔名與目錄
   pSystemFile = new TIniFile(FocusINIFilename);

   // General
   pSystemFile->WriteString(FOCUS_INFORMATION_SECTION,"Z"                       ,edAutoFocus->Text);
   pSystemFile->WriteString(FOCUS_INFORMATION_SECTION,"Z Offset"                ,edAutoFocusOffset->Text);
   pSystemFile->WriteString(FOCUS_INFORMATION_SECTION,"Z Speed"                 ,edAutoFocusSpeed->Text);

   // Quick Mode & Algorithm
   pSystemFile->WriteBool(FOCUS_INFORMATION_SECTION,"Z Quick Mode"              ,cbAIFocus->Checked);
   pSystemFile->WriteInteger(FOCUS_INFORMATION_SECTION,"Z Focus Algorithm"      ,rgFocusAlgorithm->ItemIndex);

   // 對比量: edDifferenceValue
   pSystemFile->WriteString(FOCUS_INFORMATION_SECTION,"Difference Value"        ,edDifferenceValue->Text);

   // 加權: edDifferenceRatio
   pSystemFile->WriteString(FOCUS_INFORMATION_SECTION,"Difference Ratio"        ,edDifferenceRatio->Text);

   // 厚度: edAutoFocusThickness
   pSystemFile->WriteString(FOCUS_INFORMATION_SECTION,"Z Thickness"        ,edAutoFocusThickness->Text);

   delete pSystemFile;
   pnlSystemMessage->Caption = "更新對焦參數完成.";
}
//---------------------------------------------------------------------------
// ToLens
int MotionX,MotionY;
int MotionXAfter,MotionYAfter;
void __fastcall TfrnMain::mnToLensClick(TObject *Sender)
{

   // 是指目前的十字中心: DoubleClickX為imCCD的有效座標, 但shVertical->Left是pnlCCD的座標!
   DoubleClickX = shVertical->Left - imCCD->Left;
   DoubleClickY = shHorizontal->Top - imCCD->Top;

   // 2020 7 24 - chc 要在ToLens前取得
   I32 cmd;
   GetPosition(X_AXIS, &cmd);
   MotionX = cmd;
   GetPosition(Y_AXIS, &cmd);
   MotionY = cmd;
   WriteSystemLog("ToLens前MotionXY= " + IntToStr(MotionX) + "," + IntToStr(MotionY));

   LensNo = 1;
   CCDToLens(LensNo,0);

   // 管理者才要顯示重校正
   if(PriorityLevel > PRIORITY_OP) {
      btnReCalibration->Visible = true;
      pnlReCalibration->Visible = true;
      pnlReCalibration->Color = clSilver;
   }

   // MotionX,MotionY要在ToLens前取得
   GetPosition(X_AXIS, &cmd);
   MotionXAfter = cmd;
   GetPosition(Y_AXIS, &cmd);
   MotionYAfter = cmd;
   WriteSystemLog("ToLens後MotionXY= " + IntToStr(MotionXAfter) + "," + IntToStr(MotionYAfter));

}
//---------------------------------------------------------------------------
// mode: 0-ToLens, 1-ToCCD
void __fastcall TfrnMain::CCDToLens(int lensno, int mode)
{
int level;
double fdy,ccdprecision,fdx;
int axisno,position,xposition,yposition;
I32 cmd;
AnsiString msg;
int cx,cy,X,Y;

   // 禁止操作
   pcSystem->Enabled = false;
   pnlCCD->Enabled = false;

   // X/Y position(set by MouseDown Event)
   X = DoubleClickX;
   Y = DoubleClickY;

   cx = imCCD->Width / 2;
   cy = imCCD->Height / 2;

   // use shVertical & shHorizontal(imCCD: 1020*810)
   cx = shVertical->Left - imCCD->Left;
   cy = shHorizontal->Top - imCCD->Top;

   pnlSystemMessage->Caption = "ToLens: XYMoving...";
   WriteSystemLog(pnlSystemMessage->Caption);
   // Y軸
   pnlYMove->Color = clSilver;
   level = shHorizontal->Top;
   ccdprecision = edCCDPrecision->Text.ToDouble();

   fdy = (Y - (level - imCCD->Top)) * ccdprecision;
   msg.sprintf("Y,level,top,fy,precision= %d,%d,%d,%.4f,%.4f",Y,level,imCCD->Top,fdy,ccdprecision);
   WriteSystemLog(msg);

   // ToCCD
   if(mode == 1)
      fdy = 0;

   // 兩個Lens之間的間距: edLens1X
   TLMDEdit *edx,*edy;
   int lensx,lensy;
   int ccdx,ccdy;

   // 2020 3 24 - chc 改成double
   //int dx,dy;
   double pdx,pdy;

   WriteSystemLog("取得Lens Position..." + IntToStr(lensno));
   edx = (TLMDEdit*)(FindComponent("edLens" + IntToStr(lensno) + "X"));
   edy = (TLMDEdit*)(FindComponent("edLens" + IntToStr(lensno) + "Y"));
   WriteSystemLog("取得Lens Position..." + edx->Name + "," + edx->Text + "," + edy->Name + "," + edy->Text);
   lensx = edx->Text.ToInt();
   WriteSystemLog("取得Lens PositionX");
   lensy = edy->Text.ToInt();
   WriteSystemLog("取得Lens PositionY");
   ccdx = edCCDX->Text.ToInt();
   ccdy = edCCDY->Text.ToInt();
   WriteSystemLog("取得CCD Position");

   // dx,dy改成double
   pdx = (double)(lensx - ccdx) * X_RESOLUTION;
   pdy = (double)(lensy - ccdy) * Y_RESOLUTION;
   if(mode == 1) {
      pdx = 0 - pdx;
      pdy = 0 - pdy;
   }
   fdy += pdy;

   WriteSystemLog("取得Lens-CCD位移量.");
   msg.sprintf("lensy(p), ccdy(p), dy(um), fdy(um) = %d,%d,%.4f,%.4f",lensy,ccdy,pdy,fdy);
   WriteSystemLog(msg);

   if(cbLensYDirection->Checked == true)
      fdy = 0 - fdy;
   msg.sprintf("%.3f",fdy);
   pnlYAltOffset->Caption = msg;
   // Y - absolute
   axisno = Y_AXIS;

   GetPosition(axisno, &cmd);
   position = cmd + (fdy / Y_RESOLUTION);
   yposition = position;

   // X軸
   pnlXMove->Color = clSilver;
   level = shVertical->Left;
   fdx = (X - (level - imCCD->Left)) * ccdprecision;
   msg.sprintf("X,level,left,fx= %d,%d,%d,%.4f,%.4f",X,level,imCCD->Left,fdx,ccdprecision);
   WriteSystemLog(msg);

   if(mode == 1)
      fdx = 0;

   // 兩個Lens之間的間距: edLens1X
   fdx += pdx;
   msg.sprintf("lensx(p), ccdx(p), dx(um), fdx(um) = %d,%d,%.4f,%.4f",lensx,ccdx,pdx,fdx);
   WriteSystemLog(msg);

   if(cbLensXDirection->Checked == true)
      fdx = 0 - fdx;
   msg.sprintf("%.3f",fdx);
   pnlXAltOffset->Caption = msg;
   // X - absolute
   axisno = X_AXIS;

   GetPosition(axisno, &cmd);
   position = cmd + (fdx / X_RESOLUTION);
   WriteSystemLog("btnGetBrukerZClick() - CCDToLens()");
   xposition = position;

   // 使用XY同動
   MoveToXY(xposition,yposition);
   Sleep(100);

   // 強制切到X軸
   axisno = X_AXIS;
   combAxis->ItemIndex = axisno;

end:
   // 恢復操作
   pcSystem->Enabled = true;
   pnlCCD->Enabled = true;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::mnToCCDClick(TObject *Sender)
{

   LensNo = 1;
   CCDToLens(LensNo,1);
   btnReCalibration->Visible = false;
   pnlReCalibration->Visible = false;
}
//---------------------------------------------------------------------------
// 重新定義硬體異常
// true: 異常
void __fastcall TfrnMain::InitAlarmStatus()
{

   AlarmStatus.boolCDA          = false;
   AlarmStatus.boolVacuum       = false;
   AlarmStatus.boolMotion       = false;
   AlarmStatus.boolCCD          = false;
   AlarmStatus.boolLED          = false;
   AlarmStatus.boolDI           = false;
   AlarmStatus.boolDO           = false;
   AlarmStatus.boolEMO          = false;
   AlarmStatus.boolPower        = false;
   AlarmStatus.boolBXFM         = false;
   AlarmStatus.boolOperation    = false;
   AlarmStatus.boolInDoor       = false;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::cbBit2Click(TObject *Sender)
{

   WriteDO(IO1_ID);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::cbBit1Click(TObject *Sender)
{

   WriteDO(IO1_ID);
}
//---------------------------------------------------------------------------
// Red Light
void __fastcall TfrnMain::cbBit11Click(TObject *Sender)
{

   WriteDO(IO1_ID);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::cbBit12Click(TObject *Sender)
{

   WriteDO(IO1_ID);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::cbBit13Click(TObject *Sender)
{

   WriteDO(IO1_ID);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::cbBit14Click(TObject *Sender)
{

   WriteDO(IO1_ID);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::cbBit15Click(TObject *Sender)
{

   WriteDO(IO1_ID);
}
//---------------------------------------------------------------------------
// 關閉前強制到原點或入料點
void __fastcall TfrnMain::ForceToOriginal()
{
int ox,oy,ix,iy,mx,my;
I32 cmd;
bool boolgo = true;

   ox = edOriginalX->Text.ToInt();
   oy = edOriginalY->Text.ToInt();
   ix = edLoadX->Text.ToInt();
   iy = edLoadY->Text.ToInt();

   // 設定大範圍, 避免誤判
   ox += 100;
   oy += 100;
   ix += 100;
   iy += 100;

   GetPosition(X_AXIS, &cmd);
   mx = cmd;
   GetPosition(Y_AXIS, &cmd);
   my = cmd;

   AnsiString msg;
   msg.sprintf("Close(ox,oy), (ix,iy), (mx,my)= (%d,%d), (%d,%d), (%d,%d)",ox,oy,ix,iy,mx,my);
   WriteSystemLog(msg);

   if((mx < ox || mx < ix) && (my < oy || my < iy)) {
      boolgo = false;
      WriteSystemLog("不用回入料點");
   }
   if(boolgo == true) {
      Application->MessageBox("關閉前, 強制到入料點", " 關閉程式", MB_OK);
      btnToLoadPositionClick(this);
   }

}
//---------------------------------------------------------------------------
// Close all Timer
void __fastcall TfrnMain::CloseAllTimer()
{

   WriteSystemLog("Close All Timer...");
   tmActiveSocket->Enabled = false;
   tmActiveSocket2->Enabled = false;
   tm400ms->Enabled = false;
   tmISCCD->Enabled = false;
   tmBeep->Enabled = false;
   tmStatus->Enabled = false;
   tmStatus2->Enabled = false;
   tmJoystick->Enabled = false;
   tmTrigger->Enabled = false;
   tmX->Enabled = false;
   tmY->Enabled = false;
   tmZ->Enabled = false;

   ICImagingControl1->LiveStop();
   pnlISCCDStaus->Color = clSilver;
   Sleep(100);

   tmMotionPolling->Enabled = false;
   tmSystem->Enabled = false;
   WriteSystemLog("Close All Timer.");
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::imCCDMouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   DoubleClickX = X;
   DoubleClickY = Y;

   // 2022 7 15 - chc Add Measure Item
   if(MeasureState == 1 && cbMeasure->Checked == true) {
      AddMeasureMessage(AnsiString("長度: ") + pnlMeasureResult->Caption);
   }
   if(!Shift.Contains(ssAlt) && !Shift.Contains(ssCtrl) && Button == mbLeft) {
      if(MeasureState == 0 && cbMeasure->Checked == true) {
         pnlMeasureResult->Caption = "";
         MeasureState = 1;
         Mx1 = X;
         My1 = Y;
         shMeasure->Visible = true;
         shMeasure->Left = X + imCCD->Left;
         shMeasure->Top = Y + imCCD->Top;
         shMeasure->Width = 2;
         shMeasure->Height = 2;
      }
      else if(MeasureState == 1 && cbMeasure->Checked == true) {
         MeasureState = 2;
         Mx2 = X;
         My2 = Y;
         MeasureState = 0;
         double wvalue,hvalue,lvalue,dx;
         AnsiString msg;
         dx = GetLensPrecision();
         // Width
         wvalue = (abs(Mx2 - Mx1)+1) * dx;
         // Height
         hvalue = (abs(My2 - My1)+1) * dx;
         // Length
         lvalue = sqrt((Mx2-Mx1)*(Mx2-Mx1) + (My2-My1)*(My2-My1)) * dx;
         if(pnlUnit->Caption == "um")
            msg.sprintf("(um)W:%.2f  H:%.2f  L:%.2f  A:%.2f  a:%.2f",wvalue,hvalue,lvalue,wvalue*hvalue,((wvalue*hvalue)/4)*M_PI);
         else {
            wvalue /= MM_TO_UM;
            hvalue /= MM_TO_UM;
            lvalue /= MM_TO_UM;
            msg.sprintf("(mm)W:%.3f  H:%.3f  L:%.3f  A:%.4f  a:%.4f",wvalue,hvalue,lvalue,wvalue*hvalue,((wvalue*hvalue)/4)*M_PI);
         }
         pnlMeasureResult->Caption = msg;
         //shMeasure->Visible = false;
         shEllipse->Left = shMeasure->Left;
         shEllipse->Top = shMeasure->Top;
         shEllipse->Width = shMeasure->Width;
         shEllipse->Height = shMeasure->Height;
         shEllipse->Visible = true;
      }
   }
}
//---------------------------------------------------------------------------


void __fastcall TfrnMain::btnSetLens1PositionClick(TObject *Sender)
{

   SetLensPosition(1);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnSetLens2PositionClick(TObject *Sender)
{

   SetLensPosition(2);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnToLens1PositionClick(TObject *Sender)
{

   pnlToLens1Position->Color = clSilver;
   ToLensPosition(1);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnToLens2PositionClick(TObject *Sender)
{

   pnlToLens1Position->Color = clSilver;
   ToLensPosition(2);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnSetLens1ZLimitClick(TObject *Sender)
{

   SetLensZLimit(1);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnSetLens2ZLimitClick(TObject *Sender)
{

   SetLensZLimit(2);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnSaveLensPositionClick(TObject *Sender)
{
TIniFile *pSystemFile;
AnsiString str;
TLMDEdit *edx,*edy,*edz,*edt;
int x,y,z,t;
// add Z Limit
TLMDEdit *edzlimit;
int zlimit;
TEdit *edp;
double precision;

   // Confirm
   if(Application->MessageBox("Save Lens parameter(Center position)?", "Saving Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
      return;
   }

   pnlSaveLensPosition->Color = clSilver;
   pnlSystemMessage->Caption = "Update Lens Position...";
   // ini檔名與目錄
   pSystemFile = new TIniFile(LensINIFilename);

   for(int i=0 ; i<5 ; i++) {
      edx = (TLMDEdit *)(FindComponent("edLens" + IntToStr(i+1) + "X"));
      edy = (TLMDEdit *)(FindComponent("edLens" + IntToStr(i+1) + "Y"));
      edz = (TLMDEdit *)(FindComponent("edLens" + IntToStr(i+1) + "Z"));
      edt = (TLMDEdit *)(FindComponent("edLens" + IntToStr(i+1) + "T"));
      edp = (TEdit *)(FindComponent("edCCDPrecision" + IntToStr(i+1)));

      x = edx->Text.ToInt();
      y = edy->Text.ToInt();
      z = edz->Text.ToInt();
      t = edt->Text.ToInt();
      precision = edp->Text.ToDouble();

      LensPosition[i].X = x;
      LensPosition[i].Y = y;
      LensPosition[i].Z = z;
      LensPosition[i].Precision = precision;

      pSystemFile->WriteInteger(LENS_POSITION_SECTION,"LensPosition" + IntToStr(i+1) + "X"    ,x);
      pSystemFile->WriteInteger(LENS_POSITION_SECTION,"LensPosition" + IntToStr(i+1) + "Y"    ,y);
      pSystemFile->WriteInteger(LENS_POSITION_SECTION,"LensPosition" + IntToStr(i+1) + "Z"    ,z);
      pSystemFile->WriteInteger(LENS_POSITION_SECTION,"LensPosition" + IntToStr(i+1) + "T"    ,t);
      pSystemFile->WriteFloat(LENS_POSITION_SECTION,"LensPosition" + IntToStr(i+1) + "Precision"    ,precision);

   }

   delete pSystemFile;
   pnlSystemMessage->Caption = "Update Lens Parameter Completed.";
   pnlSaveLensPosition->Color = clLime;
}
//---------------------------------------------------------------------------
// Load Lens Position
void __fastcall TfrnMain::LoadLensPosition(int lensno)
{
TIniFile *pSystemFile;
AnsiString str;
TLMDEdit *edx,*edy,*edz,*edt;
int x,y,z,t;
// add Z Limit
TLMDEdit *edzlimit;
int zlimit;
TEdit *edp;
double precision;

   pnlSystemMessage->Caption = "Load Lens Parameter...";
   // ini檔名與目錄
   pSystemFile = new TIniFile(LensINIFilename);

   // try-catch
   try {
      for(int i=0 ; i<5 ; i++) {
         x = pSystemFile->ReadInteger(LENS_POSITION_SECTION,"LensPosition" + IntToStr(i+1) + "X",0);
         y = pSystemFile->ReadInteger(LENS_POSITION_SECTION,"LensPosition" + IntToStr(i+1) + "Y",0);
         z = pSystemFile->ReadInteger(LENS_POSITION_SECTION,"LensPosition" + IntToStr(i+1) + "Z",0);
         t = pSystemFile->ReadInteger(LENS_POSITION_SECTION,"LensPosition" + IntToStr(i+1) + "T",0);
         // 3.45: 0.69, 0.345, 0.1725, 0.069, 0.0345
         if(i == 0)
            precision = pSystemFile->ReadFloat(LENS_POSITION_SECTION,"LensPosition" + IntToStr(i+1) + "Precision",0.69);
         else if(i == 1)
            precision = pSystemFile->ReadFloat(LENS_POSITION_SECTION,"LensPosition" + IntToStr(i+1) + "Precision",0.345);
         else if(i == 2)
            precision = pSystemFile->ReadFloat(LENS_POSITION_SECTION,"LensPosition" + IntToStr(i+1) + "Precision",0.1725);
         else if(i == 3)
            precision = pSystemFile->ReadFloat(LENS_POSITION_SECTION,"LensPosition" + IntToStr(i+1) + "Precision",0.069);
         else if(i == 4)
            precision = pSystemFile->ReadFloat(LENS_POSITION_SECTION,"LensPosition" + IntToStr(i+1) + "Precision",0.0345);

         edx = (TLMDEdit *)(FindComponent("edLens" + IntToStr(i+1) + "X"));
         edy = (TLMDEdit *)(FindComponent("edLens" + IntToStr(i+1) + "Y"));
         edz = (TLMDEdit *)(FindComponent("edLens" + IntToStr(i+1) + "Z"));
         edt = (TLMDEdit *)(FindComponent("edLens" + IntToStr(i+1) + "T"));
         edp = (TEdit *)(FindComponent("edCCDPrecision" + IntToStr(i+1)));

         edx->Text = IntToStr(x);
         edy->Text = IntToStr(y);
         edz->Text = IntToStr(z);
         edt->Text = IntToStr(t);
         str.sprintf("%.04f",precision);
         edp->Text = str;
      }

   }
   catch(Exception &e) {
      WriteSystemLog("LoadLensPosition() - Error");
      sbSystem->Panels->Items[1]->Text = "LoadLensPosition() - Error";
   }
   delete pSystemFile;
   pnlSystemMessage->Caption = "Load Lens Parameter Completed.";

}
//---------------------------------------------------------------------------
// 2022 6 19 - chc 更新Table位置對應圖
void __fastcall TfrnMain::UpdateTablePosition()
{
int x1,y1,x2,y2,wx1,wy1,wx2,wy2,wdx,wdy,dx,dy,x,y,cx,cy;

   cx = edCounterX->Text.ToInt();
   cy = edCounterY->Text.ToInt();

   wx1 = 0;
   wy1 = 0;
   wx2 = imTable->Width - 1;
   wy2 = imTable->Height - 1;
   wdx = wx2 - wx1;
   wdy = wy2 - wy1;

   // 量測
   if(rgTableCCDMode->ItemIndex == 1) {
      x1 = Vx1;
      y1 = Vy1;
      x2 = Vx2;
      y2 = Vy2;
   }
   // 對位
   else {
      x1 = Tx1;
      y1 = Ty1;
      x2 = Tx2;
      y2 = Ty2;
   }
   dx = x2 - x1;
   dy = y2 - y1;

   if(cx <= x1 && cx >= x2 && cy >= y1 && cy <= y2) {
      x = wx1 + ((double)(cx - x1) / dx) * wdx;
      y = wy1 + ((double)(cy - y1) / dy) * wdy;
      shTable->Left = x + imTable->Left - shTable->Width/2;
      shTable->Top = y + imTable->Top - shTable->Height/2;
      shTable->Visible = true;
      shTable->Refresh();
   }
   else
      shTable->Visible = false;
}
//---------------------------------------------------------------------------
void __fastcall TfrnMain::ReadRangeData()
{
TIniFile *pSystemFile;
AnsiString fname;

   fname = SystemDirectory + "\\Stage.ini";
   pSystemFile = new TIniFile(fname);

   Tx1 = pSystemFile->ReadInteger("Range Motion" ,"X1"                          ,-405201);
   Ty1 = pSystemFile->ReadInteger("Range Motion" ,"Y1"                          ,214318);
   Tx2 = pSystemFile->ReadInteger("Range Motion" ,"X2"                          ,4527086);
   Ty2 = pSystemFile->ReadInteger("Range Motion" ,"Y2"                          ,6126607);

   Vx1 = pSystemFile->ReadInteger("Range DSX" ,"X1"                             ,649921);
   Vy1 = pSystemFile->ReadInteger("Range DSX" ,"Y1"                             ,308814);
   Vx2 = pSystemFile->ReadInteger("Range DSX" ,"X2"                             ,5367962);
   Vy2 = pSystemFile->ReadInteger("Range DSX" ,"Y2"                             ,6088443);

   // Motion CCD
   pnlLeftUpMX->Caption = IntToStr(Tx1);
   pnlLeftUpMY->Caption = IntToStr(Ty1);
   pnlRightDownMX->Caption = IntToStr(Tx2);
   pnlRightDownMY->Caption = IntToStr(Ty2);

   // DSX CCD
   pnlLeftUpBX->Caption = IntToStr(Vx1);
   pnlLeftUpBY->Caption = IntToStr(Vy1);
   pnlRightDownBX->Caption = IntToStr(Vx2);
   pnlRightDownBY->Caption = IntToStr(Vy2);

   delete pSystemFile;
}
//---------------------------------------------------------------------------
// for test
void __fastcall TfrnMain::pnlTableXClick(TObject *Sender)
{

   //cbContinueMove1->Checked = false;
}
//---------------------------------------------------------------------------
// 2022 6 19 - chc 若是在傾斜位置, 要補償X/Y/Z
bool __fastcall TfrnMain::IsHeadTilt()
{
int currt,sett;
AnsiString msg;

   currt = edCounterT->Text.ToInt();
   sett = ed45T->Text.ToInt();
   msg.sprintf("IsHeadTilt() currt,sett = %d,%d",currt,sett);
   WriteSystemLog(msg);

   if(abs(currt - sett) < 80000) {
      WriteSystemLog("在左傾斜位置: Yes");
      return true;
   }
   else {
      WriteSystemLog("在左傾斜位置: No");
      return false;
   }
}
//---------------------------------------------------------------------------
// 2022 6 19 - chc 若是在傾斜位置, 要補償X/Y/Z
bool __fastcall TfrnMain::IsHeadRTilt()
{
int currt,sett;
AnsiString msg;

   currt = edCounterT->Text.ToInt();
   sett = edR45T->Text.ToInt();
   msg.sprintf("IsHeadTilt() currt,sett = %d,%d",currt,sett);
   WriteSystemLog(msg);

   if(abs(currt - sett) < 80000) {
      WriteSystemLog("在右傾斜位置: Yes");
      return true;
   }
   else {
      WriteSystemLog("在右傾斜位置: No");
      return false;
   }
}
//---------------------------------------------------------------------------
// 2022 6 19 - chc 若是在水平位置, 要補償X/Y/Z
bool __fastcall TfrnMain::IsHeadHorizontal()
{
int currt,sett;
AnsiString msg;

   currt = edCounterT->Text.ToInt();
   sett = ed0T->Text.ToInt();
   msg.sprintf("IsHeadHorizontal() currt,sett = %d,%d",currt,sett);
   WriteSystemLog(msg);

   if(abs(currt - sett) < 80000) {
      WriteSystemLog("在水平位置: Yes");
      return true;
   }
   else {
      WriteSystemLog("在水平位置: No");
      return false;
   }
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnR45PositionClick(TObject *Sender)
{

   SetR45Position();        
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnToR45PositionClick(TObject *Sender)
{

   // 禁操作
   pcSystem->Enabled = false;
   pnlStartMessage->Caption = "Moving to R45...";
   pnlStartMessage->Visible = true;
   pnlStartMessage->Refresh();
   // 到入料點/原點用最高速
   boolUseMaxSpeed = true;

   MotionStatus(false);
   ToR45Position(1);
   MotionStatus(true);

   // 禁操作
   pcSystem->Enabled = true;
   pnlStartMessage->Visible = false;
   // 到入料點/原點用最高速
   boolUseMaxSpeed = false;
}
//---------------------------------------------------------------------------
// Process Alarm
// CDA, Vacuum, EMO, Power - true(異常: Alarm)
// Motion, CCD, LED, DI, DO, Bruker, URV, Operation - true(異常: Alarm)
void __fastcall TfrnMain::UpdateAlarmStatus()
{

   // 重新定義硬體異常
   bool balarm = false;

   // CDA
   // true為異常
   if(AlarmStatus.boolCDA == true) {
      pnlCDAAlarm->Color = clRed;
      balarm = true;
   }
   else {
      pnlCDAAlarm->Color = clSilver;
   }

   // Vacuum
   if(AlarmStatus.boolVacuum == true) {
      pnlVacuumAlarm->Color = clRed;
      balarm = true;
   }
   else {
      pnlVacuumAlarm->Color = clSilver;
   }

   // Motion
   if(AlarmStatus.boolMotion == true) {
      if(pnlPCI7856->Color != clRed)
         pnlPCI7856->Color = clRed;
      balarm = true;
   }
   else {
      if(pnlPCI7856->Color != clLime)
         pnlPCI7856->Color = clLime;
   }

   // CCD
   if(AlarmStatus.boolCCD == true) {
      balarm = true;
      if(pnlCCDStatus->Color != clRed) {
         pnlCCDStatus->Color = clRed;
         pnlCCDStatus1->Color = clRed;
      }
   }
   else {
      if(pnlCCDStatus->Color != clLime) {
         pnlCCDStatus->Color = clLime;
         pnlCCDStatus1->Color = clLime;
      }
   }

   // LED
   if(AlarmStatus.boolLED == true) {
      balarm = true;
      if(pnlLampControl2->Color != clRed) {
         pnlLampControl2->Color = clRed;
         pnlAOILamp->Color = clRed;
      }
   }
   else {
      if(pnlLampControl2->Color != clLime) {
         pnlLampControl2->Color = clLime;
         pnlAOILamp->Color = clLime;
      }
   }

   // DI/DO
   if(AlarmStatus.boolDI == true)
      balarm = true;
   if(AlarmStatus.boolDO == true)
      balarm = true;

   // EMO
   if(AlarmStatus.boolEMO == true) {
      if(pnlEMOAlarm->Color != clRed) {
         pnlEMOAlarm->Color = clRed;
         pnlEMOAlarm1->Color = clRed;
      }
      balarm = true;
   }
   else {
      if(pnlEMOAlarm->Color != clSilver) {
         pnlEMOAlarm->Color = clSilver;
         pnlEMOAlarm1->Color = clSilver;
      }
   }

   // Power
   if(AlarmStatus.boolPower == true) {
      if(pnlPowerAlarm->Color != clRed)
         pnlPowerAlarm->Color = clRed;
      balarm = true;
   }
   else {
      if(pnlPowerAlarm->Color != clSilver)
         pnlPowerAlarm->Color = clSilver;
   }

   // BXFM
   if(AlarmStatus.boolBXFM == true)
      balarm = true;

   // 2022 12 5 - chc 光柵
   if(AlarmStatus.boolLPLight == true)
      balarm = true;

   // Operation
   if(AlarmStatus.boolOperation == true)
      balarm = true;

   // Door
   if(AlarmStatus.boolInDoor == true)
      balarm = true;

   // Alarm
   if(balarm == true) {
      if(AlarmStatus.boolEMO) {
         SetLight(SYSTEM_ALARM);
         Beep(0);
      }
      else if(AlarmStatus.boolInDoor) {
         SetLight(DOOR_ALARM);
         if(pnlError->Visible == false) {
            //pnlError->Visible = true;
            pnlError->Caption = "Interlock Error";
            pnlAlarm->Caption = pnlError->Caption;
         }
         Beep(0);
      }
      else if(AlarmStatus.boolPower) {
         SetLight(POWER_ALARM);
         if(pnlError->Visible == false) {
            //pnlError->Visible = true;
            pnlError->Caption = "Power Error";
            pnlAlarm->Caption = pnlError->Caption;
         }
         if(frnMain->cbBit15->Checked == true)
            BeepStop();
      }
      else if(AlarmStatus.boolLPLight) {
         SetLight(LIGHT_ALARM);
         if(pnlError->Visible == false) {
            //pnlError->Visible = true;
            pnlError->Caption = "Safety Area Error";
            pnlAlarm->Caption = pnlError->Caption;
         }
         if(frnMain->cbBit15->Checked == true)
            BeepStop();
      }
      else if(AlarmStatus.boolCDA) {
         SetLight(CDA_ALARM);
         if(frnMain->cbBit15->Checked == true)
            BeepStop();
      }
      else if(AlarmStatus.boolVacuum) {
         SetLight(VACUUM_ALARM);
         if(frnMain->cbBit15->Checked == true)
            BeepStop();
      }
      else {
         if(frnMain->cbBit15->Checked == true)
            BeepStop();
      }
   }
   else {
      SetRedLamp(false);
      SetYellowLamp(false);
      if(pnlError->Visible == true) {
         pnlError->Visible = false;
         pnlAlarm->Caption = "";
      }
      if(frnMain->cbBit15->Checked == true)
         BeepStop();
   }

   bool boolchange = false;
   if(cbBit11->Checked == true) {
      if(cbBit12->Checked == true) {
         cbBit12->Checked = false;
         boolchange = true;
      }
      if(cbBit13->Checked == true) {
         cbBit13->Checked = false;
         boolchange = true;
      }
      if(boolchange == true) {
         WriteDO(IO1_ID);
      }
   }
   boolchange = false;
   if(cbBit12->Checked == true) {
      if(cbBit13->Checked == true) {
         cbBit13->Checked = false;
         boolchange = true;
      }
      if(boolchange == true) {
         WriteDO(IO1_ID);
      }
   }

}
//---------------------------------------------------------------------------
//  設黃燈: Idle
//   #define SYSTEM_IDLE          0
//   #define SYSTEM_MEASURE       1
//   #define SYSTEM_RECIPE        2
//   #define SYSTEM_ALARM         3
void __fastcall TfrnMain::SetLight(int mode)
{

   if(bool_IO_Status == false)
      return;

   switch(mode) {
      case SYSTEM_IDLE:
//         SetYellowLamp(cbIdleYellow->Checked);
         SetGreenLamp(cbIdleGreen->Checked);
         break;
      case SYSTEM_MEASURE:
//         SetYellowLamp(cbMeasureYellow->Checked);
         SetGreenLamp(cbMeasureGreen->Checked);
         break;
      case SYSTEM_RECIPE:
//         SetYellowLamp(cbRecipeYellow->Checked);
         SetGreenLamp(cbRecipeGreen->Checked);
         break;
      case SYSTEM_ALARM:
         SetYellowLamp(false);
         SetGreenLamp(false);
         SetRedLamp(true);
         break;

      case DOOR_ALARM:
         SetYellowLamp(false);
         SetGreenLamp(false);
         SetRedLamp(true);
         break;
      case POWER_ALARM:
         SetYellowLamp(true);
         SetGreenLamp(false);
         SetRedLamp(false);
         break;
      case LIGHT_ALARM:
         SetYellowLamp(true);
         SetGreenLamp(false);
         SetRedLamp(false);
         break;
      case CDA_ALARM:
         SetYellowLamp(true);
         SetGreenLamp(false);
         SetRedLamp(false);
         break;
      case VACUUM_ALARM:
         SetYellowLamp(true);
         SetGreenLamp(false);
         SetRedLamp(false);
         break;

   }
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnStartRunClick(TObject *Sender)
{

   return;
   // Measure
   SetLight(SYSTEM_MEASURE);

   //...

   // Idle
   SetLight(SYSTEM_IDLE);

}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::pcSystemChange(TObject *Sender)
{

   return;
   if(pcSystem->ActivePage == tsRecipe) {
      SetLight(SYSTEM_RECIPE);
   }
   else {
      SetLight(SYSTEM_IDLE);
   }
}
//---------------------------------------------------------------------------


void __fastcall TfrnMain::bnSaveDOClick(TObject *Sender)
{
TIniFile *pSystemFile;
AnsiString axisname;

   pSystemFile = new TIniFile(SystemINIFilename);

   // 2022 5 21 - chc Idle/Measure/Recipe Lamp
   // Idle
   boolIdleYellow = cbIdleYellow->Checked;
   pSystemFile->WriteBool(MOTION_INFORMATION_SECTION,BOOL_IDLE_YELLOW           ,boolIdleYellow);
   boolIdleGreen = cbIdleGreen->Checked;
   pSystemFile->WriteBool(MOTION_INFORMATION_SECTION,BOOL_IDLE_GREEN            ,boolIdleGreen);
   // Measure
   boolMeasureYellow = cbMeasureYellow->Checked;
   pSystemFile->WriteBool(MOTION_INFORMATION_SECTION,BOOL_MEASURE_YELLOW        ,boolMeasureYellow);
   boolMeasureGreen = cbMeasureGreen->Checked;
   pSystemFile->WriteBool(MOTION_INFORMATION_SECTION,BOOL_MEASURE_GREEN         ,boolMeasureGreen);
   // Recipe
   boolRecipeYellow = cbRecipeYellow->Checked;
   pSystemFile->WriteBool(MOTION_INFORMATION_SECTION,BOOL_RECIPE_YELLOW         ,boolRecipeYellow);
   boolRecipeGreen = cbRecipeGreen->Checked;
   pSystemFile->WriteBool(MOTION_INFORMATION_SECTION,BOOL_RECIPE_GREEN          ,boolRecipeGreen);

   delete pSystemFile;
}
//---------------------------------------------------------------------------
//
void __fastcall TfrnMain::btnUpdateMotionParameterClick(TObject *Sender)
{

   // Null
}
//---------------------------------------------------------------------------
// Left - Type1
void __fastcall TfrnMain::btnType1LeftClick(TObject *Sender)
{

   TypeMoveLeftRight(1,1);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnType1RightClick(TObject *Sender)
{

   TypeMoveLeftRight(1,2);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnType1BackClick(TObject *Sender)
{

   TypeMoveFrontBack(1,2);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnType1FrontClick(TObject *Sender)
{

   TypeMoveFrontBack(1,1);
}
//---------------------------------------------------------------------------
// Left/Right - Type
// no: 1/2/3/4, dir: 1/2(Left/Right)
void __fastcall TfrnMain::TypeMoveLeftRight(int no, int dir)
{
double fdx;
int axisno,position;
I32 cmd;
TPanel *panel;
AnsiString dirname;

   // Disable
   tsArrayDieMove->Enabled = false;

   panel = (TPanel *)(FindComponent("pnlType" + IntToStr(no) + "Width"));
   if(dir == 1)
      dirname = "Left";
   else
      dirname = "right";

   // X軸
   fdx = panel->Caption.ToDouble();
   // 移動X軸 - absolute
   axisno = X_AXIS;
   GetPosition(axisno, &cmd);
   if(dir == 1)
      position = cmd - (fdx / X_RESOLUTION);
   else
      position = cmd + (fdx / X_RESOLUTION);
   if(MoveToX(position) == false) {
      pnlSystemMessage->Caption = "Type" + IntToStr(no) + " " + dirname + ": XMove Fail!";
      // Beep聲
      Beep(500);
      pnlAlarmMessage->Caption = " Type" + IntToStr(no) + "-X Move Error!";
   }
   else {
      pnlSystemMessage->Caption = "Type" + IntToStr(no) + " " + dirname + ": XMove Success";
   }

   // Enable
   tsArrayDieMove->Enabled = true;
}
//---------------------------------------------------------------------------
// Up/Down - Type
// no: 1/2/3/4, dir: 1/2(Up/Down)
void __fastcall TfrnMain::TypeMoveFrontBack(int no, int dir)
{
double fdy;
int axisno,position;
I32 cmd;
TPanel *panel;
AnsiString dirname;

   // Disable
   tsArrayDieMove->Enabled = false;

   panel = (TPanel *)(FindComponent("pnlType" + IntToStr(no) + "Height"));
   if(dir == 1)
      dirname = "Front";
   else
      dirname = "Back";

   // Y軸
   fdy = panel->Caption.ToDouble();
   // 移動Y軸 - absolute
   axisno = Y_AXIS;
   GetPosition(axisno, &cmd);
   if(dir == 1)
      position = cmd + (fdy / Y_RESOLUTION);
   else
      position = cmd - (fdy / Y_RESOLUTION);
   if(MoveToY(position) == false) {
      pnlSystemMessage->Caption = "Type" + IntToStr(no) + " " + dirname + ": YMove Fail!";
      // Beep聲
      Beep(500);
      pnlAlarmMessage->Caption = " Type" + IntToStr(no) + "-Y Move Error!";
   }
   else {
      pnlSystemMessage->Caption = "Type" + IntToStr(no) + " " + dirname + ": YMove Success";
   }

   // Enable
   tsArrayDieMove->Enabled = true;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnType2LeftClick(TObject *Sender)
{

   TypeMoveLeftRight(2,1);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnType3LeftClick(TObject *Sender)
{

   TypeMoveLeftRight(3,1);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnType4LeftClick(TObject *Sender)
{

   TypeMoveLeftRight(4,1);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnType2RightClick(TObject *Sender)
{

   TypeMoveLeftRight(2,2);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnType3RightClick(TObject *Sender)
{

   TypeMoveLeftRight(3,2);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnType4RightClick(TObject *Sender)
{

   TypeMoveLeftRight(4,2);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnType2BackClick(TObject *Sender)
{

   TypeMoveFrontBack(2,2);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnType3BackClick(TObject *Sender)
{

   TypeMoveFrontBack(3,2);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnType4BackClick(TObject *Sender)
{

   TypeMoveFrontBack(4,2);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnType2FrontClick(TObject *Sender)
{

   TypeMoveFrontBack(2,1);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnType3FrontClick(TObject *Sender)
{

   TypeMoveFrontBack(3,1);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnType4FrontClick(TObject *Sender)
{

   TypeMoveFrontBack(4,1);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnUpdateArrayDieClick(TObject *Sender)
{

   pnlType1Width->Caption = edType1Width->Text;
   pnlType1Height->Caption = edType1Height->Text;

   pnlType2Width->Caption = edType2Width->Text;
   pnlType2Height->Caption = edType2Height->Text;

   pnlType3Width->Caption = edType3Width->Text;
   pnlType3Height->Caption = edType3Height->Text;

   pnlType4Width->Caption = edType4Width->Text;
   pnlType4Height->Caption = edType4Height->Text;

}
//---------------------------------------------------------------------------
// 切換400點長度
void __fastcall TfrnMain::cbCCDFullImageChange(TObject *Sender)
{

   Set400Width();
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnReCalibrationClick(TObject *Sender)
{
AnsiString msg;
int CCDx,CCDy;
int Lensx,Lensy;
int nLensx,nLensy;
int nx,ny,x,y,dx,dy;
I32 cmd;
double fdx,fdy;

   btnReCalibration->Color = clSilver;
   if(LensNo == 1) {
      Lensx = edLens1X->Text.ToInt();
      Lensy = edLens1Y->Text.ToInt();
   }

   WriteSystemLog("btnReCalibrationClick LensXY= " + IntToStr(Lensx) + "," + IntToStr(Lensy));
   CCDx = edCCDX->Text.ToInt();
   CCDy = edCCDY->Text.ToInt();
   WriteSystemLog("btnReCalibrationClick CCDXY= " + IntToStr(CCDx) + "," + IntToStr(CCDy));

   GetPosition(X_AXIS, &cmd);
   nx = cmd;
   GetPosition(Y_AXIS, &cmd);
   ny = cmd;
   WriteSystemLog("btnReCalibrationClick MotionXY= " + IntToStr(nx) + "," + IntToStr(ny));
   x = MotionX + (Lensx-CCDx);
   y = MotionY + (Lensy-CCDy);
   WriteSystemLog("btnReCalibrationClick 原MotionXY= " + IntToStr(x) + "," + IntToStr(y) + " - " +
                   IntToStr(MotionXAfter) + "," + IntToStr(MotionYAfter));
   dx = nx - x;
   dy = ny - y;
   WriteSystemLog("btnReCalibrationClick dXY= " + IntToStr(dx) + "," + IntToStr(dy));
   nLensx = Lensx + dx;
   nLensy = Lensy + dy;
   WriteSystemLog("btnReCalibrationClick NewLensXY= " + IntToStr(nLensx) + "," + IntToStr(nLensy));
   fdx = dx * X_RESOLUTION;
   fdy = dy * Y_RESOLUTION;
   msg.sprintf("(%.1fum,%.1fum)",fdx,fdy);

   // Confirm
   if(Application->MessageBox((AnsiString("Lens XY偏移量(dx,dy): ") + msg + ", 重校正? ").c_str(), btnReCalibration->Caption.c_str(), MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
      return;
   }
   if(LensNo == 1) {
      edLens1X->Text = IntToStr(nLensx);
      edLens1Y->Text = IntToStr(nLensy);
   }

   // 寫入ini
   btnSaveLensPositionClick(this);
   btnReCalibration->Color = clLime;

   // Log & 寫入Calibration.log
   msg.sprintf("[%s], 誤差量=(%.1f,%.1f)",btnReCalibration->Caption.c_str(),fdx,fdy);
   WriteSystemLog(msg);
   // Exception Error
   try {                                                                        // 追蹤Exception Error
      AnsiString logMessage;
      AnsiString dstr,tstr,filename;
      FILE *logFile;
      DateTimeToString(dstr,"yyyy'/'mm'/'dd",Date());
      DateTimeToString(tstr,"hh':'nn':'ss':'zzz",Time());
      logMessage = dstr + " " + tstr + "-" + msg + "\n";
      filename = SystemDirectory + "\\Calibration.log";
      logFile = fopen(filename.c_str(),"a+t");
      fprintf(logFile,logMessage.c_str());
      fclose(logFile);
   }
   catch(Exception &e) {
      WriteSystemLog(">>Error(btnReCalibrationClick): " + e.Message);
   }

   btnReCalibration->Visible = false;
   pnlReCalibration->Visible = false;

}
//---------------------------------------------------------------------------
// Type3: 矩形 Draw
// 1. Clear
// 2. 框
// 3. Draw
// 353*353
void __fastcall TfrnMain::btnType3DrawClick(TObject *Sender)
{
double fdx,fdy;
int w,h,xno,yno,dx,dy;

   w = imType3->Width;
   h = imType3->Height;
   xno = edType3XTNo->Text.ToInt();
   yno = edType3YTNo->Text.ToInt();

   // 先填上顏色
   imType3->Canvas->Brush->Style = bsSolid;
   imType3->Canvas->Pen->Style = psSolid;
   imType3->Canvas->Pen->Color = clBtnFace;
   imType3->Canvas->Brush->Color = clBtnFace;
   imType3->Canvas->Rectangle(0,0,w,h);

   // Grid
   fdx = (double)w / (xno-1);
   fdy = (double)h / (yno-1);
   for(int i=0 ; i<yno ; i++) {
      dy = i * fdy;
      imType3->Canvas->Pen->Color = clGray;
      imType3->Canvas->Pen->Style = bsSolid;
      imType3->Canvas->Pen->Width = 2;
      if(dy == 0)
         dy = 1;
      if(dy >= h)
         dy = h - 1;
      imType3->Canvas->MoveTo(1,dy);
      imType3->Canvas->LineTo(w-1,dy);
   }
   for(int i=0 ; i<xno ; i++) {
      dx = i * fdx;
      imType3->Canvas->Pen->Color = clGray;
      imType3->Canvas->Pen->Style = bsSolid;
      imType3->Canvas->Pen->Width = 2;
      if(dx == 0)
         dx = 1;
      if(dx >= w)
         dx = w - 1;
      imType3->Canvas->MoveTo(dx,1);
      imType3->Canvas->LineTo(dx,h-1);
   }

}
//---------------------------------------------------------------------------
// Draw 圓
void __fastcall TfrnMain::btnType2DrawClick(TObject *Sender)
{
double ddegree,degree,theta;
int w,h,no,tno,x1,y1,x2,y2,cx,cy,rx,ry,dr;

   w = imType2->Width;
   h = imType2->Height;
   no = edType2TNo->Text.ToInt();
   tno = edType2TNo->Text.ToInt();
   ddegree = 360.0 / tno;
   x1 = 5;
   y1 = 5;
   x2 = w - 5;
   y2 = h - 5;
   cx = (x1+x2)/2;
   cy = (y1+y2)/2;
   dr = (x2-x1)/2;

   // 先填上顏色
   imType2->Canvas->Brush->Style = bsSolid;
   imType2->Canvas->Pen->Style = psSolid;
   imType2->Canvas->Pen->Color = clBtnFace;
   imType2->Canvas->Brush->Color = clBtnFace;
   imType2->Canvas->Rectangle(0,0,w,h);
   imType2->Canvas->Pen->Width = 2;

   // 圓
   imType2->Canvas->Pen->Color = clGray;
   imType2->Canvas->Pen->Style = bsSolid;
   imType2->Canvas->Ellipse(1,1,w-1,h-1);

   // 點
   for(int i=0 ; i<tno ; i++) {
      degree = i * ddegree;
      theta = degree * 2 * M_PI / 360;
      rx = dr * cos(theta);
      ry = dr * sin(theta);
      rx = 0 - rx;
      rx += cx;
      ry += cy;
      imType2->Canvas->Ellipse(rx-3,ry-3,rx+3,ry+3);
   }

}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::cbBit3Click(TObject *Sender)
{

   WriteDO(IO1_ID);        
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::rgZSourceChange(TObject *Sender, int ButtonIndex)
{
TIniFile *pSystemFile;

   // ini檔名與目錄: LaserMotion.ini
   pSystemFile = new TIniFile(SystemINIFilename);
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,"Joystick Z Source"     ,rgZSource->ItemIndex);
   JoystickZSource = rgZSource->ItemIndex;
   delete pSystemFile;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::cbJoystickYDirectionClick(TObject *Sender)
{
TIniFile *pSystemFile;

   // ini檔名與目錄: LaserMotion.ini
   pSystemFile = new TIniFile(SystemINIFilename);
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,"Joystick Y Direction"     ,cbJoystickYDirection->Checked);
   boolJoystickYDirection = cbJoystickYDirection->Checked;
   delete pSystemFile;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::cbJoystick2LockZClick(TObject *Sender)
{
TIniFile *pSystemFile;

   // ini檔名與目錄: LaserMotion.ini
   pSystemFile = new TIniFile(SystemINIFilename);
   pSystemFile->WriteInteger(MOTION_INFORMATION_SECTION,"Joystick 2 LockZ"     ,cbJoystick2LockZ->Checked);
   boolJoystick2LockZ = cbJoystick2LockZ->Checked;
   delete pSystemFile;
}
//---------------------------------------------------------------------------
// Macro - 1 X/Y Home
// ID5- DO21/27
// ID3- DI05/07
void __fastcall TfrnMain::btnMacroXYHomeClick(TObject *Sender)
{
int timeout,cnt;

// 2022 9 5 - chc 再確認一次
bool boolrecheck = false;

//   tsDI->Enabled = false;

   // 2022 9 5 - chc 改成每次50ms
   //timeout = 1000;
   // 2022 9 12 - chc 改成100ms
   //timeout = 200-50;
   timeout = 100-20;

   cnt = 0;

   pnlDIMsg->Caption = "";
   pnlMacroXYHome->Color = clSilver;
   pnlMacroXYHome->Refresh();
   pnlDIMsg->Caption = "XY Home...";

   // Reset ID5 DO21/27
   cbID5Bit21->Checked = false;
   cbID5Bit27->Checked = false;
   WriteDO(IO3_ID);
   //Sleep(100);
   // 2022 8 16 - chc 減半
   //WaitTime(100);
   WaitTimeMacro(50);

   // Set ID5 DO21/27
   cbID5Bit21->Checked = true;
   //Sleep(50);
   WaitTimeMacro(50);
   cbID5Bit27->Checked = true;
   WriteDO(IO3_ID);
   //Sleep(50);

   // 2022 9 22 - chc 加長, IO可能尚未反應
   //WaitTimeMacro(50);
   WaitTimeMacro(150);

   // Check ID3 DI05/07
   while(1) {
      if((pnlID3Bit5->Color == clLime && pnlID3Bit7->Color == clLime) || (HSL_DI_InStatus2[5] == true && HSL_DI_InStatus2[7] == true)) {
         pnlMacroXYHome->Color = clLime;
         pnlDIMsg->Caption = "XY Home ok.";
         pnlMacroXYHome->Refresh();
         break;
      }

      // 2022 9 5 - chc 改成每次50ms
      //WaitTime(10);
      // 2022 9 12 - chc 改成100ms
      //WaitTime(50);
      WaitTimeMacro(100);

      cnt++;
      if(cnt > timeout) {

         // 2022 9 5 - chc 再確認一次
         if(boolrecheck == false) {
            if(boolInMotionUpdate == false) {
               UpdateMotionStatus();
               boolrecheck = true;
               continue;
            }
            if(cnt < (timeout+20))
               continue;
         }

         // 2022 9 5 - chc 忽略Timeout
         if(cbMacroDemoIgnoreTimeout->Checked == true)
            pnlMacroXYHome->Color = clLime;
         else

            pnlMacroXYHome->Color = clRed;
         pnlMacroXYHome->Refresh();
         pnlDIMsg->Caption = "XY Home Timeout!";
         break;
      }
   }

   // Reset ID5 DO21/27
   cbID5Bit21->Checked = false;
   cbID5Bit27->Checked = false;
   WriteDO(IO3_ID);
   //Sleep(100);
   // 2022 8 16 - chc 減半
   //WaitTime(100);
   // 2022 8 24 - chc 再減半
   //WaitTime(50);
   WaitTimeMacro(25);
   tsDI->Enabled = true;
}
//---------------------------------------------------------------------------
// Z1 Down
// ID3- DO13
// ID3- DI12, 13
void __fastcall TfrnMain::btnMacroZ1DownClick(TObject *Sender)
{
int timeout,cnt;

// 2022 9 5 - chc 再確認一次
bool boolrecheck = false;

//   tsDI->Enabled = false;

   // 2022 9 5 - chc 改成每次50ms
   //timeout = 1000;
   // 2022 9 12 - chc 改成100ms
   //timeout = 200-50;
   // 2022 9 12a - chc 改成100ms => 縮短時間3sec就夠
   //timeout = 100-20;
   timeout = 20-5;

   // 2022 9 23 - chc Log
   WriteSystemLog("Z1(內環)下降...");

   cnt = 0;

   pnlDIMsg->Caption = "";
   pnlMacroZ1Down->Color = clSilver;
   pnlMacroZ1Down->Refresh();
   pnlDIMsg->Caption = "Z1 Down...";

   // Check ID3 DI05/07 - 是否已XY Home
   if((pnlID3Bit5->Color != clLime || pnlID3Bit7->Color != clLime)  || (HSL_DI_InStatus2[5] != true || HSL_DI_InStatus2[7] != true)) {
      pnlMacroZ1Down->Color = clRed;
      pnlDIMsg->Caption = "XY 尚未Home!";
      pnlMacroZ1Down->Refresh();
      goto err;
   }

   // Reset ID3 DO13
   cbID3Bit13->Checked = false;
   WriteDO(IO2_ID);
   //Sleep(100);
   // 2022 8 16 - chc 減半
   //WaitTime(100);
   // 2022 8 24 - chc 再減半
   //WaitTime(50);
   WaitTimeMacro(25);

   // Set ID5 DO21/27
   cbID3Bit13->Checked = true;
   WriteDO(IO2_ID);
   //Sleep(50);
   // 2022 8 16 - chc 減半
   //WaitTime(200);
   // 2022 8 24 - chc 再減半
   //WaitTime(100);

   // 2022 9 22 - chc 加長, IO可能尚未反應
   //WaitTimeMacro(50);
   WaitTimeMacro(150);

   // 2022 9 23 - chc 記錄是否在做Z1 Down
   boolZ1InDown = true;

   // Check ID3 DI12/13
   while(1) {
      if((pnlID3Bit12->Color == clLime && pnlID3Bit13->Color == clLime) || (HSL_DI_InStatus2[12] == true && HSL_DI_InStatus2[13] == true)) {
         pnlMacroZ1Down->Color = clLime;
         pnlDIMsg->Caption = "Z1 Down ok.";
         WriteSystemLog(pnlDIMsg->Caption);
         pnlMacroZ1Down->Refresh();
         break;
      }

      // 2022 9 5 - chc 改成每次50ms
      //WaitTime(10);
      // 2022 9 12 - chc 改成100ms
      //WaitTime(50);
      WaitTimeMacro(100);

      cnt++;
      if(cnt > timeout) {

         // 2022 9 5 - chc 再確認一次
         if(boolrecheck == false) {
            if(boolInMotionUpdate == false) {
               UpdateMotionStatus();
               boolrecheck = true;
               continue;
            }

            // 2022 9 23 - chc Log
            else
               WriteSystemLog("Z1(內環)下降, DIO更新中!");

            if(cnt < (timeout+5))
               continue;
         }

         // 2022 9 5 - chc 忽略Timeout
         if(cbMacroDemoIgnoreTimeout->Checked == true)
            pnlMacroZ1Down->Color = clLime;
         else

            pnlMacroZ1Down->Color = clRed;
         pnlMacroZ1Down->Refresh();
         pnlDIMsg->Caption = "Z1 Down Timeout!";
         WriteSystemLog(pnlDIMsg->Caption);
         break;
      }
   }

   // 2022 9 23 - chc 記錄是否在做Z1 Down
   boolZ1InDown = false;

   // Reset ID5 DO21/27
   cbID3Bit13->Checked = false;
   WriteDO(IO2_ID);
   //Sleep(100);
   // 2022 8 16 - chc 減半
   //WaitTime(100);
   // 2022 8 24 - chc 再減半
   //WaitTime(50);
   WaitTimeMacro(35);
err:
   tsDI->Enabled = true;
}
//---------------------------------------------------------------------------
// T1 Reset
// ID5- DO10
void __fastcall TfrnMain::btnMacroT1ResetClick(TObject *Sender)
{

//   tsDI->Enabled = false;
   pnlMacroT1Reset->Color = clSilver;
   // Set ID5 DO10
   cbID5Bit10->Checked = true;
   WriteDO(IO3_ID);

   //Sleep(100);
   // 2022 8 16 - chc 減半
   //WaitTime(100);
   WaitTimeMacro(50);

   cbID5Bit10->Checked = false;
   WriteDO(IO3_ID);
   pnlMacroT1Reset->Color = clLime;
   tsDI->Enabled = true;
}
//---------------------------------------------------------------------------
// 2022 9 15a - chc Loop取片後Demo要忽略
bool boolInLoopMacroZ2Up = false;

// Z2 Up
// ID3- DO06,07,05
// ID3- DI09,10(No)
//   確認sensor觸發(Di-113[ID3-DI13])=>
//          MBL上升到取片位(Do-107[ID3-DO07]->Do-105[ID3-DO05]),確認完成(Di-109[ID3-DI09])=>
//          關閉內環Vacuum(Do-01[ID1-DO01]),開啟外環Vacuum(Do-02[ID1-DO02])=>
//          MBL上升到最上位(Do-106[ID3-DO06]+Do-107[ID3-DO07]->Do-105[ID3-DO05]),確認完成(Di-109[ID3-DI09])=>
//          MBR正轉(DO-116[ID5-DO00]),反轉(DO-117[ID5-DO01])
void __fastcall TfrnMain::btnMacroZ2UpClick(TObject *Sender)
{
int timeout,cnt;

// 2022 9 5 - chc 再確認一次
bool boolrecheck = false;

//   tsDI->Enabled = false;

   // 2022 9 5 - chc 改成每次50ms
   //timeout = 2000;
   timeout = 400-50;

   cnt = 0;

   pnlDIMsg->Caption = "";
   pnlMacroZ2Up->Color = clSilver;
   pnlMacroZ2Up->Refresh();
   pnlDIMsg->Caption = "Z2 Up...";

   WriteSystemLog(pnlDIMsg->Caption);

   /* 分段作業
   // Reset ID3 DO6,7,5
   cbID3Bit6->Checked = false;
   cbID3Bit7->Checked = false;
   cbID3Bit5->Checked = false;
   WriteDO(IO2_ID);
   //Sleep(100);
   WaitTime(100);

   // Set ID3 DO6,7,5
   cbID3Bit6->Checked = true;
   //Sleep(50);
   WaitTime(50);
   cbID3Bit7->Checked = true;
   //Sleep(50);
   WaitTime(50);
   cbID3Bit5->Checked = true;
   WriteDO(IO2_ID);
   //Sleep(50);
   WaitTime(200);

   // Check ID3 DI9/10(No)
   while(1) {
      if(pnlID3Bit9->Color == clLime && pnlID3Bit10->Color != clLime) {
         pnlMacroZ2Up->Color = clLime;
         pnlDIMsg->Caption = "Z2 Up ok.";
         break;
      }
      //Sleep(10);
      WaitTime(10);
      cnt++;
      if(cnt > timeout) {
         pnlMacroZ2Up->Color = clRed;
         pnlDIMsg->Caption = "Z2 Up Timeout!";
         break;
      }
   }

   // Reset ID3 DO6/7/5
   cbID3Bit6->Checked = false;
   cbID3Bit7->Checked = false;
   cbID3Bit5->Checked = false;
   WriteDO(IO2_ID);
   //Sleep(100);
   WaitTime(100);
   tsDI->Enabled = true;
   */

   // 確認在下位ID3-DI13
   // 2022 9 15a - chc 看DI: HSL_DI_InStatus2[13]
   //if(pnlID3Bit13->Color != clLime) {
   if(HSL_DI_InStatus2[13] != true) {

      pnlMacroZ2Up->Color = clRed;
      pnlDIMsg->Caption = "Z1 不在下位!";
      WriteSystemLog(">>Macro Demo: Z2 Up, Z1不在下位!");
      pnlMacroZ2Up->Refresh();

      // 2022 9 15a - chc Loop取片後Demo要忽略: boolInLoopMacroZ2Up
      // ==> 有問題, 不做
      //if(boolInLoopMacroZ2Up == true) {
      //   WriteSystemLog(">>Macro Demo: Z2 Up, oop取片後Demo要忽略");
      //}
      //else

         goto err;
   }

   // Reset ID3 DO6,7,5
   cbID3Bit6->Checked = false;
   cbID3Bit7->Checked = false;
   cbID3Bit5->Checked = false;
   WriteDO(IO2_ID);
   // 2022 8 16 - chc 減半
   //WaitTime(100);
   // 2022 8 24 - chc 再減半
   //WaitTime(50);
   WaitTimeMacro(25);

   // Switch Vacuum: 關內, 1000ms
   cbBit1->Checked = false;
   WriteDO(IO1_ID);
   // 2022 8 16 - chc 減半
   //WaitTime(200);
   // 2022 8 24 - chc 再減半
   //WaitTime(100);
   WaitTimeMacro(50);

   // 往上到第一段
   // Set ID3 DO7/5
   cbID3Bit7->Checked = true;
   WriteDO(IO2_ID);
   // 2022 8 24 - chc 再減半
   //WaitTime(50);
   WaitTimeMacro(25);
   cbID3Bit5->Checked = true;
   WriteDO(IO2_ID);
   // 2022 8 16 - chc 減半
   //WaitTime(200);
   // 2022 8 24 - chc 再減半
   //WaitTime(100);

   // 2022 9 22 - chc 加長, IO可能尚未反應
   //WaitTime(50);
   WaitTime(150);

   // Check ID3 DI9
   while(1) {

      // 2022 9 15a - chc 看DI: HSL_DI_InStatus2[13]
      //if(pnlID3Bit9->Color == clLime) {
      if(HSL_DI_InStatus2[9] == true) {

         pnlMacroZ2Up->Color = clGreen;
         pnlDIMsg->Caption = "Z2 Up Phase1 ok.";
         WriteSystemLog(pnlDIMsg->Caption);
         pnlMacroZ2Up->Refresh();
         break;
      }

      // 2022 9 5 - chc 改成每次50ms
      //WaitTime(10);
      // 2022 9 22 - chc 改成每次100ms
      //WaitTimeMacro(50);
      WaitTimeMacro(100);

      cnt++;
      if(cnt > timeout) {

         // 2022 9 5 - chc 再確認一次
         if(boolrecheck == false) {
            if(boolInMotionUpdate == false) {
               UpdateMotionStatus();
               boolrecheck = true;
               continue;
            }
            if(cnt < (timeout+50))
               continue;
         }

         // 2022 9 5 - chc 忽略Timeout
         if(cbMacroDemoIgnoreTimeout->Checked == true) {
            pnlMacroZ2Up->Color = clLime;
            pnlDIMsg->Caption = "Z2 Up Phase1 Timeout! 強制為true";
            WriteSystemLog(pnlDIMsg->Caption);
         }
         else {

            pnlMacroZ2Up->Color = clRed;
            pnlDIMsg->Caption = "Z2 Up Phase1 Timeout!";
            WriteSystemLog(pnlDIMsg->Caption);
         }
         pnlMacroZ2Up->Refresh();
         break;
      }
   }
   cbID3Bit7->Checked = false;
   cbID3Bit5->Checked = false;
   WriteDO(IO2_ID);
   // 2022 8 16 - chc 減半
   //WaitTime(200);
   // 2022 8 24 - chc 再減半
   //WaitTime(100);
   WaitTimeMacro(50);
   if(pnlID3Bit9->Color != clLime)
      goto err;

   // Switch Vacuum: 開外, 1000ms
   cbBit2->Checked = true;
   WriteDO(IO1_ID);
   // 2022 8 15 - chc 改成200
   //WaitTime(1000);
   // 2022 8 24 - chc 再減半
   //WaitTime(200);
   WaitTimeMacro(100);

   // Set ID3 DO6,7,5
   cbID3Bit6->Checked = true;
   // 2022 8 16 - chc 減半
   //WaitTime(50);
   WaitTimeMacro(20);
   WriteDO(IO2_ID);
   cbID3Bit7->Checked = true;
   // 2022 8 16 - chc 減半
   //WaitTime(50);
   WaitTimeMacro(20);
   WriteDO(IO2_ID);
   cbID3Bit5->Checked = true;
   WriteDO(IO2_ID);
   // 2022 8 16 - chc 減半
   //WaitTime(200);
   WaitTimeMacro(100);
   // Check ID3 DI9
   while(1) {
      if((pnlID3Bit9->Color == clLime && pnlID3Bit10->Color != clLime) || (HSL_DI_InStatus2[9] == true && HSL_DI_InStatus2[10] != true)) {
         pnlMacroZ2Up->Color = clLime;
         pnlDIMsg->Caption = "Z2 Up Phase2 ok.";
         WriteSystemLog(pnlDIMsg->Caption);
         pnlMacroZ2Up->Refresh();
         break;
      }

      // 2022 9 22 - chc 改成每次100ms
      //WaitTimeMacro(10);
      WaitTimeMacro(100);

      cnt++;
      if(cnt > timeout) {

         // 2022 9 5 - chc 忽略Timeout
         if(cbMacroDemoIgnoreTimeout->Checked == true) {
            pnlMacroZ2Up->Color = clLime;
            pnlDIMsg->Caption = "Z2 Up Phase2 Timeout! 強制為true";
            WriteSystemLog(pnlDIMsg->Caption);
         }
         else {

            pnlMacroZ2Up->Color = clRed;
            pnlDIMsg->Caption = "Z2 Up Phase2 Timeout!";
            WriteSystemLog(pnlDIMsg->Caption);
         }
         pnlMacroZ2Up->Refresh();
         break;
      }
   }
   cbID3Bit6->Checked = false;
   cbID3Bit7->Checked = false;
   cbID3Bit5->Checked = false;
   WriteDO(IO2_ID);
   // 2022 8 16 - chc 減半
   //WaitTime(200);
   // 2022 8 24 - chc 再減半
   //WaitTime(100);
   WaitTimeMacro(50);

err:
   tsDI->Enabled = true;
}
//---------------------------------------------------------------------------
// Z2 Home
// ID5- DO05
// ID3- DI01,02
void __fastcall TfrnMain::btnMacroZ2HomeClick(TObject *Sender)
{
int timeout,cnt;

// 2022 9 5 - chc 再確認一次
bool boolrecheck = false;

//   tsDI->Enabled = false;

   // 2022 9 5 - chc 改成每次50ms
   //timeout = 2000;
   timeout = 400-50;

   cnt = 0;

   pnlDIMsg->Caption = "";
   pnlMacroZ2Home->Color = clSilver;
   pnlMacroZ2Home->Refresh();
   pnlDIMsg->Caption = "Z2 Home...";

   // Reset ID5 DO05
   cbID5Bit5->Checked = false;
   WriteDO(IO3_ID);
   //Sleep(100);
   // 2022 8 16 - chc 減半
   //WaitTime(100);
   // 2022 8 24 - chc 再減半
   //WaitTime(50);
   WaitTimeMacro(25);

   // Set ID5 DO05
   cbID5Bit5->Checked = true;
   WriteDO(IO3_ID);
   //Sleep(50);
   // 2022 8 16 - chc 減半
   //WaitTime(300);
   // 2022 8 24 - chc 再減半
   //WaitTime(150);

   // 2022 9 22 - chc 加長, IO可能尚未反應
   //WaitTimeMacro(75);
   WaitTimeMacro(150);

   // Check ID3 DI9/10(No)
   while(1) {
      if((pnlID3Bit1->Color == clLime && pnlID3Bit2->Color == clLime) || (HSL_DI_InStatus2[1] == true && HSL_DI_InStatus2[2] == true)) {
         pnlMacroZ2Home->Color = clLime;
         pnlDIMsg->Caption = "Z2 Home ok.";
         pnlMacroZ2Home->Refresh();
         break;
      }

      // 2022 9 5 - chc 改成每次50ms
      //WaitTime(10);
      // 2022 9 23 - chc 改成每次100ms
      //WaitTimeMacro(50);
      WaitTimeMacro(100);

      cnt++;
      if(cnt > timeout) {

         // 2022 9 5 - chc 再確認一次
         if(boolrecheck == false) {
            if(boolInMotionUpdate == false) {
               UpdateMotionStatus();
               boolrecheck = true;
               continue;
            }
            if(cnt < (timeout+50))
               continue;
         }

         // 2022 9 5 - chc 忽略Timeout
         if(cbMacroDemoIgnoreTimeout->Checked == true)
            pnlMacroZ2Home->Color = clLime;
         else

            pnlMacroZ2Home->Color = clRed;
         pnlMacroZ2Home->Refresh();
         pnlDIMsg->Caption = "Z2 Home Timeout!";
         break;
      }
   }

   // Reset ID3 DO6/7/5
   cbID5Bit5->Checked = false;
   WriteDO(IO3_ID);
   //Sleep(100);
   // 2022 8 16 - chc 減半
   //WaitTime(100);
   // 2022 8 24 - chc 再減半
   //WaitTime(50);
   WaitTimeMacro(25);
   tsDI->Enabled = true;
}
//---------------------------------------------------------------------------
// Z2 down
// ID3- DO05
// ID3- DI09,10
//   5. => MBL下降到放片位(Do-106[ID3-DO06]->Do-105[ID3-DO05]),確認完成(Di-109[ID3-DI09])=>
//          關閉外環Vacuum(Do-02[ID1-DO02]),開啟內環Vacuum(Do-01[ID1-DO01])=>
//          MBL下降到最下位(Do-105[ID3-DO05]),確認完成(Di-109[ID3-DI09]),sensor觸發(Di-110[ID3-DI10])
void __fastcall TfrnMain::btnMacroZ2DownClick(TObject *Sender)
{
int timeout,cnt;

// 2022 9 5 - chc 再確認一次
bool boolrecheck = false;

//   tsDI->Enabled = false;

   // 2022 9 5 - chc 改成每次50ms
   //timeout = 2000;
   timeout = 400-50;

   cnt = 0;

   pnlDIMsg->Caption = "";
   pnlMacroZ2Down->Color = clSilver;
   pnlMacroZ2Down->Refresh();
   pnlDIMsg->Caption = "Z2 Down...";

   // 檢查ID3- DI01/02是否為On, 否則要做Z2 Home
   if((pnlID3Bit1->Color != clLime || pnlID3Bit2->Color != clLime) || (HSL_DI_InStatus2[1] != true || HSL_DI_InStatus2[2] != true)) {
      btnMacroZ2HomeClick(this);
      if(pnlMacroZ2Home->Color != clLime) {
         pnlMacroZ2Down->Color = clRed;
         pnlDIMsg->Caption = "Z2 Home Fail!";
         pnlMacroZ2Down->Refresh();
         return;
      }
   }

   // Reset ID3 DO13
   cbID3Bit5->Checked = false;
   WriteDO(IO2_ID);
   //Sleep(100);
   // 2022 8 16 - chc 減半
   //WaitTime(100);
   // 2022 8 24 - chc 再減半
   //WaitTime(50);
   WaitTimeMacro(25);

   /* 分段作業
   // Set ID5 DO21/27
   cbID3Bit5->Checked = true;
   WriteDO(IO2_ID);
   //Sleep(50);
   WaitTime(50);

   // Check ID3 DI9/10(No)
   while(1) {
      if(pnlID3Bit9->Color == clLime && pnlID3Bit10->Color == clLime) {
         pnlMacroZ2Down->Color = clLime;
         pnlDIMsg->Caption = "Z2 Down ok.";
         break;
      }
      //Sleep(10);
      WaitTime(10);
      cnt++;
      if(cnt > timeout) {
         pnlMacroZ2Down->Color = clRed;
         pnlDIMsg->Caption = "Z2 Down Timeout!";
         break;
      }
   }

   // Reset ID3 DO6/7/5
   cbID3Bit5->Checked = false;
   WriteDO(IO2_ID);
   //Sleep(100);
   WaitTime(100);
   tsDI->Enabled = true;
   */

   // 確認Z2在上位ID3-DI9(on), 10(off)
   if((pnlID3Bit9->Color != clLime || pnlID3Bit10->Color == clLime) || (HSL_DI_InStatus2[9] != true || HSL_DI_InStatus2[10] == true)) {
      pnlMacroZ2Down->Color = clRed;
      pnlDIMsg->Caption = "Z2 不在上位!";
      pnlMacroZ2Down->Refresh();
      goto err;
   }

   // Reset ID3 DO6,7,5
   cbID3Bit6->Checked = false;
   cbID3Bit7->Checked = false;
   cbID3Bit5->Checked = false;
   WriteDO(IO2_ID);
   // 2022 8 16 - chc 減半
   //WaitTime(100);
   // 2022 8 24 - chc 再減半
   //WaitTime(50);
   WaitTimeMacro(25);

   // 往下到第一段
   // Set ID3 DO6/5
   cbID3Bit6->Checked = true;
   WriteDO(IO2_ID);
   // 2022 8 24 - chc 再減半
   //WaitTime(50);
   WaitTimeMacro(25);
   cbID3Bit5->Checked = true;
   WriteDO(IO2_ID);
   // 2022 8 16 - chc 減半
   //WaitTime(200);
   // 2022 8 24 - chc 再減半
   //WaitTime(100);

   // 2022 9 22 - chc 加長, IO可能尚未反應
   //WaitTimeMacro(50);
   WaitTimeMacro(150);

   // Check ID3 DI9
   while(1) {
      if(pnlID3Bit9->Color == clLime) {
         pnlMacroZ2Down->Color = clGreen;
         pnlDIMsg->Caption = "Z2 Down Phase1 ok.";
         pnlMacroZ2Down->Refresh();
         break;
      }

      // 2022 9 5 - chc 改成每次50ms
      //WaitTime(10);
      // 2022 9 23 - chc 改成每次100ms
      //WaitTimeMacro(50);
      WaitTimeMacro(100);

      cnt++;
      if(cnt > timeout) {

         // 2022 9 5 - chc 再確認一次
         if(boolrecheck == false) {
            if(boolInMotionUpdate == false) {
               UpdateMotionStatus();
               boolrecheck = true;
               continue;
            }
            if(cnt < (timeout+50))
               continue;
         }

         // 2022 9 5 - chc 忽略Timeout
         if(cbMacroDemoIgnoreTimeout->Checked == true)
            pnlMacroZ2Down->Color = clLime;
         else

            pnlMacroZ2Down->Color = clRed;
         pnlMacroZ2Down->Refresh();
         pnlDIMsg->Caption = "Z2 Down Phase1 Timeout!";
         break;
      }
   }
   cbID3Bit6->Checked = false;
   cbID3Bit5->Checked = false;
   WriteDO(IO2_ID);
   // 2022 8 16 - chc 減半
   //WaitTime(200);
   // 2022 8 24 - chc 再減半
   //WaitTime(100);
   WaitTimeMacro(50);
   if(pnlID3Bit9->Color != clLime)
      goto err;

   // Switch Vacuum: 關外開內, 1000ms
   cbBit1->Checked = true;
   cbBit2->Checked = false;
   WriteDO(IO1_ID);
   // 2022 8 15 - chc 改成200
   //WaitTime(1000);
   // 2022 8 16 - chc 減半
   //WaitTime(200);
   // 2022 8 24 - chc 再減半
   //WaitTime(100);
   WaitTimeMacro(50);

   // Set ID3 DO5
   cbID3Bit5->Checked = true;
   WriteDO(IO2_ID);
   // 2022 8 16 - chc 減半
   //WaitTime(200);
   // 2022 8 24 - chc 再減半
   //WaitTime(100);
   WaitTimeMacro(50);
   // Check ID3 DI9,10
   while(1) {
      if(pnlID3Bit9->Color == clLime && pnlID3Bit10->Color == clLime) {
         pnlMacroZ2Down->Color = clLime;
         pnlDIMsg->Caption = "Z2 Down Phase2 ok.";
         pnlMacroZ2Down->Refresh();
         break;
      }
      WaitTime(10);
      cnt++;
      if(cnt > timeout) {
         pnlMacroZ2Down->Color = clRed;
         pnlDIMsg->Caption = "Z2 Down Phase2 Timeout!";
         pnlMacroZ2Down->Refresh();
         break;
      }
   }
   cbID3Bit5->Checked = false;
   WriteDO(IO2_ID);
   // 2022 8 16 - chc 減半
   //WaitTime(200);
   // 2022 8 24 - chc 再減半
   //WaitTime(100);
   WaitTimeMacro(50);

err:
   tsDI->Enabled = true;

}
//---------------------------------------------------------------------------

// Z1 Up
// ID3- DO15/13
// ID3- DI12, 13
void __fastcall TfrnMain::btnMacroZ1UpClick(TObject *Sender)
{
int timeout,cnt;

// 2022 9 5 - chc 再確認一次
bool boolrecheck = false;

//   tsDI->Enabled = false;

   // 2022 9 5 - chc 改成每次50ms
   //timeout = 1000;
   // 2022 9 12 - chc 改成100ms
   //timeout = 200-50;
   // 2022 9 12a - chc 改成100ms => 縮短時間3sec就夠
   //timeout = 100-20;
   timeout = 20-5;

   // 2022 9 12a - chc Log
   WriteSystemLog("Z1(內環)上升...");

   cnt = 0;

   pnlDIMsg->Caption = "";
   pnlMacroZ1Up->Color = clSilver;
   pnlMacroZ1Up->Refresh();
   pnlDIMsg->Caption = "Z1 Up...";

   // Reset ID3 DO13
   cbID3Bit13->Checked = false;
   cbID3Bit15->Checked = false;
   WriteDO(IO2_ID);
   //Sleep(100);
   // 2022 8 16 - chc 減半
   //WaitTime(100);
   // 2022 8 24 - chc 再減半
   //WaitTime(50);
   WaitTimeMacro(25);

   // Set ID5 DO21/27
   cbID3Bit15->Checked = true;
   //Sleep(50);
   // 2022 8 24 - chc 再減半
   //WaitTime(50);
   WaitTimeMacro(25);
   WriteDO(IO2_ID);
   cbID3Bit13->Checked = true;
   WriteDO(IO2_ID);
   //Sleep(50);
   // 2022 8 16 - chc 減半
   //WaitTime(200);
   // 2022 8 24 - chc 再減半
   //WaitTime(100);

   // 2022 9 22 - chc 加長, IO可能尚未反應
   //WaitTimeMacro(50);
   WaitTimeMacro(150);

   // 2022 9 12a - chc Log
   WriteSystemLog("Z1(內環)上升, 等待DI...");

   // 2022 9 15 - chc 記錄是否在做Z1 Up
   boolZ1InUp = true;

   // Check ID3 DI12/13
   while(1) {
      if((pnlID3Bit12->Color == clLime && pnlID3Bit13->Color != clLime) || (HSL_DI_InStatus2[12] == true && HSL_DI_InStatus2[13] != true)) {
         pnlMacroZ1Up->Color = clLime;
         pnlDIMsg->Caption = "Z1 Up ok.";
         pnlMacroZ1Up->Refresh();

         // 2022 9 12a - chc Log
         WriteSystemLog("Z1(內環)上升: ok.");

         break;
      }

      // 2022 9 5 - chc 改成每次50ms
      //WaitTime(10);
      // 2022 9 12 - chc 改成100ms
      //WaitTime(50);
      WaitTimeMacro(100);

      cnt++;
      if(cnt > timeout) {

         // 2022 9 5 - chc 再確認一次
         if(boolrecheck == false) {
            if(boolInMotionUpdate == false) {
               UpdateMotionStatus();
               boolrecheck = true;
               continue;
            }

            // 2022 9 23 - chc Log
            else
               WriteSystemLog("Z1(內環)上升, DIO更新中!");

            if(cnt < (timeout+5))
               continue;
         }

         // 2022 9 5 - chc 忽略Timeout
         if(cbMacroDemoIgnoreTimeout->Checked == true) {
            pnlMacroZ1Up->Color = clLime;
            pnlDIMsg->Caption = "Z1 Up Timeout! 但強制為Ok";
            WriteSystemLog("Z1(內環)上升: Timeout! 但強制為Ok");
            pnlID3Bit12->Color = clLime;
            pnlID3Bit13->Color = clSilver;
         }
         else {

            pnlMacroZ1Up->Color = clRed;

            pnlDIMsg->Caption = "Z1 Up Timeout!";

            // 2022 9 12a - chc Log
            WriteSystemLog("Z1(內環)上升: Timeout!");
         }
         pnlMacroZ1Up->Refresh();
         break;
      }
   }

   // 2022 9 15 - chc 記錄是否在做Z1 Up
   boolZ1InUp = false;

   // Reset ID5 DO21/27
   cbID3Bit13->Checked = false;
   cbID3Bit15->Checked = false;
   WriteDO(IO2_ID);
   //Sleep(100);
   // 2022 8 16 - chc 減半
   //WaitTime(100);
   // 2022 8 24 - chc 再減半
   //WaitTime(50);
   WaitTimeMacro(25);
   tsDI->Enabled = true;
}
//---------------------------------------------------------------------------
// Macro Home
void __fastcall TfrnMain::btnMacroHomeClick(TObject *Sender)
{

   WriteSystemLog(">btnMacroHomeClick()Enter");
//   tsDI->Enabled = false;
   pnlDIMsg->Caption = "";
   pnlMacroHome->Color = clSilver;

   // 2022 12 22 - chc Tazmo
   if(RobotMode == ROBOT_MODE_TAZMO) {
      btnMacroWithWaferClick(this);
      if(pnlMacroWithWafer->Color == clLime) {
         if(Application->MessageBox("Macro上有Wafer, 續做Home?       ", "Home Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
            goto err;
         }
      }
   }

   // XY Home
   btnMacroXYHomeClick(this);
   if(pnlMacroXYHome->Color != clLime) {
      pnlDIMsg->Caption = "Macro Home: XYHome Fail!";
      pnlMacroHome->Color = clRed;
      goto err;
   }
   if(cbDemoStep->Checked == true) {
      if(Application->MessageBox("續做2?      ", "Home Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         goto err;
      }
   }

   // Z1 Down
   // 2022 12 22 - chc Tazmo
   if(RobotMode != ROBOT_MODE_TAZMO) {
      btnMacroZ1DownClick(this);
      if(pnlMacroZ1Down->Color != clLime) {
         pnlDIMsg->Caption = "Macro Home: Z1 Down Fail!";
         pnlMacroHome->Color = clRed;
         goto err;
      }
      if(cbDemoStep->Checked == true) {
         if(Application->MessageBox("續做3?      ", "Home Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
            goto err;
         }
      }
   }

   // T1 Reset
   btnMacroT1ResetClick(this);
   if(pnlMacroT1Reset->Color != clLime) {
      pnlDIMsg->Caption = "Macro Home: T1 Reset Fail!";
      pnlMacroHome->Color = clRed;
      goto err;
   }
   if(cbDemoStep->Checked == true) {
      if(Application->MessageBox("續做4?      ", "Home Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         goto err;
      }
   }

   // 2022 12 22 - chc Tazmo
   if(RobotMode != ROBOT_MODE_TAZMO) {
      // Z2 Up
      btnMacroZ2UpClick(this);
      if(pnlMacroZ2Up->Color != clLime) {
         pnlDIMsg->Caption = "Macro Home: Z2 Up Fail!";
         pnlMacroHome->Color = clRed;
         goto err;
      }
      if(cbDemoStep->Checked == true) {
         if(Application->MessageBox("續做5?      ", "Home Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
            goto err;
         }
      }

      // T2 Home
      btnMacroZ2HomeClick(this);
      if(pnlMacroZ2Home->Color != clLime) {
         pnlDIMsg->Caption = "Macro Home: T2 Home Fail!";
         pnlMacroHome->Color = clRed;
         goto err;
      }
      if(cbDemoStep->Checked == true) {
         if(Application->MessageBox("續做6?      ", "Home Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
            goto err;
         }
      }

      // Z2 Down
      btnMacroZ2DownClick(this);
      if(pnlMacroZ2Down->Color != clLime) {
         pnlDIMsg->Caption = "Macro Home: Z2 Down Fail!";
         pnlMacroHome->Color = clRed;
         goto err;
      }
   }

   WaitTime(100);

   // 2022 8 12 - chc Home完要關內外環真空, 因btnMacroZ2DownClick()會開環
   // 2022 12 22 - chc Tazmo
   if(RobotMode == ROBOT_MODE_TAZMO) {
      cbBit2->Checked = false;
      cbBit3->Checked = false;
   }
   else {

      cbBit1->Checked = false;
      cbBit2->Checked = false;
   }
   WriteDO(IO1_ID);
   WaitTime(100);

   // Check DI : ID3 DI00~DI13全亮, input_DI2
   if(CheckMacroReady() == true) {
      pnlDIMsg->Caption = "Macro Home: ok";
      pnlMacroHome->Color = clLime;
   }
   else {
      pnlDIMsg->Caption = "Macro Home: Fail!";
      pnlMacroHome->Color = clRed;
   }

err:
   tsDI->Enabled = true;

}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::cbID3Bit0Click(TObject *Sender)
{

   WriteDO(IO2_ID);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::cbID5Bit0Click(TObject *Sender)
{

   WriteDO(IO3_ID);
}
//---------------------------------------------------------------------------
// Wait time
void __fastcall TfrnMain::WaitTime(int no)
{
long starttime,stoptime,elapsedms;
short starttick,stoptick;
int cnt = 0;

   // 2022 9 23 - chc 進來與離開各做一次
   if(boolInMotionUpdate == false) {
      UpdateMotionStatus();
   }

   frnMain->GetTimeTic(&starttime,&starttick);
   while(1) {

      // 2022 9 23 - chc 進來與離開各做一次
      //if(boolInMotionUpdate == false) {
      //   UpdateMotionStatus();
      //}

      // 2022 9 22a - chc 不做看看
      // 2022 9 27 - chc 要做: 因不會更新其他: Robot RS232
      Application->ProcessMessages();

      // 2022 9 5 - chc 改成2, 因有時不會更新DI!!!
      // 2022 9 12a - chc 回到10ms, 不要太密集
      //Sleep(2);
      Sleep(10);

      cnt++;
      if(cnt >= 1) {
         cnt = 0;
         frnMain->GetTimeTic(&stoptime,&stoptick);
         elapsedms = ((stoptime*1000+stoptick) - (starttime*1000+starttick));
         if(elapsedms > no) {

            // 2022 9 23 - chc 進來與離開各做一次
            if(boolInMotionUpdate == false) {
               UpdateMotionStatus();
            }

            return;
         }
      }
   }
}
//---------------------------------------------------------------------------
// Z1 Down
void __fastcall TfrnMain::btnMacroRobotPositionClick(TObject *Sender)
{
int cnt = 0;

again:
   pnlDIMsg->Caption = "";
   pnlMacroRobotPosition->Color = clSilver;
   btnMacroZ1DownClick(this);
   if(pnlMacroZ1Down->Color != clLime) {
      if(pnlDIMsg->Caption == "XY 尚未Home!") {
         if(cnt == 0) {
            cnt++;
            // 先做XY Home
            btnMacroXYHomeClick(this);
            if(pnlMacroXYHome->Color == clLime) {
               goto again;
            }
         }
      }
      pnlDIMsg->Caption = "Macro Robot位置: Fail!";
      pnlMacroRobotPosition->Color = clRed;
   }
   else {
      // Check DI : ID3 DI00~DI13全亮, input_DI2
      if(CheckMacroReady() == true) {
         pnlDIMsg->Caption = "Macro Robot位置: ok.";
         pnlMacroRobotPosition->Color = clLime;
      }
      else {
         pnlDIMsg->Caption = "Macro Robot位置: Fail!";
         pnlMacroRobotPosition->Color = clRed;
      }
   }
}
//---------------------------------------------------------------------------
// Check DI : ID3 DI00~DI13全亮, input_DI2
bool __fastcall TfrnMain::CheckMacroReady()
{
I32 distatus;

   //distatus = GetDI(IO2_ID);
   distatus = input_DI2;

   // 2022 12 22 - chc Tazmo
   unsigned int checkcode;
   if(RobotMode == ROBOT_MODE_TAZMO)
      checkcode = 0x4080;
   else
      checkcode = 0x3fff;
   if((distatus & checkcode) == checkcode) {

   /*
   // 2022 12 22 - chc Tazmo: Only 5/7/14
   // 0100 0000 1010 0000 => 0x40A0
   //if((distatus & 0x3fff) == 0x3fff) {
   // 2022 12 22 - chc Tazmo: Only 7/14
   // 0100 0000 1000 0000 => 0x40A0
   //if((distatus & 0x40A0) == 0x40A0) {
   if((distatus & 0x4080) == 0x4080) {
   */

      return true;
   }
   else {
      return false;
   }
}
//---------------------------------------------------------------------------
// Check DI : ID3 DI00~DI13全亮, input_DI2
bool __fastcall TfrnMain::CheckMacroZ2Up()
{
I32 distatus;
AnsiString msg;

   //distatus = GetDI(IO2_ID);
   distatus = input_DI2;
   msg.sprintf("CheckMacroZ2Up() = %4X",distatus);
   WriteSystemLog(msg);
   if((distatus & 0x0400) == 0) {
      return true;
   }
   else {
      return false;
   }
}
//---------------------------------------------------------------------------
// Check DI : ID3 DI00~DI13全亮, input_DI2
bool __fastcall TfrnMain::CheckMacroZ1Up()
{
I32 distatus;
AnsiString msg;

   //distatus = GetDI(IO2_ID);
   distatus = input_DI2;
   msg.sprintf("CheckMacroZ1Up() = %4X",distatus);
   WriteSystemLog(msg);
   if((distatus & 0x2000) == 0) {
      return true;
   }
   else {
      return false;
   }
}
//---------------------------------------------------------------------------
// Z1 Up
void __fastcall TfrnMain::btnMacroReadyPositionClick(TObject *Sender)
{

   pnlDIMsg->Caption = "";
   pnlMacroReadyPosition->Color = clSilver;
   if(CheckMacroZ2Up() == true) {
      pnlDIMsg->Caption = "Macro Z2在上位!";
      pnlMacroReadyPosition->Color = clRed;
      return;
   }
   btnMacroZ1UpClick(this);
   if(pnlMacroZ1Up->Color != clLime) {
      pnlDIMsg->Caption = "Macro Z1 Up Fail!";
      pnlMacroReadyPosition->Color = clRed;
   }
   else {
      pnlDIMsg->Caption = "Macro Z1 Up ok.";
      pnlMacroReadyPosition->Color = clLime;
   }
}
//---------------------------------------------------------------------------
// Z1 Up
void __fastcall TfrnMain::btnMacroInnerPositionClick(TObject *Sender)
{

//   tsDI->Enabled = false;
   pnlDIMsg->Caption = "";
   pnlMacroInnerPosition->Color = clSilver;
   pnlMacroInnerPosition->Refresh();
   if(CheckMacroZ2Up() == true) {
      pnlDIMsg->Caption = "Macro Z2在上位!";
      pnlMacroInnerPosition->Color = clRed;
      WriteSystemLog("btnMacroInnerPositionClick: Macro Z2在上位!");
      pnlMacroInnerPosition->Refresh();
      return;
   }
   btnMacroZ1UpClick(this);
   if(pnlMacroZ1Up->Color != clLime) {
      pnlDIMsg->Caption = "Macro Z1 Up Fail!";
      pnlMacroInnerPosition->Color = clRed;
      WriteSystemLog("btnMacroInnerPositionClick: Macro Z1 Up Fail!");
      pnlMacroInnerPosition->Refresh();
   }
   else {
      pnlDIMsg->Caption = "Macro Z1 Up ok.";
      pnlMacroInnerPosition->Color = clLime;
      WriteSystemLog("btnMacroInnerPositionClick: Macro Z1 Up ok.");
      pnlMacroInnerPosition->Refresh();
   }
}
//---------------------------------------------------------------------------
// Jog 前: ID5- DO16
//   jog正轉(DO-132[ID5-DO16]), jog反轉(DO-133[ID5-DO17])
//   內環升降在最上位才可操作
void __fastcall TfrnMain::btnMacroInnerYMoveMouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   //tsDI->Enabled = false;
   pnlDIMsg->Caption = "";
   pnlMacroInnerYMove->Color = clSilver;

   // 2022 12 22 - chc Tazmo
   if(RobotMode != ROBOT_MODE_TAZMO) {
      if(CheckMacroZ1Up() == false) {
         pnlDIMsg->Caption = "Macro Z1不在上位!";
         pnlMacroInnerYMove->Color = clRed;
      }
      else if(CheckMacroZ2Up() == true) {
         pnlDIMsg->Caption = "Macro Z2在上位!";
         pnlMacroInnerYMove->Color = clRed;
      }
      else {
         // Reset ID5 DO16,17
         cbID5Bit16->Checked = true;
         cbID5Bit17->Checked = false;
         WriteDO(IO3_ID);
         pnlMacroInnerYMove->Color = clLime;
      }
   }
   else {

      cbID5Bit16->Checked = true;
      cbID5Bit17->Checked = false;
      WriteDO(IO3_ID);
      pnlMacroInnerYMove->Color = clLime;
   }
}
//---------------------------------------------------------------------------
// Jog 前-停
void __fastcall TfrnMain::btnMacroInnerYMoveMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   // Reset ID5 DO16,17
   cbID5Bit16->Checked = false;
   cbID5Bit17->Checked = false;
   WriteDO(IO3_ID);
   pnlMacroInnerYMove->Color = clSilver;
   //tsDI->Enabled = true;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnMacroInnerYBackMouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   //tsDI->Enabled = false;
   pnlDIMsg->Caption = "";
   pnlMacroInnerYBack->Color = clSilver;

   // 2022 12 22 - chc Tazmo
   if(RobotMode != ROBOT_MODE_TAZMO) {
      if(CheckMacroZ1Up() == false) {
         pnlDIMsg->Caption = "Macro Z1不在上位!";
         pnlMacroInnerYMove->Color = clRed;
      }
      else if(CheckMacroZ2Up() == true) {
         pnlDIMsg->Caption = "Macro Z2在上位!";
         pnlMacroInnerYBack->Color = clRed;
      }
      else {
         // Reset ID5 DO16,17
         cbID5Bit16->Checked = false;
         cbID5Bit17->Checked = true;
         WriteDO(IO3_ID);
         pnlMacroInnerYBack->Color = clLime;
      }
   }
   else {

      cbID5Bit16->Checked = false;
      cbID5Bit17->Checked = true;
      WriteDO(IO3_ID);
      pnlMacroInnerYBack->Color = clLime;
   }
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnMacroInnerYBackMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   // Reset ID5 DO16,17
   cbID5Bit16->Checked = false;
   cbID5Bit17->Checked = false;
   WriteDO(IO3_ID);
   pnlMacroInnerYBack->Color = clSilver;
   //tsDI->Enabled = true;
}
//---------------------------------------------------------------------------
// ID5- DO22,23
void __fastcall TfrnMain::btnMacroInnerXMoveMouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   //tsDI->Enabled = false;
   pnlDIMsg->Caption = "";
   pnlMacroInnerXMove->Color = clSilver;

   // 2022 12 22 - chc Tazmo
   if(RobotMode != ROBOT_MODE_TAZMO) {
      if(CheckMacroZ1Up() == false) {
         pnlDIMsg->Caption = "Macro Z1不在上位!";
         pnlMacroInnerYMove->Color = clRed;
      }
      else if(CheckMacroZ2Up() == true) {
         pnlDIMsg->Caption = "Macro Z2在上位!";
         pnlMacroInnerXMove->Color = clRed;
      }
      else {
         // Reset ID5 DO22,23
         cbID5Bit22->Checked = true;
         cbID5Bit23->Checked = false;
         WriteDO(IO3_ID);
         pnlMacroInnerXMove->Color = clLime;
      }
   }
   else {

      // Reset ID5 DO22,23
      cbID5Bit22->Checked = true;
      cbID5Bit23->Checked = false;
      WriteDO(IO3_ID);
      pnlMacroInnerXMove->Color = clLime;
   }
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnMacroInnerXMoveMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   // Reset ID5 DO22,23
   cbID5Bit22->Checked = false;
   cbID5Bit23->Checked = false;
   WriteDO(IO3_ID);
   pnlMacroInnerXMove->Color = clSilver;
   //tsDI->Enabled = true;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnMacroInnerXBackMouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   //tsDI->Enabled = false;
   pnlDIMsg->Caption = "";
   pnlMacroInnerXBack->Color = clSilver;

   // 2022 12 22 - chc Tazmo
   if(RobotMode != ROBOT_MODE_TAZMO) {
      if(CheckMacroZ1Up() == false) {
         pnlDIMsg->Caption = "Macro Z1不在上位!";
         pnlMacroInnerYMove->Color = clRed;
      }
      else if(CheckMacroZ2Up() == true) {
         pnlDIMsg->Caption = "Macro Z2在上位!";
         pnlMacroInnerXBack->Color = clRed;
      }
      else {
         // Reset ID5 DO22,23
         cbID5Bit22->Checked = false;
         cbID5Bit23->Checked = true;
         WriteDO(IO3_ID);
         pnlMacroInnerXBack->Color = clLime;
      }
   }
   else {

      // Reset ID5 DO22,23
      cbID5Bit22->Checked = false;
      cbID5Bit23->Checked = true;
      WriteDO(IO3_ID);
      pnlMacroInnerXBack->Color = clLime;
   }
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnMacroInnerXBackMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   // Reset ID5 DO22,23
   cbID5Bit22->Checked = false;
   cbID5Bit23->Checked = false;
   WriteDO(IO3_ID);
   pnlMacroInnerXBack->Color = clSilver;
   //tsDI->Enabled = true;
}
//---------------------------------------------------------------------------
// 內環旋轉 MSR jog正轉(DO-122[ID5-DO06]), jog反轉(DO-123[ID5-DO07])
//	(內環升降在最上位才可操作)
void __fastcall TfrnMain::btnMacroInnerTMoveMouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   //tsDI->Enabled = false;
   pnlDIMsg->Caption = "";
   pnlMacroInnerTMove->Color = clSilver;

   // 2022 12 22 - chc Tazmo
   if(RobotMode != ROBOT_MODE_TAZMO) {
      if(CheckMacroZ1Up() == false) {
         pnlDIMsg->Caption = "Macro Z1不在上位!";
         pnlMacroInnerYMove->Color = clRed;
      }
      else if(CheckMacroZ2Up() == true) {
         pnlDIMsg->Caption = "Macro Z2在上位!";
         pnlMacroInnerTMove->Color = clRed;
      }
      else {
         // Reset ID5 DO06,07
         cbID5Bit6->Checked = true;
         cbID5Bit7->Checked = false;
         WriteDO(IO3_ID);
         pnlMacroInnerTMove->Color = clLime;
      }
   }
   else {

      // Reset ID5 DO06,07
      cbID5Bit6->Checked = true;
      cbID5Bit7->Checked = false;
      WriteDO(IO3_ID);
      pnlMacroInnerTMove->Color = clLime;
   }
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnMacroInnerTMoveMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   // Reset ID5 DO6,7
   cbID5Bit6->Checked = false;
   cbID5Bit7->Checked = false;
   WriteDO(IO3_ID);
   pnlMacroInnerTMove->Color = clSilver;
   //tsDI->Enabled = true;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnMacroInnerTBackMouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   //tsDI->Enabled = false;
   pnlDIMsg->Caption = "";
   pnlMacroInnerTBack->Color = clSilver;

   // 2022 12 22 - chc Tazmo
   if(RobotMode != ROBOT_MODE_TAZMO) {
      if(CheckMacroZ1Up() == false) {
         pnlDIMsg->Caption = "Macro Z1不在上位!";
         pnlMacroInnerYMove->Color = clRed;
      }
      else if(CheckMacroZ2Up() == true) {
         pnlDIMsg->Caption = "Macro Z2在上位!";
         pnlMacroInnerTBack->Color = clRed;
      }
      else {
         // Reset ID5 DO22,23
         cbID5Bit6->Checked = false;
         cbID5Bit7->Checked = true;
         WriteDO(IO3_ID);
         pnlMacroInnerTBack->Color = clLime;
      }
   }
   else {

      // Reset ID5 DO22,23
      cbID5Bit6->Checked = false;
      cbID5Bit7->Checked = true;
      WriteDO(IO3_ID);
      pnlMacroInnerTBack->Color = clLime;
   }
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnMacroInnerTBackMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   // Reset ID5 DO22,23
   cbID5Bit6->Checked = false;
   cbID5Bit7->Checked = false;
   WriteDO(IO3_ID);
   pnlMacroInnerTBack->Color = clSilver;
   //tsDI->Enabled = true;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnMacroOuterPositionClick(TObject *Sender)
{

//   tsDI->Enabled = false;
   pnlDIMsg->Caption = "";
   pnlMacroOuterPosition->Color = clSilver;
   pnlMacroOuterPosition->Refresh();
   if(CheckMacroZ1Up() == true) {
      pnlDIMsg->Caption = "Macro Z1在上位!";
      pnlMacroOuterPosition->Color = clRed;
      WriteSystemLog(">>Macro Demo: Z2 Up, Z1在上位!");
      pnlMacroOuterPosition->Refresh();
      goto err;
   }
   btnMacroZ2UpClick(this);
   if(pnlMacroZ2Up->Color != clLime) {
      pnlDIMsg->Caption = "Macro Z2 Up Fail!";
      pnlMacroOuterPosition->Color = clRed;
      WriteSystemLog(">>Macro Demo: Z2 Up Fail!(btnMacroOuterPositionClick)");
      pnlMacroOuterPosition->Refresh();
   }
   else {
      pnlDIMsg->Caption = "Macro Z2 Up ok.";
      pnlMacroOuterPosition->Color = clLime;
      WriteSystemLog(">>Macro Demo: Z2 Up Ok.(btnMacroOuterPositionClick)");
      pnlMacroOuterPosition->Refresh();
   }
err:
   tsDI->Enabled = true;
}
//---------------------------------------------------------------------------
// 外環旋轉 MBR jog正轉(DO-116[ID5-DO00]), jog反轉(DO-117[ID5-DO01])
void __fastcall TfrnMain::btnMacroOuterTCWMouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   //tsDI->Enabled = false;
   pnlDIMsg->Caption = "";
   pnlMacroOuterTCW->Color = clSilver;
   if(CheckMacroZ1Up() == true) {
      pnlDIMsg->Caption = "Macro Z1在上位!";
      pnlMacroOuterTCW->Color = clRed;
   }
   else if(CheckMacroZ2Up() == false) {
      pnlDIMsg->Caption = "Macro Z2不在上位!";
      pnlMacroOuterTCW->Color = clRed;
   }
   else {
      // Reset ID5 DO00,01
      cbID5Bit0->Checked = true;
      cbID5Bit1->Checked = false;
      WriteDO(IO3_ID);
      pnlMacroOuterTCW->Color = clLime;
   }
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnMacroOuterTCWMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   // Reset ID5 DO0,01
   cbID5Bit0->Checked = false;
   cbID5Bit1->Checked = false;
   WriteDO(IO3_ID);
   pnlMacroOuterTCW->Color = clSilver;
   //tsDI->Enabled = true;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnMacroOuterTCCWMouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   //tsDI->Enabled = false;
   pnlDIMsg->Caption = "";
   pnlMacroOuterTCCW->Color = clSilver;
   if(CheckMacroZ1Up() == true) {
      pnlDIMsg->Caption = "Macro Z1在上位!";
      pnlMacroOuterTCCW->Color = clRed;
   }
   else if(CheckMacroZ2Up() == false) {
      pnlDIMsg->Caption = "Macro Z2不在上位!";
      pnlMacroOuterTCCW->Color = clRed;
   }
   else {
      // Reset ID5 DO00,01
      cbID5Bit0->Checked = false;
      cbID5Bit1->Checked = true;
      WriteDO(IO3_ID);
      pnlMacroOuterTCCW->Color = clLime;
   }
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnMacroOuterTCCWMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   // Reset ID5 DO0,01
   cbID5Bit0->Checked = false;
   cbID5Bit1->Checked = false;
   WriteDO(IO3_ID);
   pnlMacroOuterTCCW->Color = clSilver;
   //tsDI->Enabled = true;
}
//---------------------------------------------------------------------------


void __fastcall TfrnMain::rgJoystickModeChange(TObject *Sender,
      int ButtonIndex)
{

   if(rgJoystickMode->ItemIndex == JOYSTICK_MACRO_INNER || rgJoystickMode->ItemIndex == JOYSTICK_MACRO_OUTER) {
      cbAISpeed->Checked = false;
      if(rgJoystickMode->ItemIndex == JOYSTICK_MACRO_INNER) {
         MacroInnerXStatus = 0;
         MacroInnerYStatus = 0;
         MacroInnerTStatus = 0;
      }
      else {
         MacroOuterYStatus = 0;
      }
   }
}
//---------------------------------------------------------------------------
bool boolInLoopTest = false;

void __fastcall TfrnMain::btnMacroDemoClick(TObject *Sender)
{
int delaytime,outtime,intime;

   // 2022 9 14 - chc Demo時做
   //if(mmRobotMsg->Lines->Count > 400) {
   //   for(int i=320 ; i<mmRobotMsg->Lines->Count ; i++)
   //      mmRobotMsg->Lines->Delete(i);
   //}
   mmRobotMsg->Clear();

   WriteSystemLog("Macro Demo Start...");
   delaytime = edDemoDelay->Text.ToInt();
   outtime = edDemoOutTime->Text.ToInt();
   intime = edDemoInTime->Text.ToInt();
   tsDI->Enabled = false;
   pnlMacroDemo->Color = clSilver;

   // Home
   // 2022 8 10 - chc 正常不做Home
   //btnMacroHomeClick(this);
   //if(pnlMacroHome->Color != clLime)
   //   goto err;

   // 2022 12 22 - chc Tazmo
   if(RobotMode != ROBOT_MODE_TAZMO) {
      if(cbDemoStep->Checked == true) {
         if(Application->MessageBox("續做Z1上升?      ", "Demo Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
            goto err;
         }
      }

      // Inner就觀測位置: Z1上升
      btnMacroInnerPositionClick(this);
      if(pnlMacroInnerPosition->Color != clLime) {
         WriteSystemLog("Macro Demo: Inner就觀測位置失敗!");

         // 2022 9 12a - chc 再做一次
         for(int i=0 ; i<3 ; i++) {
            UpdateMotionStatus();
            if((pnlID3Bit12->Color == clLime && pnlID3Bit13->Color != clLime) || (HSL_DI_InStatus2[12] == true && HSL_DI_InStatus2[13] != true)) {
               goto inok;
            }
            WaitTime(50);
         }

         goto err;
      }
   }

inok:
   // 2022 8 15 - chc 是否移動與轉動
   if(cbMacroDemoMove->Checked == true) {

      // 後
      if(cbDemoStep->Checked == true) {
         if(Application->MessageBox("續做內後?      ", "Demo Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
            goto err;
         }
      }
      WriteSystemLog(">>Macro Demo: 內環前翻...");
      // 2022 9 15 - chc ID5- DO16,17
      //if(MacroInnerYBack() == false) {
      if(MacroInnerYBackForce() == false) {

         WriteSystemLog(">>Macro Demo: 內環前翻Fail!");
         goto err;
      }
      WriteSystemLog(">>Macro Demo: 內環前翻Ok.");

      // 2022 9 2 - chc Get/Put時用指定時間
      // 2022 9 12a - chc Loop也要計入: boolInLoopTest = true
      //if(boolInLoad == true || boolInUnLoad == true)
      if(boolInLoad == true || boolInUnLoad == true || boolInLoopTest == true)

          WaitTimeMacro(intime);
      else

          WaitTimeMacro(delaytime);
      if(MacroInnerYRelease() == false)
         goto err;

      // 2022 9 2 - chc Get/Put時不做
      // 2022 9 12a - chc Loop也要計入: boolInLoopTest = true
      //if(boolInLoad != true && boolInUnLoad != true) {
      if(boolInLoad != true && boolInUnLoad != true && boolInLoopTest != true) {

         // 前
         if(cbDemoStep->Checked == true) {
            if(Application->MessageBox("續做內前?      ", "Demo Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
               goto err;
            }
         }
         if(MacroInnerYMove() == false)
            goto err;
         WaitTimeMacro(delaytime);
         if(MacroInnerYRelease() == false)
            goto err;

         // 左
         if(cbDemoStep->Checked == true) {
            if(Application->MessageBox("續做內左?      ", "Demo Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
               goto err;
            }
         }
         if(MacroInnerXMove() == false)
            goto err;
         WaitTimeMacro(delaytime);
         if(MacroInnerXRelease() == false)
            goto err;

         // 右
         if(cbDemoStep->Checked == true) {
            if(Application->MessageBox("續做內右?      ", "Demo Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
               goto err;
            }
         }
         if(MacroInnerXBack() == false)
            goto err;
         WaitTimeMacro(delaytime);
         if(MacroInnerXRelease() == false)
            goto err;

         // 正轉
         if(cbDemoStep->Checked == true) {
            if(Application->MessageBox("續做內正轉?      ", "Demo Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
               goto err;
            }
         }
         if(MacroInnerTMove() == false)
            goto err;
         WaitTimeMacro(delaytime);
         if(MacroInnerTRelease() == false)
            goto err;

         // 反轉
         if(cbDemoStep->Checked == true) {
            if(Application->MessageBox("續做內反轉?      ", "Demo Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
               goto err;
            }
         }
         if(MacroInnerTBack() == false)
            goto err;
         WaitTimeMacro(delaytime);
         if(MacroInnerTRelease() == false)
            goto err;
      }
   }

   // XY Home
   if(cbDemoStep->Checked == true) {
      if(Application->MessageBox("續做內XY Home?      ", "Demo Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         goto err;
      }
   }
   WriteSystemLog(">>Macro Demo: XY Home...");
   btnMacroXYHomeClick(this);
   if(pnlMacroXYHome->Color != clLime) {
      WriteSystemLog(">>Macro Demo: XY Home Fail!");
      goto err;
   }
   WriteSystemLog(">>Macro Demo: XY Home Ok.");

   // T Reset
   if(cbDemoStep->Checked == true) {
      if(Application->MessageBox("續做內T Reset?      ", "Demo Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         goto err;
      }
   }
   WriteSystemLog(">>Macro Demo: T Reset...");
   btnMacroT1ResetClick(this);
   if(pnlMacroT1Reset->Color != clLime) {
      WriteSystemLog(">>Macro Demo: T Reset Fail!");
      goto err;
   }
   WriteSystemLog(">>Macro Demo: T Reset Ok.");

   // 2022 12 22 - chc Tazmo
   if(RobotMode != ROBOT_MODE_TAZMO) {
      // Z1下降
      if(cbDemoStep->Checked == true) {
         if(Application->MessageBox("續做內下降?      ", "Demo Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
            goto err;
         }
      }
      WriteSystemLog(">>Macro Demo: Z1 Down...");
      // 結果會看DI12,13
      btnMacroZ1DownClick(this);
      if(pnlMacroZ1Down->Color != clLime) {

         // 2022 9 15 - chc 不管結果
         //goto err;
         WriteSystemLog(">>Macro Demo: Z1 Down Fail強制為Ok.");

      }
      WriteSystemLog(">>Macro Demo: Z1 Down Ok.");

      // Outer就觀測位置
      if(cbDemoStep->Checked == true) {
         if(Application->MessageBox("續做外上升?      ", "Demo Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
            goto err;
         }
      }
      WriteSystemLog(">>Macro Demo: Z2 Up...");

      // 2022 9 15a - chc Loop取片後Demo要忽略
      boolInLoopMacroZ2Up = true;

      // 會檢查Z1: 在上無法執行
      btnMacroOuterPositionClick(this);

      // 2022 9 15a - chc Loop取片後Demo要忽略
      boolInLoopMacroZ2Up = false;

      if(pnlMacroOuterPosition->Color != clLime) {
         WriteSystemLog(">>Macro Demo: Z2 Up Fail!");
         goto err;
      }
      WriteSystemLog(">>Macro Demo: Z2 Up Ok.");

      // 2022 8 15 - chc 是否移動與轉動
      if(cbMacroDemoMove->Checked == true) {

         // 前轉
         if(cbDemoStep->Checked == true) {
            if(Application->MessageBox("續做外前轉?      ", "Demo Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
               goto err;
            }
         }

         // 2022 9 15 - chc 可分是否檢查?
         //if(MacroOuterTCCW() == false)
         WriteSystemLog(">>Macro Demo: 外環前轉...");
         if(MacroOuterTCCW(false) == false) {
            WriteSystemLog(">>Macro Demo: 外環前轉 Fail!");

            goto err;
         }
         WriteSystemLog(">>Macro Demo: 外環前轉 Ok.");
         WaitTimeMacro(outtime);
         WriteSystemLog(">>Macro Demo: 外環前轉停...");
         if(MacroOuterTRelease() == false) {
            WriteSystemLog(">>Macro Demo: 外環前轉停 Fail!");
            goto err;
         }
         WriteSystemLog(">>Macro Demo: 外環前轉停 Ok.");
         WaitTimeMacro(delaytime);

         // 後轉
         // 2022 9 2 - chc Get/Put時不做
         // 2022 9 12a - chc Loop也要計入: boolInLoopTest = true
         //if(boolInLoad != true && boolInUnLoad != true) {
         if(boolInLoad != true && boolInUnLoad != true && boolInLoopTest != true) {

            if(cbDemoStep->Checked == true) {
               if(Application->MessageBox("續做外後轉?      ", "Demo Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
                  goto err;
               }
            }
            if(MacroOuterTCW() == false)
               goto err;
            WaitTimeMacro(outtime*2);
            if(MacroOuterTRelease() == false)
               goto err;
            WaitTimeMacro(delaytime);
         }

         // Z2 Home
         if(cbDemoStep->Checked == true) {
            if(Application->MessageBox("續做外Home?      ", "Demo Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
               goto err;
            }
         }
         WriteSystemLog(">>Macro Demo: Z1 Home...");
         btnMacroZ2HomeClick(this);
         if(pnlMacroZ2Home->Color != clLime) {
            WriteSystemLog(">>Macro Demo: Z1 Home Fail!");
            goto err;
         }
         WriteSystemLog(">>Macro Demo: Z1 Home Ok.");
      }

      // Z2下降
      if(cbDemoStep->Checked == true) {
         if(Application->MessageBox("續做外下降?      ", "Demo Operation", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
            goto err;
         }
      }
      WriteSystemLog(">>Macro Demo: Z2 Down...");
      btnMacroZ2DownClick(this);
      if(pnlMacroZ2Down->Color != clLime) {
         WriteSystemLog(">>Macro Demo: Z2 Down Fail!");
         goto err;
      }
      WriteSystemLog(">>Macro Demo: Z2 Down Ok.");
   }

   pnlMacroDemo->Color = clLime;
   goto ok;

err:
   pnlMacroDemo->Color = clRed;
ok:
   tsDI->Enabled = true;
   WriteSystemLog("Macro Demo Stop.");

}
//---------------------------------------------------------------------------
// 結束內還觀測
// 3. => 1. => 2.
void __fastcall TfrnMain::btnMacroInnerStopClick(TObject *Sender)
{

   WriteSystemLog("結束內環觀測...");

//   tsDI->Enabled = false;
   pnlMacroInnerStop->Color = clSilver;
   pnlMacroInnerStop->Refresh();
   //Z2 在上?
   if(CheckMacroZ2Up() == true) {
      pnlMacroInnerStop->Color = clRed;
      pnlMacroInnerStop->Refresh();
      goto err;
   }
   WriteSystemLog("結束內環觀測-1...");
   //Z1 在下
   if(CheckMacroZ1Up() == false) {
      pnlMacroInnerStop->Color = clRed;
      pnlMacroInnerStop->Refresh();
      goto err;
   }
   WriteSystemLog("結束內環觀測-2...");
   // 內環T Reset
   btnMacroT1ResetClick(this);
   if(pnlMacroT1Reset->Color != clLime) {
      pnlMacroInnerStop->Color = clRed;
      pnlMacroInnerStop->Refresh();
      goto err;
   }
   WriteSystemLog("結束內環觀測-3...");
   // 內環XY Home
   btnMacroXYHomeClick(this);
   if(pnlMacroXYHome->Color != clLime) {
      pnlMacroInnerStop->Color = clRed;
      pnlMacroInnerStop->Refresh();
      goto err;
   }
   WriteSystemLog("結束內環觀測-4...");
   // 內還Z1降
   btnMacroZ1DownClick(this);
   if(pnlMacroZ1Down->Color != clLime) {
      pnlMacroInnerStop->Color = clRed;
      pnlMacroInnerStop->Refresh();
      goto err;
   }
   pnlMacroInnerStop->Color = clLime;
   pnlMacroInnerStop->Refresh();
err:
   tsDI->Enabled = true;
   WriteSystemLog("結束內環觀測.");

}
//---------------------------------------------------------------------------
// 結束外環觀測
//  5. => MBL下降到放片位(Do-106[ID3-DO06]->Do-105[ID3-DO05]),確認完成(Di-109[ID3-DI09])=>
//        關閉外環Vacuum(Do-02[ID1-DO02]),開啟內環Vacuum(Do-01[ID1-DO01])=>
//        MBL下降到最下位(Do-105[ID3-DO05]),確認完成(Di-109[ID3-DI09]),sensor觸發(Di-110[ID3-DI10])
// 5. - 6.
void __fastcall TfrnMain::btnMacroOuterStopClick(TObject *Sender)
{

//   tsDI->Enabled = false;
   pnlMacroOuterStop->Color = clSilver;
   pnlMacroOuterStop->Refresh();
   // Z1在上?
   if(CheckMacroZ1Up() == true) {
      pnlDIMsg->Caption = "Macro Z1在上位!";
      pnlMacroOuterStop->Color = clRed;
      pnlMacroOuterStop->Refresh();
      goto err;
   }
   // Z2在下?
   if(CheckMacroZ2Up() == false) {
      pnlDIMsg->Caption = "Macro Z2在下位!";
      pnlMacroOuterStop->Color = clRed;
      pnlMacroOuterStop->Refresh();
      goto err;
   }
   // T2 Home
   btnMacroZ2HomeClick(this);
   if(pnlMacroZ2Home->Color != clLime) {
      pnlDIMsg->Caption = "Macro Z2 Home Fail!";
      pnlMacroOuterStop->Color = clRed;
      pnlMacroOuterStop->Refresh();
      goto err;
   }
   // Z2降
   btnMacroZ2DownClick(this);
   if(pnlMacroZ2Down->Color != clLime) {
      pnlDIMsg->Caption = "Macro Z2 Down Fail!";
      pnlMacroOuterStop->Color = clRed;
      pnlMacroOuterStop->Refresh();
      goto err;
   }
   pnlMacroOuterStop->Color = clLime;
   pnlMacroOuterStop->Refresh();
err:
   tsDI->Enabled = true;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnMacroInnerYMoveMouseExit(TObject *Sender)
{

   // Reset ID5 DO16,17
   cbID5Bit16->Checked = false;
   cbID5Bit17->Checked = false;
   WriteDO(IO3_ID);
   pnlMacroInnerYMove->Color = clSilver;
   //tsDI->Enabled = true;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnMacroInnerYBackMouseExit(TObject *Sender)
{

   // Reset ID5 DO16,17
   cbID5Bit16->Checked = false;
   cbID5Bit17->Checked = false;
   WriteDO(IO3_ID);
   pnlMacroInnerYBack->Color = clSilver;
   //tsDI->Enabled = true;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnMacroInnerXMoveMouseExit(TObject *Sender)
{

   // Reset ID5 DO22,23
   cbID5Bit22->Checked = false;
   cbID5Bit23->Checked = false;
   WriteDO(IO3_ID);
   pnlMacroInnerXMove->Color = clSilver;
   //tsDI->Enabled = true;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnMacroInnerXBackMouseExit(TObject *Sender)
{

   // Reset ID5 DO22,23
   cbID5Bit22->Checked = false;
   cbID5Bit23->Checked = false;
   WriteDO(IO3_ID);
   pnlMacroInnerXBack->Color = clSilver;
   //tsDI->Enabled = true;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnMacroInnerTMoveMouseExit(TObject *Sender)
{

   // Reset ID5 DO6,7
   cbID5Bit6->Checked = false;
   cbID5Bit7->Checked = false;
   WriteDO(IO3_ID);
   pnlMacroInnerTMove->Color = clSilver;
   //tsDI->Enabled = true;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnMacroInnerTBackMouseExit(TObject *Sender)
{

   // Reset ID5 DO22,23
   cbID5Bit6->Checked = false;
   cbID5Bit7->Checked = false;
   WriteDO(IO3_ID);
   pnlMacroInnerTBack->Color = clSilver;
   //tsDI->Enabled = true;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnMacroOuterTCWMouseExit(TObject *Sender)
{

   // Reset ID5 DO0,01
   cbID5Bit0->Checked = false;
   cbID5Bit1->Checked = false;
   WriteDO(IO3_ID);
   pnlMacroOuterTCW->Color = clSilver;
   //tsDI->Enabled = true;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnMacroOuterTCCWMouseExit(TObject *Sender)
{

   // Reset ID5 DO0,01
   cbID5Bit0->Checked = false;
   cbID5Bit1->Checked = false;
   WriteDO(IO3_ID);
   pnlMacroOuterTCCW->Color = clSilver;
   //tsDI->Enabled = true;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnMoveRClick(TObject *Sender)
{

   btnMoveR->Enabled = false;
   if(cbContinueMove->Checked == true)
      return;

   // 設定為Y軸, 做後退動作
   combAxis->ItemIndex = R_AXIS;
   btnMoveClick(this);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnMoveRMouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   // 指定軸
   combAxis->ItemIndex = R_AXIS;
   btnMoveMouseDown(this,Button, Shift, X, Y);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnMoveRMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   btnMoveR->Enabled = true;
   if(cbContinueMove->Checked == false)
      return;
   boolJogMove = false;

   // Log
   //WriteSystemLog(">boolJogMove=false - btnMoveYMouseUp");

   // 立即停止
   pnlSystemMessage->Caption = "W軸停止.";
   pnlSystemMessage->Refresh();
   StopOneAxis(R_AXIS);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnBackwardRClick(TObject *Sender)
{

   btnBackwardR->Enabled = false;

   // Log
   //WriteSystemLog(">btnBackwardY->Enabled = false - btnBackwardYClick");

   if(cbContinueMove->Checked == true)
      return;

   // 設定為Y軸, 做後退動作
   combAxis->ItemIndex = R_AXIS;
   btnBackwardClick(this);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnBackwardRMouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   // 指定軸
   combAxis->ItemIndex = R_AXIS;
   btnBackwardMouseDown(this,Button, Shift, X, Y);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnBackwardRMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   // Log
   //WriteSystemLog(">btnBackwardR->Enabled = true - btnBackwardRMouseUp");

   btnBackwardR->Enabled = true;
   if(cbContinueMove->Checked == false)
      return;
   boolJogMove = false;

   // Log
   //WriteSystemLog(">boolJogMove=false - btnBackwardRMouseUp");

   // 立即停止
   pnlSystemMessage->Caption = "W軸停止.";
   pnlSystemMessage->Refresh();
   StopOneAxis(R_AXIS);
}
//---------------------------------------------------------------------------
// 2022 7 6 - chc EFEM
// 2022 12 5 - chc Full or LP+Robot
//bool __fastcall TfrnMain::SetupEFEM()
// Mode: 1-Full, 2-LP+Robot
bool __fastcall TfrnMain::SetupEFEM(int mode)

{
bool status = true;

   // 2022 12 6 - chc Logo Form
   if(frmLogo->Visible == true) {
      frmLogo->pnlMacroUnit->Caption = "Initialized.";
      frmLogo->pnlWaferUnit->Caption = "Initializing...";
   }

   frnMain->AddMainLog("EFEM Init...", EFEM_RESTART,true);
   // EFEM Setup Message
   pnlStartMessage->Caption = "EFEM Initializing...";
   pnlMainOperation->Caption = pnlStartMessage->Caption;
   pnlStartMessage->Visible = true;
   pnlStartMessage->Refresh();
   if(frmLogo->Visible == true)
      frmLogo->pnlMessage->Caption = pnlStartMessage->Caption;

   // 2022 12 5 - chc Full or LP+Robot
   //WriteSystemLog("SetupEFEM() Enter...");
   WriteSystemLog("SetupEFEM() Enter... Mode= " + IntToStr(mode));

   RobotWithWafer = ROBOT_WAFER_UNKOWN;

   // init Com Port
   boolRobotStatus = true;
   RobotButton();
   boolLoadPortStatus = true;
   LoadPortButton(0);
   InitRobotCom();
   WaitTime(500);
   InitLoadPortCom();
   // 2023 1 9 - chc 提前做
   //WaitTime(500);
   //InitRFIDCom();

   // Abort
   if(frnMain->AlarmStatus.boolLPLight == true) {
      status = false;
      goto end;
   }

   // 2022 12 5 - chc Full or LP+Robot
   if(mode == 1) {

      boolAlignerStatus = true;
      AlignerButton();
      InitAlignerCom();

      // 2022 12 22 - chc Tazmo
      if(RobotMode == ROBOT_MODE_TAZMO) {
         boolAligner2Status = true;
         Aligner2Button();
         InitAligner2Com();
      }

   }

   // Abort
   if(frnMain->AlarmStatus.boolLPLight == true) {
      status = false;
      goto end;
   }

   // 2022 12 5 - chc Init BXFM
   /*
   pnlStartMessage->Caption = "EFEM 初始BXFM...";
   pnlStartMessage->Refresh();
   if(frmLogo->Visible == true)
      frmLogo->pnlMessage->Caption = pnlStartMessage->Caption;

   // 2022 8 2 - chc 要Init BXFM
   // 2022 12 5 - chc Full or LP+Robot
   if(mode == 1)

      InitBXFMCom();
   */

   // 2022 7 10 - chc LoadPort2
   boolLoadPort2Status = true;
   LoadPort2Button(0);
   InitLoadPort2Com();
   WaitTime(500);
   //InitLED1Com();
   //InitLED2Com();

   // Abort
   if(frnMain->AlarmStatus.boolLPLight == true) {
      status = false;
      goto end;
   }

   WaitTime(1000);

   WriteSystemLog("SetupEFEM() COM init.");

   // Pause
   // 2022 9 12 - chc 不做
   //if(Application->MessageBox("SetupEFEM: 做Robot原點, 繼續?      ", "AllHome", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
   //   goto end;
   //}

   pnlStartMessage->Caption = "EFEM: Init Robot...";
   pnlStartMessage->Refresh();
   pnlMainOperation->Caption = pnlStartMessage->Caption;
   if(frmLogo->Visible == true)
      frmLogo->pnlMessage->Caption = pnlStartMessage->Caption;

   // Robot ORGN
   if(boolRobotStatus == true) {
      btnRobotOriginalClick(this);
   }   
   else
      status = false;

   WaitTime(1000);
   WriteSystemLog("SetupEFEM() Robot ORGN.");

   // Abort
   if(frnMain->AlarmStatus.boolLPLight == true) {
      status = false;
      goto end;
   }

   // Pause
   // 2022 9 12 - chc 不做
   //if(Application->MessageBox("SetupEFEM: 取得LoadPort1狀態, 繼續?      ", "AllHome", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
   //   goto end;
   //}

   pnlStartMessage->Caption = "EFEM: Init LoadPort...";
   pnlStartMessage->Refresh();
   pnlMainOperation->Caption = pnlStartMessage->Caption;
   if(frmLogo->Visible == true)
      frmLogo->pnlMessage->Caption = pnlStartMessage->Caption;

   // LoadPort GetStatus
   if(boolLoadPortStatus == true)
      btnLoadPortStasClick(this);
   else
      status = false;

   // Abort
   if(frnMain->AlarmStatus.boolLPLight == true) {
      status = false;
      goto end;
   }

   WaitTime(1000);
   WriteSystemLog("SetupEFEM() LoadPort STAS.");

   // 2020 5 4 - chc 檢查pnlLoadPortS3是否為2(Load)
   if(pnlLoadPortS3->Caption == "2") {
      btnCassetteLoad->Caption = "UnLoad";
      frmRecipe->btnCassetteLoad->Caption = "UnLoad";
   }
   else {
      btnCassetteLoad->Caption = "Load";
      frmRecipe->btnCassetteLoad->Caption = "Load";
   }

   // Pause
   // 2022 9 12 - chc 不做
   //if(Application->MessageBox("SetupEFEM: 取得LoadPort2狀態, 繼續?      ", "AllHome", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
   //   goto end;
   //}

   // Abort
   if(frnMain->AlarmStatus.boolLPLight == true) {
      status = false;
      goto end;
   }

   // LoadPort GetStatus
   if(boolLoadPort2Status == true)
      btnLoadPort2StasClick(this);
   else
      status = false;
   WaitTime(1000);
   WriteSystemLog("SetupEFEM() LoadPort2 STAS.");
   // 檢查pnlLoadPort2S3是否為2(Load)
   if(pnlLoadPort2S3->Caption == "2") {
      btnCassette2Load->Caption = "UnLoad";
      frmRecipe->btnCassette2Load->Caption = "UnLoad";
   }
   else {
      btnCassette2Load->Caption = "Load";
      frmRecipe->btnCassette2Load->Caption = "Load";
   }

   // Abort
   if(frnMain->AlarmStatus.boolLPLight == true) {
      status = false;
      goto end;
   }

   // 2020 5 6 - chc 要做Unload
   //btnLoadPortUnLoadClick(this);

   // Pause
   // 2022 9 12 - chc 不做
   //if(Application->MessageBox("SetupEFEM: 做Aligner原點, 繼續?      ", "AllHome", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
   //   goto end;
   //}

   // 2022 12 5 - chc Full or LP+Robot
   if(mode == 1) {

      pnlStartMessage->Caption = "EFEM: Init Aligner...";
      pnlStartMessage->Refresh();
      pnlMainOperation->Caption = pnlStartMessage->Caption;
      if(frmLogo->Visible == true)
         frmLogo->pnlMessage->Caption = pnlStartMessage->Caption;

      // 2022 12 22 - chc Tazmo
      if(RobotMode != ROBOT_MODE_TAZMO) {
         // Aligner ORGN
         if(boolAlignerStatus == true)
            btnAlignerORGNClick(this);
         else
            status = false;
         // 檢查
         WaitTime(3000);
         WriteSystemLog("SetupEFEM() Aligner ORGN.");
      }
      else {

         // 2022 12 20 - chc 交給timer同步做
         tmAligner2Reset->Enabled = true;
         // Aligner ORGN
         if(boolAlignerStatus == true) {
            btnAlignerResetClick(this);
         }
         else
            status = false;
         WaitTime(2000);
         if(pnlAligner2Reset->Color != clLime) {
            status = false;
         }
         // 檢查
         WaitTime(1000);
         WriteSystemLog("SetupEFEM() Aligner ORGN.");
      }
   }

   // Abort
   if(frnMain->AlarmStatus.boolLPLight == true) {
      status = false;
      goto end;
   }

   if(pnlRobotOriginal->Color != clLime || pnlRobotOperation->Caption != "Ready") {
      status = false;
      pnlRobotReady->Color = clRed;

      // 2020 5 6 - chc Log
      if(pnlRobotOriginal->Color != clLime)
         WriteSystemLog("#pnlRobotOriginal->Color != clLime");
      else
         WriteSystemLog("#pnlRobotOperation->Caption != Ready");

   }

   // 2022 12 5 - chc Full or LP+Robot, pnlAlignerOperation
   if(mode == 1) {

      // 2022 12 5 - chc 錯: pnlAlignerOperation
      // 2022 12 22 - chc Tazmo
      if(RobotMode != ROBOT_MODE_TAZMO) {
         if(pnlAlignerORGN->Color != clLime || pnlLoadPortOperation->Caption != "Ready") {
            status = false;
            pnlAlignerReady->Color = clRed;
         }
      }
      else {

         // 2022 12 19 - chc Tazmo
         if(pnlAlignerReset->Color != clLime || pnlAlignerOperation->Caption != "Ready" || pnlAligner2Reset->Color != clLime || pnlAligner2Operation->Caption != "Ready") {
            status = false;
            pnlAlignerReady->Color = clRed;
         }   
      }
   }

   if(pnlLoadPortOperation->Caption != "Ready") {
      status = false;
      pnlLoadPortReady->Color = clRed;
   }

   // 2020 7 14 - chc 設為enable
   else {

      // 2022 12 6 - chc OP Not allow
      if(PriorityLevel == PRIORITY_OP) {
         btnCassetteLoad->Enabled = false;
         frmRecipe->btnCassetteLoad->Enabled = false;
      }
      else {

         btnCassetteLoad->Enabled = true;
         frmRecipe->btnCassetteLoad->Enabled = true;
      }
   }

   // 2022 12 5 - chc 漏LP2
   if(pnlLoadPort2Operation->Caption != "Ready") {
      status = false;
      pnlLoadPort2Ready->Color = clRed;
   }
   // 設為enable
   else {

      // 2022 12 6 - chc OP Not allow
      if(PriorityLevel == PRIORITY_OP) {
         btnCassetteLoad->Enabled = false;
         frmRecipe->btnCassetteLoad->Enabled = false;
      }
      else {

         btnCassette2Load->Enabled = true;
         frmRecipe->btnCassetteLoad->Enabled = true;
      }
   }

   // 2022 12 5 - chc Full or LP+Robot
   // 2022 12 5 - chc Init BXFM
   /*
   if(mode == 1) {

      pnlStartMessage->Caption = "初始A2M...";
      pnlStartMessage->Refresh();
      if(frmLogo->Visible == true)
         frmLogo->pnlMessage->Caption = pnlStartMessage->Caption;

      // 2022 7 25 - chc BXFM Parameter
      ReadA2MParameter(1);                                          // 要先讀取AF/Z Table值
      btnA2MORGClick(this);                                        // 要先做ORG
      Sleep(500);
      ReadBXFMParameter(1);                                         // 會切換Lens: 改變AF/Z
      // Switch AF to OFF
      if(pnlA2MControl->Color == clLime) {
         rgA2MAFMode->ItemIndex = 2;
         WriteSystemLog("Set A2M AF to OFF...");
         btnA2MAFClick(this);
         WriteSystemLog("Set A2M AF to OFF.");
      }
   }
   */

   // Set Robot Speed
   // 2022 12 19 - chc Tazmo
   if(RobotMode != ROBOT_MODE_TAZMO) {
      if(boolRobotStatus == true) {

         pnlStartMessage->Caption = "EFEM: Set Robot Speed...";
         pnlStartMessage->Refresh();
         pnlMainOperation->Caption = pnlStartMessage->Caption;
         if(frmLogo->Visible == true)
            frmLogo->pnlMessage->Caption = pnlStartMessage->Caption;

         WriteSystemLog("Set Robot Speed...");
         btnRobotSpeedClick(this);
         WriteSystemLog("Set Robot Speed.");
      }
   }

end:
   // 2020 5 21 - chc EFEM Setup Message
   pnlStartMessage->Visible = false;

   if(frmLogo->Visible == true)
      frmLogo->pnlMessage->Caption = "EFEM Initialized.";
   pnlMainOperation->Caption = "EFEM Initialized.";

   WriteSystemLog("SetupEFEM() Leave.");
   if(mode == 2) {
      if(status == true)
         frnMain->AddMainLog("EFEM Init Ok.", EFEM_RESTART_OK,false);
      else
         frnMain->AddMainLog("EFEM Init Fail!", EFEM_RESTART_ERR,false);
   }

   // 2022 12 6 - chc Logo Form
   if(frmLogo->Visible == true) {
      frmLogo->pnlWaferUnit->Caption = "Initialized.";
   }

   return status;
}
//---------------------------------------------------------------------------
// boolRobotStatus = false;
void __fastcall TfrnMain::RobotButton()
{

   btnRobotCMD->Enabled = boolRobotStatus;
   btnRobotOriginal->Enabled = boolRobotStatus;
   btnRobotPos->Enabled = boolRobotStatus;
   cbRobot->Enabled = boolRobotStatus;
   rgWaferLocation->Enabled = boolRobotStatus;
   btnRobotGet->Enabled = boolRobotStatus;
   btnRobotPut->Enabled = boolRobotStatus;
   btnRobotVacuumOn->Enabled = boolRobotStatus;
   btnRobotVacuumOff->Enabled = boolRobotStatus;
   btnRobotStas->Enabled = boolRobotStatus;
   btnRobotWithWafer->Enabled = boolRobotStatus;

   // 2022 12 22 - chc Chuck Wafer? Tazmo
   if(RobotMode == ROBOT_MODE_TAZMO) {
      btnRobotVacuumOn->Caption = "夾";
   }
   else {

      btnRobotGetPosition->Enabled = boolRobotStatus;
      btnRobotClearAlarm->Enabled = boolRobotStatus;
      btnRobotEanble->Enabled = boolRobotStatus;
      btnRobotDisable->Enabled = boolRobotStatus;
   }
}
//---------------------------------------------------------------------------
// boolLoadPortStatus = false;
void __fastcall TfrnMain::LoadPortButton(int mode)
{

   btnLoadPortCMD->Enabled = boolLoadPortStatus;
   btnLoadPortLoad->Enabled = boolLoadPortStatus;
   btnLoadPortUnLoad->Enabled = boolLoadPortStatus;
   btnLoadPortLED->Enabled = boolLoadPortStatus;
   btnLoadPortMap->Enabled = boolLoadPortStatus;
   btnLoadPortStas->Enabled = boolLoadPortStatus;
   btnLoadPortMapping->Enabled = boolLoadPortStatus;
   btnLoadPortReset->Enabled = boolLoadPortStatus;

   if(mode == 1 || boolLoadPortStatus == false) {
      btnCassetteLoad->Enabled = boolLoadPortStatus;
      frmRecipe->btnCassetteLoad->Enabled = boolLoadPortStatus;
   }
}
//---------------------------------------------------------------------------
// boolAlignerStatus = false;
void __fastcall TfrnMain::AlignerButton()
{

   btnAlignerCMD->Enabled = boolAlignerStatus;
   btnAlignerORGN->Enabled = boolAlignerStatus;
   btnAlignerVacuumOff->Enabled = boolAlignerStatus;
   btnAlignerAlignment->Enabled = boolAlignerStatus;
   btnAlignerStas->Enabled = boolAlignerStatus;
   btnAlignerWithWafer->Enabled = boolAlignerStatus;
   //rgAlignerSet->Enabled = boolAlignerStatus;
   //btnAlignerSet->Enabled = boolAlignerStatus;
   //btnAlignerGet->Enabled = boolAlignerStatus;
   btnAlignerReset->Enabled = boolAlignerStatus;
   btnAlignerSave->Enabled = boolAlignerStatus;
   edAlignerDegree->Enabled = boolAlignerStatus;
   edAlignerDegreeOut->Enabled = boolAlignerStatus;
   //edAlignerSpeed->Enabled = boolAlignerStatus;
   //edAlignerType->Enabled = boolAlignerStatus;
}
//---------------------------------------------------------------------------
// 2022 7 6 - chc Init Robot ComPort
// COM4
void __fastcall TfrnMain::InitRobotCom()
{

   // 由參數決定COM Port
   pnlSystemMessage->Caption = "啟動Robot Com Port...";
   try {
      pnlRobotStatus->Color = clSilver;
      ybRobot->Active = false;
      Sleep(200);
      /*
      if(combRobotBaudrate->Text == "115200")
         ybRobot->Baud = ybRobot->br115200;
      else if(combRobotBaudrate->Text == "57600")
         ybRobot->Baud = ybRobot->br57600;
      else if(combRobotBaudrate->Text == "38400")
         ybRobot->Baud = ybRobot->br38400;
      else if(combRobotBaudrate->Text == "19200") {
         ybRobot->Baud = ybRobot->br19200;
         WriteSystemLog("Robot: 19200");
      }
      else if(combRobotBaudrate->Text == "9600")
         ybRobot->Baud = ybRobot->br9600;
      */
      // 由參數決定COM Port
      ybRobot->PortNo = combRobotComport->ItemIndex+1;
      WriteSystemLog("Robot: COM" + IntToStr(ybRobot->PortNo));

      // Hirata: 7/E/1
      // Tazmo: 8/N/1
      // 2022 12 22 - chc Tazmo
      if(RobotMode == ROBOT_MODE_TAZMO) {
         ybRobot->Baud = ybRobot->br9600;
         combRobotBaudrate->Text = "9600";
         ybRobot->Parity = ybRobot->ptNoParity;
         ybRobot->ByteSize = 8;

      }
      else {
         ybRobot->Baud = ybRobot->br19200;
         combRobotBaudrate->Text = "19200";
         // Parity, DataBit, StopBit
         ybRobot->Parity = ybRobot->ptEvenParity;
         ybRobot->ByteSize = 7;
      }

      //ybRobot->StopBits = ybRobot->sbOneStopBit;
      //ybRobot->FlowControl = ybRobot->fcNone;
      //WriteSystemLog("Robot: 7E1None");

      // Parity
      //if(cbNoParity->Checked == true)
      //   ybRobot->Parity = ybLens->ptNoParity;
      //else
      //   ybRobot->Parity = ybLens->ptEvenParity;

      ybRobot->Active = true;
      pnlRobotStatus->Color = clLime;
      boolRobotStatus = true;
      RobotButton();
   }
   catch(Exception &e) {
      pnlSystemMessage->Caption = "ybRobot: " + e.Message;
      sbSystem->Panels->Items[1]->Text = "ybRobot: " + e.Message;
      pnlRobotStatus->Color = clRed;
      boolRobotStatus = false;
      RobotButton();
   }
   UpdateRobotStatus();
   pnlSystemMessage->Caption = "啟動Robot Com Port.";

}
//---------------------------------------------------------------------------
// 2022 7 6 - chc Init LoadPort1 ComPort
// COM2
void __fastcall TfrnMain::InitLoadPortCom()
{

   // 由參數決定COM Port
   pnlSystemMessage->Caption = "啟動LoadPort Com Port...";
   try {
      pnlLoadPortStatus->Color = clSilver;
      ybLoadPort->Active = false;
      Sleep(200);
      if(combLoadPortBaudrate->Text == "115200")
         ybLoadPort->Baud = ybLoadPort->br115200;
      else if(combLoadPortBaudrate->Text == "57600")
         ybLoadPort->Baud = ybLoadPort->br57600;
      else if(combLoadPortBaudrate->Text == "38400")
         ybLoadPort->Baud = ybLoadPort->br38400;
      else if(combLoadPortBaudrate->Text == "19200")
         ybLoadPort->Baud = ybLoadPort->br19200;
      else if(combLoadPortBaudrate->Text == "9600")
         ybLoadPort->Baud = ybLoadPort->br9600;
      // 由參數決定COM Port
      ybLoadPort->PortNo = combLoadPortComport->ItemIndex+1;

      // Parity, DataBit, StopBit
      //ybLoadPort->Parity = ybLoadPort->ptNoParity;
      //ybLoadPort->ByteSize = 8;
      //ybLoadPort->StopBits = ybLoadPort->sbOneStopBit;

      // Parity
      //if(cbNoParity->Checked == true)
      //   ybLoadPort->Parity = ybLoadPort->ptNoParity;
      //else
      //   ybLoadPort->Parity = ybLoadPort->ptEvenParity;

      ybLoadPort->Active = true;
      pnlLoadPortStatus->Color = clLime;
      boolLoadPortStatus = true;
      LoadPortButton(0);
   }
   catch(Exception &e) {
      pnlSystemMessage->Caption = "ybLoadPort: " + e.Message;
      sbSystem->Panels->Items[1]->Text = "ybLoadPort: " + e.Message;
      pnlLoadPortStatus->Color = clRed;
      boolLoadPortStatus = false;
      LoadPortButton(0);
   }
   UpdateLoadPortStatus();
   pnlSystemMessage->Caption = "啟動LoadPort Com Port.";

}
//---------------------------------------------------------------------------
// 202 7 6 - chc Init Aligner ComPort
// COM5
void __fastcall TfrnMain::InitAlignerCom()
{

   // 由參數決定COM Port
   pnlSystemMessage->Caption = "啟動Aligner Com Port...";
   try {
      pnlAlignerStatus->Color = clSilver;
      ybAligner->Active = false;
      Sleep(200);
      /*
      if(combAlignerBaudrate->Text == "115200")
         ybAligner->Baud = ybAligner->br115200;
      else if(combAlignerBaudrate->Text == "57600")
         ybAligner->Baud = ybAligner->br57600;
      else if(combAlignerBaudrate->Text == "38400")
         ybAligner->Baud = ybAligner->br38400;
      else if(combAlignerBaudrate->Text == "19200")
         ybAligner->Baud = ybAligner->br19200;
      else if(combAlignerBaudrate->Text == "9600")
         ybAligner->Baud = ybAligner->br9600;
      */
      // 由參數決定COM Port
      ybAligner->PortNo = combAlignerComport->ItemIndex+1;

      // Parity, DataBit, StopBit
      //ybAligner->Parity = ybAligner->ptNoParity;
      //ybAligner->ByteSize = 8;
      //ybAligner->StopBits = ybAligner->sbOneStopBit;

      // Parity
      //if(cbNoParity->Checked == true)
      //   ybAligner->Parity = ybAligner->ptNoParity;
      //else
      //   ybAligner->Parity = ybAligner->ptEvenParity;

      // Tazmo
      if(RobotMode == ROBOT_MODE_TAZMO) {
         ybAligner->Baud = ybRobot->br9600;
         combAlignerBaudrate->Text = "9600";
      }
      else {
         ybAligner->Baud = ybRobot->br19200;
         combAlignerBaudrate->Text = "19200";
      }

      ybAligner->Active = true;
      pnlAlignerStatus->Color = clLime;
      boolAlignerStatus = true;
      AlignerButton();
   }
   catch(Exception &e) {
      pnlSystemMessage->Caption = "ybAligner: " + e.Message;
      sbSystem->Panels->Items[1]->Text = "ybAligner: " + e.Message;
      pnlAlignerStatus->Color = clRed;
      boolAlignerStatus = false;
      AlignerButton();
   }
   UpdateAlignerStatus();
   pnlSystemMessage->Caption = "啟動Aligner Com Port.";

}
//---------------------------------------------------------------------------
// 2022 7 6 - chc 以Timer處理SetupEFEM
// 由Motion- AllHome做, 不由timer做
// => 不用
void __fastcall TfrnMain::tmSetupEFEMTimer(TObject *Sender)
{

   tmSetupEFEM->Enabled = false;

   // 2022 12 5 - chc Full or LP+Robot
   //if(SetupEFEM() == false) {
   if(SetupEFEM(1) == false) {

      pnlEFEMReady->Color = clRed;
      pnlCCD->Color = clGray;
      pcRobot->Enabled = false;
      pnlSystemMessage->Caption = "EFEM異常! 無法作業.";
   }
   else {
      pnlEFEMReady->Color = clLime;
      pnlCCD->Color = clSilver;
      pcRobot->Enabled = true;
      pnlSystemMessage->Caption = "EFEM正常! 系統Ready.";
   }

   // 若HomeDone檢查Vacuum, CDA
   WriteSystemLog("SetupEFEM完成(tmSetupEFEM): 檢查Vacuum, CDA");
   CheckCDAVacuum();

}
//---------------------------------------------------------------------------
// 2022 7 6 - chc Robot Active
void __fastcall TfrnMain::UpdateRobotStatus()
{

   if(boolRobotStatus == true) {
      pnlRobotStatus->Color = clLime;
      pnlRobotReady->Color = clLime;
   }
   else {
      pnlRobotStatus->Color = clRed;
      pnlRobotReady->Color = clRed;

      // 2020 5 6 - chc Log
      if(pnlRobotOriginal->Color != clLime)
         WriteSystemLog("#UpdateRobotStatus(): boolRobotStatus為false!");

   }
}
//---------------------------------------------------------------------------
// 2022 7 6 - chc LoadPort Active
void __fastcall TfrnMain::UpdateLoadPortStatus()
{

   if(boolLoadPortStatus == true) {
      pnlLoadPortStatus->Color = clLime;
      pnlLoadPortReady->Color = clLime;
   }
   else {
      pnlLoadPortStatus->Color = clRed;
      pnlLoadPortReady->Color = clRed;
   }
}
//---------------------------------------------------------------------------
// 2022 7 6 - chc Aligner Active
void __fastcall TfrnMain::UpdateAlignerStatus()
{

   if(boolAlignerStatus == true) {
      pnlAlignerStatus->Color = clLime;
      pnlAlignerReady->Color = clLime;
   }
   else {
      pnlAlignerStatus->Color = clRed;
      pnlAlignerReady->Color = clRed;
   }
}
//---------------------------------------------------------------------------
// Robot Send
void __fastcall TfrnMain::AddRobotSendMessage(AnsiString msg)
{
AnsiString putmsg;

   //putmsg = Now().FormatString("hh':'nn':'ss'-> '") + msg;
   //mmRobotMsg->Lines->Insert(0,putmsg);
   //if(mmRobotMsg->Lines->Count > 400) {
   //   for(int i=370 ; i<mmRobotMsg->Lines->Count ; i++)
   //      mmRobotMsg->Lines->Delete(i);
   //}

   // 2022 9 6 - chc 固定要清除, 否則速度會變慢!
   // 2022 9 14 - chc Demo時做
   // 2022 12 18 - chc 要做
   if(mmRobotMsg->Lines->Count > 400) {
      for(int i=320 ; i<mmRobotMsg->Lines->Count ; i++)
         mmRobotMsg->Lines->Delete(i);
   }

   // 2022 9 14 - chc Add Time
   //putmsg = ">" + msg;
   putmsg = Now().FormatString("nn':'ss':'zzz' '> ") + msg;
   mmRobotMsg->Lines->Insert(0,putmsg);

   //putmsg = Now().FormatString("hh':'nn':'ss'-> '") + msg;
   //mmRobotMsg->Lines->Insert(0,putmsg);
}
//---------------------------------------------------------------------------
// Robot Recv
void __fastcall TfrnMain::AddRobotRecvMessage(AnsiString msg)
{
AnsiString putmsg;

   //putmsg = Now().FormatString("hh':'nn':'ss'-> '") + msg;
   //mmRobotMsg->Lines->Insert(0,putmsg);
   //if(mmRobotMsg->Lines->Count > 400) {
   //   for(int i=370 ; i<mmRobotMsg->Lines->Count ; i++)
   //      mmRobotMsg->Lines->Delete(i);
   //}

   // 2022 9 6 - chc 固定要清除, 否則速度會變慢!
   // 2022 9 14 - chc Demo時做
   // 2022 12 18 - chc 要做
   if(mmRobotMsg->Lines->Count > 400) {
      for(int i=320 ; i<mmRobotMsg->Lines->Count ; i++)
         mmRobotMsg->Lines->Delete(i);
   }

   //putmsg = "<" + msg;
   // 2022 9 14 - chc Add Time
   //putmsg = msg;
   putmsg = Now().FormatString("nn':'ss':'zzz' < '") + msg;
   mmRobotMsg->Lines->Insert(0,putmsg);
   //putmsg = Now().FormatString("hh':'nn':'ss'-> '") + msg;
   //mmRobotMsg->Lines->Insert(0,putmsg);
}
//---------------------------------------------------------------------------
// LoadPort Send
void __fastcall TfrnMain::AddLoadPortSendMessage(AnsiString msg)
{
AnsiString putmsg;

   //putmsg = Now().FormatString("hh':'nn':'ss'-> '") + msg;
   //mmLoadPortMsg->Lines->Insert(0,putmsg);
   //if(mmLoadPortMsg->Lines->Count > 400) {
   //   for(int i=370 ; i<mmLoadPortMsg->Lines->Count ; i++)
   //      mmLoadPortMsg->Lines->Delete(i);
   //}

   // 2022 9 6 - chc 固定要清除, 否則速度會變慢!
   if(mmLoadPortMsg->Lines->Count > 400) {
      for(int i=320 ; i<mmLoadPortMsg->Lines->Count ; i++)
         mmLoadPortMsg->Lines->Delete(i);
   }

   //putmsg = ">" + msg;
   //mmLoadPortMsg->Lines->Insert(0,putmsg);
   putmsg = Now().FormatString("nn':'ss':'zzz' > '") + msg;
   mmLoadPortMsg->Lines->Insert(0,putmsg);
}
//---------------------------------------------------------------------------
// LoadPort Recv
void __fastcall TfrnMain::AddLoadPortRecvMessage(AnsiString msg)
{
AnsiString putmsg;

   //putmsg = Now().FormatString("hh':'nn':'ss'-> '") + msg;
   //mmLoadPortMsg->Lines->Insert(0,putmsg);
   //if(mmLoadPortMsg->Lines->Count > 400) {
   //   for(int i=370 ; i<mmLoadPortMsg->Lines->Count ; i++)
   //      mmLoadPortMsg->Lines->Delete(i);
   //}

   // 2022 9 6 - chc 固定要清除, 否則速度會變慢!
   if(mmLoadPortMsg->Lines->Count > 400) {
      for(int i=320 ; i<mmLoadPortMsg->Lines->Count ; i++)
         mmLoadPortMsg->Lines->Delete(i);
   }

   //putmsg = "<" + msg;
   //putmsg = msg;
   //mmLoadPortMsg->Lines->Insert(0,putmsg);
   putmsg = Now().FormatString("nn':'ss':'zzz' < '") + msg;
   mmLoadPortMsg->Lines->Insert(0,putmsg);
}
//---------------------------------------------------------------------------
// Aliger Send
void __fastcall TfrnMain::AddAlignerSendMessage(AnsiString msg)
{
AnsiString putmsg;

   //putmsg = Now().FormatString("hh':'nn':'ss'-> '") + msg;
   //mmAlignerMsg->Lines->Insert(0,putmsg);
   //if(mmAlignerMsg->Lines->Count > 400) {
   //   for(int i=370 ; i<mmAlignerMsg->Lines->Count ; i++)
   //      mmAlignerMsg->Lines->Delete(i);
   //}

   // 2022 9 6 - chc 固定要清除, 否則速度會變慢!
   if(mmAlignerMsg->Lines->Count > 400) {
      for(int i=320 ; i<mmAlignerMsg->Lines->Count ; i++)
         mmAlignerMsg->Lines->Delete(i);
   }

   //putmsg = ">" + msg;
   //mmAlignerMsg->Lines->Insert(0,putmsg);
   putmsg = Now().FormatString("nn':'ss':'zzz' > '") + msg;
   mmAlignerMsg->Lines->Insert(0,putmsg);
}
//---------------------------------------------------------------------------
// mmAligerMsg Recv
void __fastcall TfrnMain::AddAlignerRecvMessage(AnsiString msg)
{
AnsiString putmsg;

   //putmsg = Now().FormatString("hh':'nn':'ss'-> '") + msg;
   //mmAlignerMsg->Lines->Insert(0,putmsg);
   //if(mmAlignerMsg->Lines->Count > 400) {
   //   for(int i=370 ; i<mmAlignerMsg->Lines->Count ; i++)
   //      mmAlignerMsg->Lines->Delete(i);
   //}

   // 2022 9 6 - chc 固定要清除, 否則速度會變慢!
   if(mmAlignerMsg->Lines->Count > 400) {
      for(int i=320 ; i<mmAlignerMsg->Lines->Count ; i++)
         mmAlignerMsg->Lines->Delete(i);
   }

   //putmsg = "<" + msg;
   //putmsg = msg;
   //mmAlignerMsg->Lines->Insert(0,putmsg);
   putmsg = Now().FormatString("nn':'ss':'zzz' < '") + msg;
   mmAlignerMsg->Lines->Insert(0,putmsg);
}
//---------------------------------------------------------------------------
// LS Command
// OK: STX-001 S4S3S2S1-ETX-LRC
// => 完成的Status?
// NG: STX-001 E-S4S3S2S1E2E1-X-Y-Z-W-ETX-LRC
// GP/SP/Vacuum On/Vacuum Off: 會有0601
bool __fastcall TfrnMain::WaitRobotDone(timems)
{
long starttime,stoptime,elapsedms;
short starttick,stoptick;
// 記錄State : 下完Command, 等0.1sec才進來 WaitRobotDone()
int state = 0;

// 2022 8 22 - chc LS也要縮短時間: boolinLS
bool boolinLS = false;

// 2022 9 14a - chc ROBOT_CMD_STATE_4401_LS
int i4401_LS = 0;

   GetTimeTic(&starttime,&starttick);
   while(1) {

      // log
      WriteSystemLog("WaitRobotDone: State,cmd= " + IntToStr(RobotCmdState) + "," + IntToStr(RobotCmd));

      // 2022 8 15 - chc RobotCmd = ROBOT_CMD_VACUUM
      // 2022 8 22 - chc LS也要縮短時間: boolinLS
      //if(RobotCmd == ROBOT_CMD_VACUUM) {
      if(RobotCmd == ROBOT_CMD_VACUUM || boolinLS == true) {

         // 2022 8 24 - chc 減半
         // 2022 9 12a - chc 時間太短, 會造成連續送LS而Robot無法回應
         //WriteSystemLog("WaitRobotDone(10ms): 1");
         //Sleep(10);
         //WriteSystemLog("WaitRobotDone(10ms): 2");
         WriteSystemLog("WaitRobotDone(250ms): 1");
         // 2022 9 14 - chc 延長至250ms
         //Sleep(110);
         Sleep(110);
         Application->ProcessMessages();
         Sleep(110);
         WriteSystemLog("WaitRobotDone(250ms): 2");

      }
      else {

         // 2022 8 24 - chc 減半
         WriteSystemLog("WaitRobotDone(150ms): 1");
         // 2022 9 14 - chc 延長至150ms
         //Sleep(100);
         Sleep(60);
         Application->ProcessMessages();
         Sleep(60);
         WriteSystemLog("WaitRobotDone(150ms): 2");
      }
      Application->ProcessMessages();
      WriteSystemLog("WaitRobotDone: 3");
      GetTimeTic(&stoptime,&stoptick);
      elapsedms = ((stoptime*1000+stoptick) - (starttime*1000+starttick));
      if(elapsedms > timems) {
         WriteSystemLog("WaitRobotDone: Timeout! " + IntToStr(timems));
         return false;
      }

      WriteSystemLog("WaitRobotDone: 4, " + IntToStr(RobotCmdState) + "," + IntToStr(RobotCmd));
      if(RobotCmdState == ROBOT_CMD_STATE_SENT && RobotCmd == ROBOT_CMD_GP)
         WriteSystemLog("WaitRobotDone: 5");

      // GP Cmd下完要等回覆4401才能下LS
      if((RobotCmdState == ROBOT_CMD_STATE_NONE && RobotCmd != ROBOT_CMD_GP) ||
         (RobotCmdState == ROBOT_CMD_STATE_SENT && RobotCmd == ROBOT_CMD_GP)) {
         WriteSystemLog("WaitRobotDone: 6");

         // 2022 9 12a - chc 不Log
         //if(RobotCmdState == ROBOT_CMD_STATE_SENT && RobotCmd == ROBOT_CMD_GP) {
         //   WriteSystemLog("是Robot GP命令, 已收到4401, 再送出LS!");
         //}

         // 2022 9 12a - chc 4401 + LS後不用再做LS
         if(RobotCmdState == ROBOT_CMD_STATE_SENT && RobotCmd == ROBOT_CMD_GP) {
            WriteSystemLog("是Robot GP命令, 已收到4401, 再送出LS!");

            // 2022 9 22 - chc 不做LS
            if(cbNotLS->Checked == true) {
               WriteSystemLog("不做LS");
            }
            else {

               // 2022 8 22 - chc LS也要縮短時間: boolinLS
               boolinLS = true;

               edRobotCmd->Text = "LS";

               // 2022 9 14 - chc 改用timer
               //btnRobotCMDClick(this);
               // 2022 9 14a - chc 直接呼叫
               //tmRobotLS->Enabled = true;
               tmRobotLSTimer(this);
               i4401_LS = 0;

               // 2022 9 12a - chc 4401後已發出LS
               RobotCmdState = ROBOT_CMD_STATE_4401_LS;
            }

         }

      }

      // 2022 9 14a - chc ROBOT_CMD_STATE_4401_LS
      // => 不做
      //else if(RobotCmdState == ROBOT_CMD_STATE_4401_LS && RobotCmd == ROBOT_CMD_GP) {
      //   WriteSystemLog("仍在4401_LS...");
      //   i4401_LS++;
      //   if(i4401_LS > 2) {
      //      WriteSystemLog("是Robot GP命令, 已收到4401_LS, 再送出LS!");
      //      // LS也要縮短時間: boolinLS
      //      boolinLS = true;
      //      edRobotCmd->Text = "LS";
      //      tmRobotLSTimer(this);
      //   }
      //}

      if(RobotCmdState == ROBOT_CMD_STATE_NONE && RobotCmd == ROBOT_CMD_GP) {
         WriteSystemLog("是Robot GP命令, 但尚未收到4401!");
      }
      if(RobotCmdState == ROBOT_CMD_STATE_DONE) {
         // 要檢查是否已有作動
         if(RobotCmd == ROBOT_CMD_GP) {
            // Robot是否已動作?
            if(boolRobot4401 == false) {
               WriteSystemLog("是Robot GP命令, 已結束(0601)但未收到4401!");

               // 2022 9 22 - chc 不做LS
               if(cbNotLS->Checked == true) {
                  WriteSystemLog("不做LS");
               }
               else {

                  // 不中斷, 再送出LS, 繼續等到Timeout
                  edRobotCmd->Text = "LS";

                  // 2022 9 14 - chc 改用timer
                  //btnRobotCMDClick(this);
                  // 2022 9 14a - chc 直接呼叫
                  //tmRobotLS->Enabled = true;
                  tmRobotLSTimer(this);
                  RobotCmdState = ROBOT_CMD_STATE_0601_LS;

                  continue;
               }
            }
         }

         RobotCmd = ROBOT_CMD_NONE;
         WriteSystemLog("RobotCmd-15 = ROBOT_CMD_NONE");
         return true;
      }
   }
}
//---------------------------------------------------------------------------
// 2022 7 6 - chc Robot點位
bool __fastcall TfrnMain::SendRobotPosCMD(int position)
{
bool ret;

   if(RobotCmd != ROBOT_CMD_NONE) {
      return false;
   }
   RobotCmdState = ROBOT_CMD_STATE_NONE;

   WriteSystemLog("RobotCmdState-14 = ROBOT_CMD_STATE_NONE");
   RobotCmd = ROBOT_CMD_GP;
   WriteSystemLog("RobotCmd-16 = ROBOT_CMD_GP");
   edRobotCmd->Text = "GP " + IntToStr(position);
   // 要Refresh
   edRobotCmd->Refresh();

   // Robot是否已動作?
   boolRobot4401 = false;

   btnRobotCMDClick(this);
   ret = WaitRobotDone(10000);
   if(ret == true)
      return true;
   return false;
}
//---------------------------------------------------------------------------
// CassetteBuffer[]
// pnlTray25
// 0：no wafer exists
// 1：wafer exists
// 2：Cross
// 3：Thickness error（Thick）
// 4：Thickness error（Thin）
// 5：position error
// mode: 0-Clear, 1-Set

void __fastcall TfrnMain::UpdateCassetteState(int mode)
{
TPanel *panel,*panel1,*panela;
bool first = true;

   // Set Mapping Status
   boolMappingStatus = true;

   for(int i=0 ; i<25 ; i++) {
      panel = (TPanel*)(FindComponent("pnlTray" + IntToStr(i+1)));
      panel1 = (TPanel*)(FindComponent("pnlTray" + IntToStr(i+1) + "Select"));
      panela = (TPanel*)(frmRecipe->FindComponent("pnlTray" + IntToStr(i+1)));
      // Set
      if(mode == 1) {
         if(CassetteBuffer[i] == '0') {
            panel->Color = clSilver;
            panela->Color = clSilver;
            panel1->Enabled = false;
            panel1->Color = clGray;
         }
         else if(CassetteBuffer[i] == '1') {
            panel->Color = clLime;
            panela->Color = clLime;
            panel1->Enabled = true;
            panel1->Color = clLime;

            // 第一片位置
            // 小到大
            if(rgLoadOrder->ItemIndex == 0) {
               if(first == true) {
                  first = false;
                  rgWaferNo->ItemIndex = 24 - i;
               }
            }
            // 大到小
            else {
               rgWaferNo->ItemIndex = 24 - i;
            }

         }
         else {
            panel->Color = clRed;
            panela->Color = clRed;
            panel1->Enabled = false;
            panel1->Color = clGray;

            // 2020 7 17 - chc Set Mapping Status
            boolMappingStatus = false;

         }
      }
      // Clear: ORGN(UnLoad)
      else {
         CassetteBuffer[i] = '0';
         panel->Color = clSilver;
         panela->Color = clSilver;
         panel1->Enabled = false;
         panel1->Color = clGray;
      }
   }
}
//---------------------------------------------------------------------------
//unsigned char LoadPortStatus[20];
void __fastcall TfrnMain::UpdateLoadPortStatus_1()
{
TPanel *panel;
AnsiString msg;

   for(int i=0 ; i<20 ; i++) {
      // pnlLoadPortS1
      panel = (TPanel*)(FindComponent("pnlLoadPortS" + IntToStr(i+1)));
      msg.sprintf("%c",LoadPortStatus[i]);
      panel->Caption = msg;
   }
}
//---------------------------------------------------------------------------
//unsigned char AlignerStatus[15];
// A B C D EE FFF G H I JJJ
// 0 1 2 3 45 678 9 0 1 234
// 0 1 2 3 4  5   6 7 8 9
void __fastcall TfrnMain::UpdateAlignerStatus_1()
{
TPanel *panel;
AnsiString msg;

   for(int i=0 ; i<10 ; i++) {
      // pnlAlignerS1
      panel = (TPanel*)(FindComponent("pnlAlignerS" + IntToStr(i+1)));
      switch(i) {
         case 0:
         case 1:
         case 2:
         case 3:
            msg.sprintf("%c",AlignerStatus[i]);
            panel->Caption = msg;
            break;
         case 4:
            msg.sprintf("%c%c",AlignerStatus[4],AlignerStatus[5]);
            panel->Caption = msg;
            // Error code
            pnlAlignerErrorCode->Caption = msg;
            pnlAlignerErrorCode1->Caption = msg;
            break;
         case 5:
            msg.sprintf("%c%c%c",AlignerStatus[6],AlignerStatus[7],AlignerStatus[8]);
            panel->Caption = msg;
            // 011 - 無片, 111- 有片
            if(msg == "011")
               pnlAlignerWithWafer->Color = clSilver;
            else
               pnlAlignerWithWafer->Color = clLime;
            break;
         case 6:
            msg.sprintf("%c",AlignerStatus[9]);
            panel->Caption = msg;
            break;
         case 7:
            msg.sprintf("%c",AlignerStatus[10]);
            panel->Caption = msg;
            break;
         case 8:
            msg.sprintf("%c",AlignerStatus[11]);
            panel->Caption = msg;
            break;
         case 9:
            msg.sprintf("%c%c%c",AlignerStatus[12],AlignerStatus[13],AlignerStatus[14]);
            panel->Caption = msg;
            break;
      }
   }
}
//---------------------------------------------------------------------------
                  // Error(10碼): Robotstatus(4 character; S4S3S2S1) + Errorcode(2 characters; E2E1) + ErrorAxisInformation(4 characters - XYZW)
                  // S1: 0- 1：ON-LINE MODE
                  //     1- 1：MANUAL MODE
                  //     2- 1：AUTO MODE
                  //     3- 0：Fixed
                  //     4- 1：Fixed
                  //     5- 1：Fixed
                  //     6- 0：Fixed
                  //     7- Not Used
                  // MANUAL MODE is the switch to enable the automatic operation of the controller.
                  // When MANUAL is selected, the teach pendant is in one of KEY-IN,
                  // TEACH, and CHECK mode.i
                  // S1=“0”=0x30 ........................ After ON-LINE mode, and switches the key switch to the MANUAL
                  // S1=“1”=0x31 ............................. ON-LINE mode
                  // S1=“2”=0x32 ............................. MANUAL mode
                  // S1=“4”=0x34 ............................. AUTO mode
                  // S2: 0- 0：Fixed
                  //     1- 1：STOP signal ON / 0: STOP signal OF
                  //     2- 1：in ES (emergency stop) / 0: not in ES
                  //     3- 0：Fixed
                  //     4- 1：Fixed
                  //     5- 1：Fixed
                  //     6- 0：Fixed
                  //     7- Not Used
                  // STOP signal is turned ON in operation prohibited status due to GD(operation prohibiting) command.
                  // S2=“1”＝0x31............................ Not in ES and STOP signal is not ON.
                  // S2=“2”＝0x32............................ STOP signal is ON.
                  // S2=“4”＝0x34............................ in ES
                  // S2=“6”＝0x36............................ In ES and STOP signal is ON.
                  // S3: 0- 0：Z-axis zone output (SAFTY ZONE)
                  //     1- 1：Positioning completed / 0: not completed
                  //     2- 1：A-CAL completed / 0: not completed
                  //     3- 0：Fixed
                  //     4- 1：Fixed
                  //     5- 1：Fixed
                  //     6- 0：Fixed
                  //     7- Not Used
                  // Z-axis zone outputi is set to "1" when the following condition is satisfied.
                  // The Z-axis coordinate is located at a higher position (smaller value)
                  //      than the value set in System Parameter → [RESPONSE] →[RESPONCE] → [SAFE. ZONE].
                  // S3=“0”＝0x30: Neither A-CAL nor positioning has been completed.
                  // S3=“2”＝0x32: Positioning has been completed.
                  // S3=“4”＝0x34: A-CAL has been completed but positioning has not.
                  // S3=“6”＝0x36: Both A-CAL and positioning have been completed.
                  // S4: 0- 0：Fixed
                  //     1- 0：Fixed
                  //     2- 1：Executing action command 0: End
                  //     3- 0：Fixed
                  //     4- 1：Fixed
                  //     5- 1：Fixed
                  //     6- 0：Fixed
                  //     7- Not Used
                  // When the robot is being operated by GP and GZ commands, S4 character is "1".
                  // Therefore, “S4+S3+S2+S1”＝[0x30][0x36][0x30][0x31]=“0601” shows that the
                  // robot is in the following status.
                  //      ◆ In ON-LINE MODE
                  //      ◆ A-CAL completed
                  //      ◆ Positioning completed
                  // E2 E1 Error Description
                  //      00 Normal status (no error)
                  //      09 Positioning error (Refer to error axis information.)
                  //      10 Emergency stop state
                  //      20 A-CAL does not end normally. (Refer to error axis information.)
                  //      30 The address is out of the limit.
                  //      31 The robot was tried to be moved to the END(??) point.
                  //      32 FAN alarm status (When FAN alarm function is active.)
                  //      40 The position data is out of the limited area. (Refer to error axis information.)
                  //      51 The robot is in overrun status. (Refer to error axis information.)
                  //      61 Communication command error
                  //      62 A command which could not be executed in the current mode was received.
                  //      63 System data (SG, SP) is corrupted.
                  //      64 The position data cannot be read from the memory card.
                  //      67 Servo parameter is corrupted.
                  //      70 Low encoder battery
                  //      80 The robot received another command during command processing.
                  //      82 Sensor input does not turn ON. (When sensor stop function is active.)
                  //      84 The measurement result is out of the range. (When glass alignment function is active.)
                  //      90 The robot was tried to be operated before A-CAL had been completed.
                  //      95 Coordinate transformation error: The specified position data is invalid.
                  //      A0 Driver error (Refer to error axis information.)
                  //      B0 Servo lock does not work.
                  //      C0 Program error (When HARL-U2 is in use.)
                  //      D0 Aligner error: The line sensor cannot be initialized.
                  //      D1 Aligner error: The wafer edge cannot be detected.
                  //      D3 Aligner error: Too much scans
                  //      D5 Aligner error: The pivot axis rotation frequency is not sufficient.
                  //      D7 Aligner error: The correction amount exceeds the set value.
                  //      D8 Aligner error: Wrong transfer robot is specified.
                  //      D9 Aligner error: Wrong axis is specified for correction output.
                  //      DA Aligner error: Wrong address is specified for correction output.
                  //      DB Aligner error: Wrong direction is specified for motor rotation.
                  //      DC Aligner error: Wrong parameter is specified.
                  //      E0 Axis interlock (When axis interlock function is active.)
                  //      E1, E2=“0”∼“9”(0x30∼0x39): “A”∼“F”(0x41∼0x46)
                  // Axis-Error
                  //      When a positioning error (09)
                  //        0: Normal
                  //        1: Abnormal
                  //      When an A-CAL error (20)
                  //        0: Normal
                  //        1: Abnormal
                  //      When an overrun error (51) has occurred
                  //        0: Normal
                  //        1: Origin side
                  //        2: Overrun side
                  //        3: Both sides
                  //      When a position data outside limited area error (40) has occurred
                  //        0: Normal
                  //        1: Lower limit side
                  //        2: Upper limit side
                  //      When a driver error (A0) has occurred
                  //        0: Normal
                  //        1: Abnormal
                  // 10碼: ErrorCode
// 12Bytes: 001 E [S4 S3 S2 S1 E2 E1 AX AY AZ AW AR AC]
// Therefore, “S4+S3+S2+S1”＝[0x30][0x36][0x30][0x31]=“0601” shows that the
// robot is in the following status.
// ◆ In ON-LINE MODE
// ◆ A-CAL completed
// ◆ Positioning completed
// When a positioning error (09) has occurred, the information shows if each
// axis is normal or abnormal by using the following values
// 0 - Normal, 1 - Abnormal
// RobotStatus[12]
// 060262000000
// mode 0-S4S3S2S1, 1-All(12 Digits)
void __fastcall TfrnMain::UpdateRobotStatus_1(int mode)
{
TPanel *panel;
AnsiString msg;
int code,bit;
int cnt;

   // 區分是否全部?
   if(mode == 0)
      cnt = 4;
   else
      cnt = 12;
   for(int i=0 ; i<cnt ; i++) {
      // pnlAlignerS1
      switch(i) {
         // S4 S3 S2 S1
         //pnlRobotS40
         case 0:
         case 1:
         case 2:
         case 3:
            code = RobotStatus[i] - '0';
            bit = 0x01;
            for(int j=0 ; j<8 ; j++) {
               if(i == 0)
                  panel = (TPanel*)(FindComponent("pnlRobotS4" + IntToStr(j)));
               else if(i == 1)
                  panel = (TPanel*)(FindComponent("pnlRobotS3" + IntToStr(j)));
               else if(i == 2)
                  panel = (TPanel*)(FindComponent("pnlRobotS2" + IntToStr(j)));
               else if(i == 3)
                  panel = (TPanel*)(FindComponent("pnlRobotS1" + IntToStr(j)));
               if((code & bit) != 0)
                  panel->Color = clLime;
               else
                  panel->Color = clSilver;
               bit = bit << 1;
            }
            break;
         case 4:
            msg.sprintf("%c",RobotStatus[4]);
            pnlRobotE2->Caption = msg;
            break;
         case 5:
            msg.sprintf("%c",RobotStatus[5]);
            pnlRobotE1->Caption = msg;

            // 2020 5 20 - chc Error code
            pnlRobotErrorCode->Caption = pnlRobotE2->Caption + pnlRobotE1->Caption;
            pnlRobotErrorCode1->Caption = pnlRobotErrorCode->Caption;

            break;
         case 6:
            msg.sprintf("%c",RobotStatus[6]);
            pnlRobotAX->Caption = msg;
            break;
         case 7:
            msg.sprintf("%c",RobotStatus[7]);
            pnlRobotAY->Caption = msg;
            break;
         case 8:
            msg.sprintf("%c",RobotStatus[8]);
            pnlRobotAZ->Caption = msg;
            break;
         case 9:
            msg.sprintf("%c",RobotStatus[9]);
            pnlRobotAW->Caption = msg;
            break;
         case 10:
            msg.sprintf("%c",RobotStatus[10]);
            pnlRobotAR->Caption = msg;
            break;
         case 11:
            msg.sprintf("%c",RobotStatus[11]);
            pnlRobotAC->Caption = msg;
            break;
      }
   }
}
//---------------------------------------------------------------------------
bool __fastcall TfrnMain::WaitLoadPortDone(timems)
{
long starttime,stoptime,elapsedms;
short starttick,stoptick;

   GetTimeTic(&starttime,&starttick);
   while(1) {
      Sleep(10);
      Application->ProcessMessages();
      GetTimeTic(&stoptime,&stoptick);
      elapsedms = ((stoptime*1000+stoptick) - (starttime*1000+starttick));
      if(elapsedms > timems)
         return false;
      if(pnlLoadPortOperation->Caption != "Busy")
         return true;
   }
}
//---------------------------------------------------------------------------
bool __fastcall TfrnMain::WaitLoadPort2Done(timems)
{
long starttime,stoptime,elapsedms;
short starttick,stoptick;

   GetTimeTic(&starttime,&starttick);
   while(1) {
      Sleep(10);
      Application->ProcessMessages();
      GetTimeTic(&stoptime,&stoptick);
      elapsedms = ((stoptime*1000+stoptick) - (starttime*1000+starttick));
      if(elapsedms > timems)
         return false;
      if(pnlLoadPort2Operation->Caption != "Busy")
         return true;
   }
}
//---------------------------------------------------------------------------
//unsigned char LoadPortLED[8];
void __fastcall TfrnMain::UpdateLoadPortLED_1()
{
TPanel *panel;
AnsiString msg;

   for(int i=0 ; i<8 ; i++) {
      switch(i) {
         case 0:
            panel = pnlLoadPortPresence;
            break;
         case 1:
            panel = pnlLoadPortPlacement;
            break;
         case 2:
            panel = pnlLoadPortLoad;
            break;
         case 3:
            panel = pnlLoadPortUnLoad;
            break;
         case 4:
            return;
            break;
         case 5:
            panel = pnlLoadPortStatus1;
            break;
         case 6:
            panel = pnlLoadPortStatus2;
            break;
         case 7:
            return;
            break;
      }
      if(LoadPortLED[i] == '0')
         panel->Color = clSilver;
      else if(LoadPortLED[i] == '1')
         panel->Color = clLime;
      else if(LoadPortLED[i] == '2')
         panel->Color = clYellow;

      // Load
      if(i == 2) {
         pnlEFEMCassette->Color = panel->Color;
         if(panel->Color == clLime) {
            btnCassetteLoad->Caption = "UnLoad";
            frmRecipe->btnCassetteLoad->Caption = "UnLoad";

            // 2020 5 21 - chc 可以取片
            btnLoadWafer->Enabled = true;

         }
      }
      // UnLoad
      if(i == 3) {
         pnlEFEMCassette->Color = panel->Color;
         if(panel->Color == clLime) {
            btnCassetteLoad->Caption = "Load";
            frmRecipe->btnCassetteLoad->Caption = "Load";

            // 2020 5 21 - chc 不可以取片
            btnLoadWafer->Enabled = false;

         }
      }

   }
}
//---------------------------------------------------------------------------
// 2022 12 19 - chc Tazmo
AnsiString RobotCommandCode = "";
bool boolRobotAck = false;
bool boolRobotComplete = false;
bool boolRobotNak = false;

// 2022 7 6 - chc 原點
// GP 1 / GP 0
void __fastcall TfrnMain::btnRobotOriginalClick(TObject *Sender)
{

   pnlRobotOriginal->Color = clSilver;

   // 2022 12 19 - chc Tazmo
   if(RobotMode != ROBOT_MODE_TAZMO) {
      if(SendRobotPosCMD(1) == false) {
         pnlRobotOriginal->Color = clRed;
         return;
      }

      // 等待
      WaitTime(1000);

      if(SendRobotPosCMD(0) == false) {
         pnlRobotOriginal->Color = clRed;
         return;
      }
      pnlRobotOriginal->Color = clLime;
      return;
   }

bool ret;
bool first = true;

again:
   RobotCmd = ROBOT_CMD_RST;
   WriteSystemLog("RobotCmd-16 = ROBOT_CMD_RST");
   edRobotCmd->Text = "RST";
   // 要Refresh
   edRobotCmd->Refresh();
   btnRobotCMDClick(this);
   ret = WaitTMRobotDone(30000);
   if(ret == true)
      pnlRobotOriginal->Color = clLime;
   else
      pnlRobotOriginal->Color = clRed;

   // Again
   if(boolRobotNak == true && first == true) {
      first = false;
      WriteSystemLog("RobotCmd-16 = ROBOT_CMD_RST Again");
      WaitTime(1000);
      goto again;
   }

   return;

}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnLoadPortStasClick(TObject *Sender)
{

   edLoadPortCmd->Text = "GET:STAS;";
   btnLoadPortCMDClick(this);
}
//---------------------------------------------------------------------------
// 2022 7 6 - chc LoadPort
// GET:MAPR;
// 0000GET:MDAT/0000000000000000000000000;1A*( bottem to top)
void __fastcall TfrnMain::btnLoadPortCMDClick(TObject *Sender)
{

unsigned char command[50],buf[50];
AnsiString msg;
int len,cs1,cs2;
unsigned char checksum;

   if(boolLoadPortStatus == false) {
      pnlLoadPortMessage->Caption = "未連線!";
      return;
   }

   sprintf(command,"0000%s",edLoadPortCmd->Text);
   len = strlen(command);
   checksum = 0;
   for(int i=0 ; i<len ; i++) {
      checksum += command[i];
   }

   // LoadPort
   int c1,c2;
   c1 = checksum & 0xf0;
   c1 = c1 >> 4;
   c2 = checksum & 0x0f;
   if(c1 < 10)
      c1 = c1 + '0';
   else
      c1 = c1 - 10 + 'A';
   if(c2 < 10)
      c2 = c2 + '0';
   else
      c2 = c2 - 10 + 'A';
   sprintf(buf,"%c%s%c%c%c",0x01,command,c1,c2,0x0d);

   len = strlen(buf);
   buf[len] = 0x0;
   ybLoadPort->Write(buf,len);
   pnlLoadPortOperation->Caption = "Busy";
   pnlLoadPort->Enabled = false;
   btnLoadPortEnable->Visible = true;

   msg.sprintf("CMD: %s",command);
   pnlSystemMessage->Caption = msg;
   WriteSystemLog(msg);

   // 2020 5 6 - chc 不能有Sleep, 會卡住!
   //Sleep(100);

   AddLoadPortSendMessage(edLoadPortCmd->Text);
   pnlLoadPortMessage->Caption = msg;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnLoadPortUnLoadClick(TObject *Sender)
{

   // 先做Robot ORGN(GP1/GP0) & 偵測pnlLoadPortS12是否為1?
   if(BeforeLoadPortLoadUnload() == false) {
      return;
   }

   edLoadPortCmd->Text = "MOV:ORGN;";
   btnLoadPortCMDClick(this);
}
//---------------------------------------------------------------------------
bool boolAlignerORGN = false;
// 2022 8 16 - chc 因在Wait中, 其它Process無法插入! 改交由Timer來做 : iAlignerORGNDone
int iAlignerORGNDone = 0;
int iAligner2ORGNDone = 0;

void __fastcall TfrnMain::btnAlignerORGNClick(TObject *Sender)
{

   // 2022 12 19 - chc Tazmo
   if(RobotMode == ROBOT_MODE_TAZMO) {
bool ret;

      pnlAlignerORGN->Color = clSilver;
      edAlignerCmd->Text = "HOM";
      // 要Refresh
      edAlignerCmd->Refresh();
      btnAlignerCMDClick(this);
      ret = WaitTMAlignerDone(30000);
      if(ret == true)
         pnlAlignerORGN->Color = clLime;
      else {
         pnlAlignerORGN->Color = clRed;
         return;
      }

      WaitTime(1000);

      pnlAlignerORGN->Color = clSilver;
      edAlignerCmd->Text = "PRP,A";
      // 要Refresh
      edAlignerCmd->Refresh();
      btnAlignerCMDClick(this);
      ret = WaitTMAlignerDone(30000);
      if(ret == true) {
         pnlAlignerORGN->Color = clLime;
         boolAlignerORGN = true;
      }
      else
         pnlAlignerORGN->Color = clRed;
      return;
   }

   pnlAlignerORGN->Color = clSilver;
   edAlignerCmd->Text = "MOV:ORGN;";
   WriteSystemLog("執行Aligner ORGN...");
   btnAlignerCMDClick(this);

   // 2022 8 11 - chc Check Timeout : 等ORGN完成, 送出STAS
   // 2022 8 16 - chc 因在Wait中, 其它Process無法插入! 改交由Timer來做 : iAlignerORGNDone
   /*
   int cnt = 0;
   // 5sec
   int max = 100;
   while(1) {
      if(pnlAlignerORGN->Color == clRed)
         break;
      // 發出STAS
      if(pnlAlignerORGN->Color == clLime) {
         WriteSystemLog("btnAlignerORGNClick: 完成ORGN, 發出GET:STAS;");
         btnAlignerStasClick(this);
         break;
      }
      Sleep(50);
      Application->ProcessMessages();
      cnt++;
      if(cnt > max) {
         WriteSystemLog("btnAlignerORGNClick: 等完成ORGN(5sec) Timeout!");
         break;
      }
      WriteSystemLog("Wait...");
   }
   WriteSystemLog("執行Aligner ORGN.");
   */
   WriteSystemLog("確認Aligner ORGN是否完成, 改由Timer處理.");
   iAlignerORGNDone = 0;
   tmAlignerORGNDone->Enabled = true;

}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnRobotCMDClick(TObject *Sender)
{

unsigned char command[50],buf[50];
AnsiString msg;
int len,cs1,cs2;
char checksum;

// 使用或不使用unsigned均一樣的結果GP 880 ( 0 0 40 0)
unsigned char checksum1;

   if(boolRobotStatus == false) {
      pnlRobotMessage->Caption = "未連線!";
      WriteSystemLog("btnRobotCMDClick: Robot尚未連線!");
      return;
   }

   // 2022 12 19 - chc Tazmo
   if(RobotMode != ROBOT_MODE_TAZMO) {
      // robot
      if(cbRobot->Checked == true)
         sprintf(command,"001 %s%c",edRobotCmd->Text,0x03);
      else
         // Aligner
         sprintf(command,"0000%s",edRobotCmd->Text);

      len = strlen(command);
      checksum = 0;
      checksum1 = 0;
      for(int i=0 ; i<len ; i++) {
         // Robot
         if(cbRobot->Checked == true) {
            checksum ^= command[i];
            checksum1 ^= command[i];
         }
         else
            // Aligner
            checksum += command[i];
      }

      // Robot
      if(cbRobot->Checked == true) {
         sprintf(buf,"%c%s",0x02,command);
         len = strlen(buf);
         sprintf(buf,"%c%s%c",0x02,command,checksum);
         len++;
         buf[len] = 0x0;
      }
      else {
         // Aligner
         int c1,c2;
         c1 = checksum & 0xf0;
         c1 = c1 >> 4;
         c2 = checksum & 0x0f;
         if(c1 < 10)
            c1 = c1 + '0';
         else
            c1 = c1 - 10 + 'A';
         if(c2 < 10)
            c2 = c2 + '0';
         else
            c2 = c2 - 10 + 'A';
         sprintf(buf,"%c%s%c%c%c",0x01,command,c1,c2,0x0d);
         len = strlen(buf);
         buf[len] = 0x0;
      }
   }
   else {

      boolRobotAck = false;
      boolRobotComplete = false;
      boolRobotNak = false;

      sprintf(command,"%s",edRobotCmd->Text);
      sprintf(buf,"%s%c",command,0x0d);
      len = strlen(buf);

      RobotCommandCode = "";
      if(edRobotCmd->Text.Length() >= 3)
         RobotCommandCode = edRobotCmd->Text.SubString(1,3);
   }

   WriteSystemLog("btnRobotCMDClick: run...");
   ybRobot->Write(buf,len);
   pnlRobotOperation->Caption = "Busy";
   pnlRobot->Enabled = false;
   btnRobotEnable->Visible = true;

   msg.sprintf("CMD: %s",command);
   pnlSystemMessage->Caption = msg;
   WriteSystemLog(msg);

   // 不能有Sleep, 會卡住!
   //Sleep(100);

   AddRobotSendMessage(edRobotCmd->Text);
   pnlRobotMessage->Caption = msg;
   WriteSystemLog("btnRobotCMDClick: edRobotCmd= " + edRobotCmd->Text);

   // 2022 12 19 - chc Tazmo
   if(RobotMode != ROBOT_MODE_TAZMO) {
      // GP要WaitRobotDone
      if(edRobotCmd->Text.SubString(1,3) == "GP") {
         bool ret;
         RobotCmdState = ROBOT_CMD_STATE_NONE;
         WriteSystemLog("RobotCmdState-5 = ROBOT_CMD_STATE_NONE");
         RobotCmd = ROBOT_CMD_GP;
         WriteSystemLog("RobotCmd-4 = ROBOT_CMD_GP");
         // Robot是否已動作?
         boolRobot4401 = false;
         ret = WaitRobotDone(10000);
         if(ret == false) {
            pnlRobotMessage->Caption = edRobotCmd->Text + ": Timeout!";
            return;
         }
      }
   }

}
//---------------------------------------------------------------------------
// 2022 7 6 - chc 先做Robot ORGN(GP1/GP0) & 偵測pnlLoadPortS12是否為1?
bool __fastcall TfrnMain::BeforeLoadPortLoadUnload()
{

   if(pnlRobot->Enabled == false) {
      pnlLoadPortMessage->Caption = "Robot無法作動!";
      pnlAlarmMessage->Caption = pnlLoadPortMessage->Caption;
      return false;
   }
   // Robot原點
   btnRobotOriginalClick(this);
   if(pnlRobotOriginal->Color != clLime) {
      pnlLoadPortMessage->Caption = "Robot無法回原點!";
      pnlAlarmMessage->Caption = pnlLoadPortMessage->Caption;
      return false;
   }

   // 2022 12 27 - chc Tazmo
   if(RobotMode != ROBOT_MODE_TAZMO) {

      // LR: 取得位置 GP 880 ( 0 0 20 0) => 001 210 0 82 270.26L 0
      // LR: 取得位置 GP 881 ( 0 0 20 0) => 001 677.9 0 82 270.26L 0
      //                                    12345678901234567890
      // L
      //   For SCALAR type robot, "R" is right arm (RIGHT) and "L" is left arm (LEFT).
      //   For orthogonal type robot, the arm attitude is fixed to "L".
      // 最後碼固定為0
      // X < 300為安全
      btnRobotGetPositionClick(this);
      if(boolRobotLRCommand == true)
         WriteSystemLog("Wait前boolRobotLRCommand 是 true");
      else
         WriteSystemLog("Wait前boolRobotLRCommand 是 false");
      WaitTime(1000);
      if(boolRobotLRCommand == true) {
         WriteSystemLog("Wait後boolRobotLRCommand 是 true!");
         pnlLoadPortMessage->Caption = "Robot讀X異常!";
         WriteSystemLog(pnlLoadPortMessage->Caption);
         pnlAlarmMessage->Caption = pnlLoadPortMessage->Caption;
         return false;
      }
      else
         WriteSystemLog("Wait後boolRobotLRCommand 是 false");
      if(RobotXPosition > 300) {
         pnlLoadPortMessage->Caption = "Robot X過大! " + IntToStr(RobotXPosition);
         WriteSystemLog(pnlLoadPortMessage->Caption);
         pnlAlarmMessage->Caption = pnlLoadPortMessage->Caption;
         return false;
      }
   }

   // 取得LoadPort Status
   // 2020 5 6 - chc 不能看S12
   /*
   btnLoadPortStasClick(this);
   WaitTime(1000);
   if(pnlLoadPort->Enabled == false) {
      pnlLoadPortMessage->Caption = "LoadPort作動異常!";
      return false;
   }
   // 看Protrution? 1-Ok, 0-NG(有東西)
   if(pnlLoadPortS12->Caption != "1") {
      pnlLoadPortMessage->Caption = "LoadPort柵有障礙物!";
      return false;
   }
   */

   return true;
}
//---------------------------------------------------------------------------
// 2022 12 19 - chc Tazmo
AnsiString AlignerCommandCode = "";
bool boolAlignerAck = false;
bool boolAlignerComplete = false;
bool boolAlignerNak = false;

// 2022 7 6 - chc Aligner
void __fastcall TfrnMain::btnAlignerCMDClick(TObject *Sender)
{

unsigned char command[50],buf[50];
AnsiString msg;
int len,cs1,cs2;
unsigned char checksum;

   if(boolAlignerStatus == false) {
      pnlAlignerMessage->Caption = "未連線!";
      return;
   }

   // 2022 12 19 - chc Tazmo
   if(RobotMode != ROBOT_MODE_TAZMO) {
      // Aligner
      sprintf(command,"0000%s",edAlignerCmd->Text);

      len = strlen(command);
      checksum = 0;
      for(int i=0 ; i<len ; i++) {
         checksum += command[i];
      }

      int c1,c2;
      c1 = checksum & 0xf0;
      c1 = c1 >> 4;
      c2 = checksum & 0x0f;
      if(c1 < 10)
         c1 = c1 + '0';
      else
         c1 = c1 - 10 + 'A';
      if(c2 < 10)
         c2 = c2 + '0';
      else
         c2 = c2 - 10 + 'A';
      sprintf(buf,"%c%s%c%c%c",0x01,command,c1,c2,0x0d);

      len = strlen(buf);
      buf[len] = 0x0;

      // 改慢速送
      //ybAligner->Write(buf,len);
      for(int i=0 ; i<len ; i++) {
         ybAligner->Write(&buf[i],1);
         Sleep(20);
      }
   }
   else {

      boolAlignerAck = false;
      boolAlignerComplete = false;
      boolAlignerNak = false;
      sprintf(command,"%s",edAlignerCmd->Text);
      sprintf(buf,"%s%c",command,0x0d);
      len = strlen(buf);
      AlignerCommandCode = "";
      if(edAlignerCmd->Text.Length() >= 3)
         AlignerCommandCode = edAlignerCmd->Text.SubString(1,3);
      WriteSystemLog("btnAlignerCMDClick: run...");
      ybAligner->Write(buf,len);
   }

   pnlAlignerOperation->Caption = "Busy";
   pnlAligner->Enabled = false;
   btnAlignerEnable->Visible = true;

   msg.sprintf("CMD: %s",command);
   pnlSystemMessage->Caption = msg;
   WriteSystemLog(msg);

   // 2020 5 6 - chc 不能有Sleep, 會卡住!
   //Sleep(100);

   AddAlignerSendMessage(edAlignerCmd->Text);
   pnlAlignerMessage->Caption = msg;

}
//---------------------------------------------------------------------------
// LR
void __fastcall TfrnMain::btnRobotGetPositionClick(TObject *Sender)
{

   pnlRobotXPosition->Caption = "";
   boolRobotLRCommand = true;
   WriteSystemLog("Set boolRobotLRCommand = true");
   edRobotCmd->Text = "LR";
   btnRobotCMDClick(this);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::cbEFEMClick(TObject *Sender)
{

   pnlEFEM->Visible = cbEFEM->Checked;
   pnlEFEM2->Visible = cbEFEM->Checked;
   //if(cbEFEM->Checked == true)
   //   frnMain->pnlSystem->Visible = false;
}
//---------------------------------------------------------------------------
// Robot是一個命令一個回覆
// Tazmo
//（１）ENQ Communication line check（05H）
//（２）ACK Positive response（06H）
//（３）NAK Negative response（15H）
//（４）BUSY Busy （11H）
//AnsiString RobotCommandCode = "";
//bool boolRobotAck = false;
//bool boolRobotComplete = false;
//bool boolRobotNak = false;
#define ENQ                     0x05
#define ACK                     0x06
#define NAK                     0x15
#define BUSY                    0x11
#define CR                      0x0d

void __fastcall TfrnMain::ybRobotCommNotify(TObject *Sender,
      int NotifyType)
{
char Buf[8192+1];
AnsiString msg,lcode;
int len,pos,n;
bool boolstas = false;
bool boolclearerrorcode = false;

   // 2022 12 19 - chc Tazmo
   if(RobotMode == ROBOT_MODE_TAZMO) {
      // 先不管
      //if(NotifyType == EV_RXCHAR) {

         n = ybRobot->Read(Buf,8192);
         if(n > 0) {
            Buf[n] = 0;
            for(int i=0 ; i<n ; i++) {
               // 0x03
               if(Buf[i] == ACK || Buf[i] == NAK || Buf[i] == BUSY || Buf[i] == CR) {
                  // Display
                  if(Buf[i] == ACK)
                     lcode = "[Ack]";
                  else if(Buf[i] == NAK)
                     lcode = "[Nak]";
                  else if(Buf[i] == BUSY)
                     lcode = "[Busy]";
                  else if(Buf[i] == CR)
                     lcode = ReplyStrRobot + "[Cr]";
                  AddRobotRecvMessage(lcode);
                  WriteSystemLog("Robot Recv= " + lcode);

                  if(Buf[i] == ACK) {
                     boolRobotAck = true;
                     WriteSystemLog("RobotCmd-1 = [Ack]");
                  }
                  else if(Buf[i] == NAK) {
                     boolRobotNak = true;
                     WriteSystemLog("RobotCmd-1 = [Nak]");
                  }
                  else if(Buf[i] == BUSY) {
                     WriteSystemLog("RobotCmd-1 = [Busy]");
                  }
                  else if(Buf[i] == CR) {
                     WriteSystemLog("RobotCmd-1 = [Cr]");
                     if(ReplyStrRobot.SubString(1,3) == "ERR") {
                        boolRobotNak = true;
                        WriteSystemLog("RobotCmd-1 = [Err]");
                     }
                     else if(ReplyStrRobot.SubString(1,3) == RobotCommandCode) {
                        tmRobotAck->Enabled = true;
                        boolRobotComplete = true;
                        pnlRobotOperation->Caption = "Ready";
                        pnlRobot->Enabled = true;
                        if(ReplyStrRobot.SubString(1,3) == "STS") {
                           // STS,100[Cr]
                           // 123456789
                           pnlRobotWaferStatus->Caption = ReplyStrRobot.SubString(5,3);
                           //if(pnlAlingerStatus->Caption == "020") {
                           //   pnlRobotWithWafer->Color = clSilver;
                           //   RobotWithWafer = ROBOT_WAFER_NO;
                           //}
                           //else if(pnlAlingerStatus->Caption == "021") {
                           //   pnlRobotWithWafer->Color = clLime;
                           //   RobotWithWafer = ROBOT_WAFER_YES;
                           //}
                        }
                        // WCH,2,1
                        // 12345678
                        else if(ReplyStrRobot.SubString(1,3) == "WCH") {
                           if(ReplyStrRobot.SubString(7,1) == "1") {
                              pnlRobotWithWafer->Color = clLime;
                              RobotWithWafer = ROBOT_WAFER_YES;
                              frmMaintenance->pnlRobotWithWafer->Color = clLime;
                           }
                           else if(ReplyStrRobot.SubString(7,1) == "0") {
                              pnlRobotWithWafer->Color = clSilver;
                              RobotWithWafer = ROBOT_WAFER_NO;
                              frmMaintenance->pnlRobotWithWafer->Color = clSilver;
                           }
                           else {
                              pnlRobotWithWafer->Color = clRed;
                              RobotWithWafer = ROBOT_WAFER_NO;
                              frmMaintenance->pnlRobotWithWafer->Color = clRed;
                           }
                        }
                     }
                  }

                  // Clear
                  ReplyStrRobot = "";
                  // Ignore LRC
                  i++;
               }
               else {
                  ReplyStrRobot += Buf[i];
               }
            }
         }
      // 先不管
      //}

      if(pnlRobot->Enabled == true) {
         btnRobotEnable->Visible = false;
      }
   }
   else {

      // 先不管
      //if(NotifyType == EV_RXCHAR) {

         n = ybRobot->Read(Buf,8192);
         if(n > 0) {
            Buf[n] = 0;
            for(int i=0 ; i<n ; i++) {
               // 0x03
               if(Buf[i] == ETX) {
                  // Display
                  AddRobotRecvMessage(ReplyStrRobot);

                  // 2022 9 14a - chc Log
                  WriteSystemLog("Robot Recv= " + ReplyStrRobot);

                  // Recv: @001 0601# (0601 = 完成)
                  if(ReplyStrRobot.Pos("0601") > 0) {

                     // 2020 4 27 - chc 若是GP Command則不可以設為None
                     if(RobotCmd != ROBOT_CMD_GP) {

                        RobotCmd = ROBOT_CMD_NONE;

                        // 2020 5 6 - chc Log
                        WriteSystemLog("RobotCmd-1 = ROBOT_CMD_NONE");

                     }

                     RobotCmdState = ROBOT_CMD_STATE_DONE;
                     // 2020 5 6 - chc Log
                     WriteSystemLog("RobotCmdState-1 = ROBOT_CMD_STATE_DONE");

                     pnlRobotOperation->Caption = "Ready";
                     pnlRobot->Enabled = true;

                     // 2020 4 27 - chc Log
                     WriteSystemLog("Robot收到0601");

                     // 2020 5 20 - chc Clear Error Code & Msg
                     boolclearerrorcode = true;

                     // 2020 5 21 - chc Status: S4S3S2S1
                     // 0601
                     sprintf(RobotStatus,"0601");
                     UpdateRobotStatus_1(0);

                  }
                  else if(ReplyStrRobot.Pos("4401") > 0) {
                     RobotCmdState = ROBOT_CMD_STATE_SENT;
                     pnlRobotOperation->Caption = "Run";

                     // 2020 5 6 - chc Log
                     WriteSystemLog("RobotCmdState-2 = ROBOT_CMD_STATE_SENT");

                     // 2020 4 27 - chc Robot是否已動作?
                     boolRobot4401 = true;
                     // 2020 4 27 - chc Log
                     WriteSystemLog("Robot收到4401");

                     // 2020 5 20 - chc Clear Error Code & Msg
                     boolclearerrorcode = true;

                     // 2020 5 21 - chc Status: S4S3S2S1
                     // 0601
                     sprintf(RobotStatus,"4401");
                     UpdateRobotStatus_1(0);

                  }
                  // Recv: @001 E0601EE...
                  //        12345678901234567890
                  else if(ReplyStrRobot.Pos("001 E") > 0) {
                     RobotCmd = ROBOT_CMD_NONE;

                     // 2020 5 6 - chc Log
                     WriteSystemLog("RobotCmd-2 = ROBOT_CMD_NONE");

                     RobotCmdState = ROBOT_CMD_STATE_DONE;

                     // 2020 5 6 - chc Log
                     WriteSystemLog("RobotCmdState-3 = ROBOT_CMD_STATE_DONE");

                     pos = ReplyStrRobot.Pos("001 E");
                     pnlRobotOperation->Caption = "Error";
                     pnlRobotErrorCode->Caption = ReplyStrRobot.SubString(pos+9,2);
                     pnlRobotErrorCode1->Caption = ReplyStrRobot.SubString(pos+9,2);
                     // 060262000000
                     sprintf(RobotStatus,"%s",ReplyStrRobot.SubString(pos+5,12).c_str());
                     pnlRobot->Enabled = true;
                     UpdateRobotStatus_1(1);

                     // 2020 5 14 - chc Error Code
                     PutRobotErrorCodeMsg();

                  }
                  // 處理DI: 001 0 0x03 LRC
                  else if(ReplyStrRobot.Pos("001 ") > 0) {
                     pos = ReplyStrRobot.Pos("001 ");
                     len = ReplyStrRobot.Length();

                     // 2020 5 4 - chc LR
                     // LR: 取得位置 GP 881 ( 0 0 20 0) => 001 677.9 0 82 270.26L 0        => pos=1
                     //                                    123456789012345678901234        => 24
                     //                                        677.9 0 82 270.26L 0
                     //                                        12345678901234567890
                     if(boolRobotLRCommand == true) {
                        WriteSystemLog("boolRobotLRCommand = true, len= " + IntToStr(len));
                           if(len > 12) {
                           WriteSystemLog("len > 12, 進行X 解碼...");
                           AnsiString temp;
                           temp = ReplyStrRobot.SubString(pos+4,len-4);
                           WriteSystemLog("len > 12, 進行X 解碼: " + temp);
                           int pos1 = temp.Pos(" ");
                           int len1 = temp.Length();
                           boolRobotLRCommand = false;
                           WriteSystemLog("Set boolRobotLRCommand = false");
                           RobotXPosition = (int)(temp.SubString(1,pos1-1).ToDouble());
                           pnlRobotXPosition->Caption = IntToStr(RobotXPosition);
                           pnlRobot->Enabled = true;
                           WriteSystemLog("len > 12, 進行X 解碼完成: " + IntToStr(RobotXPosition));

                           // 2020 5 6 - chc 要設Ready!
                           pnlRobotOperation->Caption = "Ready";

                        }
                     }

                     // LID0: 0-Yes, 1-No
                     if(pos == len-4) {
                        RobotCmd = ROBOT_CMD_NONE;

                        // 2020 5 6 - chc Log
                        WriteSystemLog("RobotCmd-3 = ROBOT_CMD_NONE");

                        RobotCmdState = ROBOT_CMD_STATE_DONE;

                        // 2020 5 6 - chc Log
                        WriteSystemLog("RobotCmdState-4 = ROBOT_CMD_STATE_DONE");

                        pnlRobotOperation->Caption = "Ready";
                        pnlRobot->Enabled = true;
                        if(ReplyStrRobot.SubString(len,1) == "0") {
                           pnlRobotWithWafer->Color = clLime;
                           RobotWithWafer = ROBOT_WAFER_YES;
                        }
                        else {
                           pnlRobotWithWafer->Color = clSilver;
                           RobotWithWafer = ROBOT_WAFER_NO;
                        }
                     }

                     // 2020 5 20 - chc Clear Error Code & Msg
                     boolclearerrorcode = true;

                  }

                  // 2020 5 20 - chc Clear Error Code & Msg
                  if(boolclearerrorcode == true) {
                     pnlRobotErrorCode->Caption = "";
                     pnlRobotErrorCode1->Caption = "";
                     pnlRobotErrorMsg->Caption = "";
                     pnlRobotE2->Caption = "";
                     pnlRobotE1->Caption = "";
                  }

                  // Clear
                  ReplyStrRobot = "";
                  // Ignore LRC
                  i++;
               }
               else {
                  if(Buf[i] == STX)
                     ReplyStrRobot += "<";
                  else
                     ReplyStrRobot += Buf[i];
               }
            }
         }

      // 先不管
      //}

      if(pnlRobot->Enabled == true) {
         btnRobotEnable->Visible = false;
      }
   }   

/*
               // 處理命令
               if(RobotCmd == ROBOT_CMD_GP || RobotCmd == ROBOT_CMD_LS) {
                  if(msg.SubString(1,3) == "001") {
                     if(msg.SubString(5,4) == "0601") {
                        RobotCmdState = ROBOT_CMD_STATE_DONE;
                     }
                     if(msg.SubString(5,4) == "4401") {
                        RobotCmdState = ROBOT_CMD_STATE_SENT;
                     }
                  }
               }
               // 處理命令
               else if(RobotCmd == ROBOT_CMD_LR) {
                  // Error(10碼): Robotstatus(4 character; S4S3S2S1) + Errorcode(2 characters; E2E1) + ErrorAxisInformation(4 characters - XYZW)
                  // S1: 0- 1：ON-LINE MODE
                  //     1- 1：MANUAL MODE
                  //     2- 1：AUTO MODE
                  //     3- 0：Fixed
                  //     4- 1：Fixed
                  //     5- 1：Fixed
                  //     6- 0：Fixed
                  //     7- Not Used
                  // MANUAL MODE is the switch to enable the automatic operation of the controller.
                  // When MANUAL is selected, the teach pendant is in one of KEY-IN,
                  // TEACH, and CHECK mode.i
                  // S1=“0”=0x30 ........................ After ON-LINE mode, and switches the key switch to the MANUAL
                  // S1=“1”=0x31 ............................. ON-LINE mode
                  // S1=“2”=0x32 ............................. MANUAL mode
                  // S1=“4”=0x34 ............................. AUTO mode
                  // S2: 0- 0：Fixed
                  //     1- 1：STOP signal ON / 0: STOP signal OF
                  //     2- 1：in ES (emergency stop) / 0: not in ES
                  //     3- 0：Fixed
                  //     4- 1：Fixed
                  //     5- 1：Fixed
                  //     6- 0：Fixed
                  //     7- Not Used
                  // STOP signal is turned ON in operation prohibited status due to GD(operation prohibiting) command.
                  // S2=“1”＝0x31............................ Not in ES and STOP signal is not ON.
                  // S2=“2”＝0x32............................ STOP signal is ON.
                  // S2=“4”＝0x34............................ in ES
                  // S2=“6”＝0x36............................ In ES and STOP signal is ON.
                  // S3: 0- 0：Z-axis zone output (SAFTY ZONE)
                  //     1- 1：Positioning completed / 0: not completed
                  //     2- 1：A-CAL completed / 0: not completed
                  //     3- 0：Fixed
                  //     4- 1：Fixed
                  //     5- 1：Fixed
                  //     6- 0：Fixed
                  //     7- Not Used
                  // Z-axis zone outputi is set to "1" when the following condition is satisfied.
                  // The Z-axis coordinate is located at a higher position (smaller value)
                  //      than the value set in System Parameter → [RESPONSE] →[RESPONCE] → [SAFE. ZONE].
                  // S3=“0”＝0x30: Neither A-CAL nor positioning has been completed.
                  // S3=“2”＝0x32: Positioning has been completed.
                  // S3=“4”＝0x34: A-CAL has been completed but positioning has not.
                  // S3=“6”＝0x36: Both A-CAL and positioning have been completed.
                  // S4: 0- 0：Fixed
                  //     1- 0：Fixed
                  //     2- 1：Executing action command 0: End
                  //     3- 0：Fixed
                  //     4- 1：Fixed
                  //     5- 1：Fixed
                  //     6- 0：Fixed
                  //     7- Not Used
                  // When the robot is being operated by GP and GZ commands, S4 character is "1".
                  // Therefore, “S4+S3+S2+S1”＝[0x30][0x36][0x30][0x31]=“0601” shows that the
                  // robot is in the following status.
                  //      ◆ In ON-LINE MODE
                  //      ◆ A-CAL completed
                  //      ◆ Positioning completed
                  // E2 E1 Error Description
                  //      00 Normal status (no error)
                  //      09 Positioning error (Refer to error axis information.)
                  //      10 Emergency stop state
                  //      20 A-CAL does not end normally. (Refer to error axis information.)
                  //      30 The address is out of the limit.
                  //      31 The robot was tried to be moved to the END(??) point.
                  //      32 FAN alarm status (When FAN alarm function is active.)
                  //      40 The position data is out of the limited area. (Refer to error axis information.)
                  //      51 The robot is in overrun status. (Refer to error axis information.)
                  //      61 Communication command error
                  //      62 A command which could not be executed in the current mode was received.
                  //      63 System data (SG, SP) is corrupted.
                  //      64 The position data cannot be read from the memory card.
                  //      67 Servo parameter is corrupted.
                  //      70 Low encoder battery
                  //      80 The robot received another command during command processing.
                  //      82 Sensor input does not turn ON. (When sensor stop function is active.)
                  //      84 The measurement result is out of the range. (When glass alignment function is active.)
                  //      90 The robot was tried to be operated before A-CAL had been completed.
                  //      95 Coordinate transformation error: The specified position data is invalid.
                  //      A0 Driver error (Refer to error axis information.)
                  //      B0 Servo lock does not work.
                  //      C0 Program error (When HARL-U2 is in use.)
                  //      D0 Aligner error: The line sensor cannot be initialized.
                  //      D1 Aligner error: The wafer edge cannot be detected.
                  //      D3 Aligner error: Too much scans
                  //      D5 Aligner error: The pivot axis rotation frequency is not sufficient.
                  //      D7 Aligner error: The correction amount exceeds the set value.
                  //      D8 Aligner error: Wrong transfer robot is specified.
                  //      D9 Aligner error: Wrong axis is specified for correction output.
                  //      DA Aligner error: Wrong address is specified for correction output.
                  //      DB Aligner error: Wrong direction is specified for motor rotation.
                  //      DC Aligner error: Wrong parameter is specified.
                  //      E0 Axis interlock (When axis interlock function is active.)
                  //      E1, E2=“0”∼“9”(0x30∼0x39): “A”∼“F”(0x41∼0x46)
                  // Axis-Error
                  //      When a positioning error (09)
                  //        0: Normal
                  //        1: Abnormal
                  //      When an A-CAL error (20)
                  //        0: Normal
                  //        1: Abnormal
                  //      When an overrun error (51) has occurred
                  //        0: Normal
                  //        1: Origin side
                  //        2: Overrun side
                  //        3: Both sides
                  //      When a position data outside limited area error (40) has occurred
                  //        0: Normal
                  //        1: Lower limit side
                  //        2: Upper limit side
                  //      When a driver error (A0) has occurred
                  //        0: Normal
                  //        1: Abnormal
                  // 10碼: ErrorCode
*/
}
//---------------------------------------------------------------------------
// Send: 0000MOV:FPML;
// Recv: 0000MOV:FPML;56*
// Recv: 0000INF:FPML;41* (INF = 完成)
// 結束碼: CR(0x0d)
// 開始碼: 0x01
//
// Loaf port 正常log:
// 2020-03-09 09:01:15.357   P2 : A > D : Load : 0000MOV:FPML;
// 2020-03-09 09:01:15.465   P2 : D > A : ~0000MOV:FPML;56*
// 2020-03-09 09:01:27.352   P2 : D > A : ~0000INF:FPML;41* (INF = 完成)
// Loaf port error log
// 2020-03-09 08:59:53.632   P2 : A > D : Load : 0000MOV:FPML;
// 2020-03-09 08:59:53.739   P2 : D > A : ~0000MOV:FPML;56*
// 2020-03-09 09:00:18.186   P2 : D > A : ~0000ABS:FPML/16;D0* (ABS=有error, 16=error code)

// Mapping
//0000GET:MAPR/0000000000000000000000000;1A*( bottem to top)

AnsiString ReplyStrLoadPort = "";
unsigned char LoadPortBuffer[500];
int LoadPortBufferLength = 0;
//unsigned char CassetteBuffer[25];
//unsigned char LoadPortStatus[20];
//unsigned char LoadPortLED[8];
int LoadUnloadState;
bool boolMapping = false;
// 記錄為Load後的第一片
bool boolFirstAfterLoad = false;
void __fastcall TfrnMain::ybLoadPortCommNotify(TObject *Sender,
      int NotifyType)
{
char Buf[8192+1];
AnsiString msg;
int len,pos,n;
bool boolmap = false;
bool boolstas = false;
// Load/Unload LoadUnloadState = 1/2;
bool boollpld = false;
bool boolclearerrorcode = false;

   // 先不管
   //if(NotifyType == EV_RXCHAR) {

      // 2020 4 20 - chc 有通訊則Power為On
      pnlLoadPortPower->Color = clLime;
      pnlLoadPortKWF->Color = clLime;

      n = ybLoadPort->Read(Buf,8192);
      if(n > 0) {
         Buf[n] = 0;
         for(int i=0 ; i<n ; i++) {
            if(Buf[i] == 0x0d) {
               // Display
               AddLoadPortRecvMessage(ReplyStrLoadPort);
               // Recv: 0000INF:FPML;41* (INF = 完成)
               if(ReplyStrLoadPort.Pos("INF") > 0) {
                  pnlLoadPortOperation->Caption = "Ready";
                  pnlLoadPort->Enabled = true;

                  // 2020 5 20 - chc Clear Error Code & Msg
                  boolclearerrorcode = true;

                  // 2020 5 14 - chc Reset Error Code
                  pnlLoadPortErrorCode1->Caption = "";
                  pnlLoadPortErrorMsg->Caption = "";

                  // FPML
                  if(ReplyStrLoadPort.Pos("FPML") > 0) {
                     boolmap = true;
                     pnlEFEMCassette->Color = clLime;
                     pnlLoadPortLoad->Color = clLime;
                     pnlLoadPortUnLoad->Color = clSilver;
                     btnCassetteLoad->Caption = "UnLoad";
                     frmRecipe->btnCassetteLoad->Caption = "UnLoad";
                     LoadUnloadState = 1;
                     boolMapping = true;
                     boollpld = true;

                     // 2020 5 21 - chc 可以取片
                     btnLoadWafer->Enabled = true;

                     // 2020 5 4 - chc 已完成
                     boolLoadUnloadStatus = true;

                     // 2020 5 14 - chc 記錄為Load後的第一片
                     boolFirstAfterLoad = true;

                     // 2020 5 12 - chc 綠燈
                     SetGreenLamp(true);
                     SetYellowLamp(false);

                  }
                  else if(ReplyStrLoadPort.Pos("ORGN") > 0) {
                     pnlEFEMCassette->Color = clSilver;
                     pnlLoadPortLoad->Color = clSilver;
                     pnlLoadPortUnLoad->Color = clLime;
                     btnCassetteLoad->Caption = "Load";
                     frmRecipe->btnCassetteLoad->Caption = "Load";
                     LoadUnloadState = 2;
                     boollpld = true;
                     UpdateCassetteState(0);
                     boolMapping = false;

                     // 2020 5 21 - chc 不可以取片
                     btnLoadWafer->Enabled = false;

                     // 2020 5 4 - chc 已完成
                     boolLoadUnloadStatus = true;

                     // 2020 5 14 - chc 記錄為Load後的第一片
                     boolFirstAfterLoad = false;

                     // 2020 5 12 - chc 綠燈
                     SetGreenLamp(false);
                     SetYellowLamp(true);

                  }

                  // 2020 4 29 - chc Mapping
                  else if(ReplyStrLoadPort.Pos("MAPP") > 0) {
                     boolmap = true;
                     LoadUnloadState = 1;
                     boolMapping = true;
                  }

                  // 2020 4 20 - chc Succ則Alarm為Off
                  pnlLoadPortAlarm->Color = clSilver;
                  pnlLoadPortInterLockCode->Caption = "";
                  pnlLoadPortInterLockCode1->Caption = "";
                  PutLoadPortInterLockMsg();

                  // 2020 4 27 - chc
                  // Power On: PWON, PDON: Normal Mount Status, PDOF: Load sensors and mount are all OFF
                  if(ReplyStrLoadPort.Pos("PWON") > 0) {
                  }
                  if(ReplyStrLoadPort.Pos("PDON") > 0) {
                  }
                  if(ReplyStrLoadPort.Pos("PDOF") > 0) {
                  }

               }
               // 0000GET:STAS/02100010101000000000;45*
               // 12345678901234567890
               else if(ReplyStrLoadPort.Pos("GET:STAS") > 0) {
                  pos = ReplyStrLoadPort.Pos("STAS/");
                  sprintf(LoadPortStatus,"%s",ReplyStrLoadPort.SubString(pos+5,20).c_str());
                  pnlLoadPortOperation->Caption = "Ready";
                  pnlLoadPort->Enabled = true;
                  UpdateLoadPortStatus_1();
                  // 2020 4 20 - chc Succ則Alarm為Off
                  pnlLoadPortAlarm->Color = clSilver;
               }
               // InterLockCode: pnlLoadPortInterLockCode
               // MOV:FPML/19;F3
               // 12345678901234567890
               // Error
               else if(ReplyStrLoadPort.Pos("MOV:FPML/") > 0) {
                  pos = ReplyStrLoadPort.Pos("FPML/");
                  pnlLoadPortInterLockCode->Caption = ReplyStrLoadPort.SubString(pos+5,2);
                  pnlLoadPortInterLockCode1->Caption = ReplyStrLoadPort.SubString(pos+5,2);
                  PutLoadPortInterLockMsg();
                  pnlLoadPortOperation->Caption = "Ready";
                  pnlLoadPort->Enabled = true;
                  pnlLoadPortAlarm->Color = clLime;
                  boolMapping = false;

                  // 2020 5 12 - chc 紅燈
                  // 2020 8 12 - chc TSMC修改
                  //RedLamp(true);
                  boolEFEMError = true;

               }
               // Error
               else if(ReplyStrLoadPort.Pos("MOV:ORGN/") > 0) {
                  pos = ReplyStrLoadPort.Pos("ORGN/");
                  pnlLoadPortInterLockCode->Caption = ReplyStrLoadPort.SubString(pos+5,2);
                  pnlLoadPortInterLockCode1->Caption = ReplyStrLoadPort.SubString(pos+5,2);
                  PutLoadPortInterLockMsg();
                  pnlLoadPortOperation->Caption = "Ready";
                  pnlLoadPort->Enabled = true;
                  pnlLoadPortAlarm->Color = clLime;
                  boolMapping = false;

                  // 2020 5 12 - chc 紅燈
                  // 2020 8 12 - chc TSMC修改
                  //RedLamp(true);
                  boolEFEMError = true;

               }
               // 0000GET:LEST/abcdefgh;45*
               // 12345678901234567890
               else if(ReplyStrLoadPort.Pos("GET:LEST") > 0) {
                  pos = ReplyStrLoadPort.Pos("LEST/");
                  sprintf(LoadPortLED,"%s",ReplyStrLoadPort.SubString(pos+5,8).c_str());
                  pnlLoadPortOperation->Caption = "Ready";
                  pnlLoadPort->Enabled = true;
                  UpdateLoadPortLED_1();
                  // 2020 4 20 - chc Succ則Alarm為Off
                  pnlLoadPortAlarm->Color = clSilver;
               }
               // 0000ABS:FPML/16;D0* (ABS=有error, 16=error code)
               // 12345678901234567890
               else if(ReplyStrLoadPort.Pos("ABS") > 0) {
                  pos = ReplyStrLoadPort.Pos("ABS");
                  pnlLoadPortOperation->Caption = "Error";
                  pnlLoadPortErrorCode->Caption = ReplyStrLoadPort.SubString(pos+9,2);
                  pnlLoadPortErrorCode1->Caption = ReplyStrLoadPort.SubString(pos+9,2);

                  // 2020 9 3 - chc Error Code
                  pnlLoadPortS5->Caption = ReplyStrLoadPort.SubString(pos+9,1);
                  pnlLoadPortS6->Caption = ReplyStrLoadPort.SubString(pos+10,1);

                  pnlLoadPort->Enabled = true;
                  // 2020 4 20 - chc ABS則Alarm為On
                  pnlLoadPortAlarm->Color = clLime;

                  // 2020 5 14 - chc Error Code
                  PutLoadPortErrorCodeMsg();

                  // 2020 5 12 - chc 紅燈
                  // 2020 8 12 - chc TSMC修改
                  //RedLamp(true);
                  boolEFEMError = true;

               }
               // 0000GET:MAPR/0000000000000000000000000;1A*( bottem to top)
               // 12345678901234567890
               // CassetteBuffer[25]
               else if(ReplyStrLoadPort.Pos("MAPR") > 0) {

                  // 2020 4 29 - chc 做一次就可以!
                  //for(int i=0 ; i<25 ; i++) {

                     pos = ReplyStrLoadPort.Pos("MAPR");
                     sprintf(CassetteBuffer,"%s",ReplyStrLoadPort.SubString(pos+5,25).c_str());
                     pnlLoadPortOperation->Caption = "Ready";
                     pnlLoadPort->Enabled = true;
                     UpdateCassetteState(1);
                     boolstas = true;
                     // 2020 4 20 - chc Succ則Alarm為Off
                     pnlLoadPortAlarm->Color = clSilver;
                     boolMapping = true;

                  //}

               }

               // 2020 4 29 - chc Mapping
               else if(ReplyStrLoadPort.Pos("MOV:MAPP/") > 0) {
                  pos = ReplyStrLoadPort.Pos("MAPP/");
                  pnlLoadPortInterLockCode->Caption = ReplyStrLoadPort.SubString(pos+5,2);
                  pnlLoadPortInterLockCode1->Caption = ReplyStrLoadPort.SubString(pos+5,2);
                  PutLoadPortInterLockMsg();
                  pnlLoadPortOperation->Caption = "Ready";
                  pnlLoadPort->Enabled = true;
                  pnlLoadPortAlarm->Color = clLime;
                  boolMapping = false;

                  // 2020 5 12 - chc 紅燈
                  // 2020 8 12 - chc TSMC修改
                  //RedLamp(true);
                  boolEFEMError = true;

               }

               // 2020 5 20 - chc Clear Error Code & Msg
               if(boolclearerrorcode == true) {
                  // Error code
                  pnlLoadPortErrorCode->Caption = "";
                  pnlLoadPortErrorCode1->Caption = "";
                  pnlLoadPortErrorMsg->Caption = "";
                  // Interlock code
                  pnlLoadPortInterLockCode->Caption = "";
                  pnlLoadPortInterLockCode1->Caption = "";
                  pnlLoadPortInterLockMsg->Caption = "";
               }

               // Clear
               ReplyStrLoadPort = "";
            }
            else {
               if(Buf[i] == 0x01)
                  ReplyStrLoadPort += "<";
               else
                  ReplyStrLoadPort += Buf[i];
            }
         }
      }

   // 先不管
   //}

   if(pnlLoadPort->Enabled == true) {
      btnLoadPortEnable->Visible = false;
      if(boolmap == true)
         btnLoadPortMapClick(this);
   }
   if(pnlLoadPort->Enabled == true) {
      if(boolstas == true) {
         btnLoadPortStasClick(this);
      }
   }
   // Load/Unload LoadUnloadState = 1/2;
   if(boollpld == true) {
      tmLoadUnload->Enabled = true;
   }
}
//---------------------------------------------------------------------------
// 2022 12 20 - chc Tazmo
bool boolAligner1PRP = false;
bool boolAligner2PRP = false;

// Send: 0000MOV:ARLD;
// Recv:
// Recv:
// 結束碼: CR(0x0d)
// 開始碼: 0x01

// Aligner正常Log
// 2019-12-10 15:03:33.723   Aligner : D > A : ~0000SET:OFSE;4E*
// 2019-12-10 15:03:33.887   Aligner : D > A : ~0000INF:OFSE;3F*  (INF = 完成)
// Aligner error log:
// 2020-03-26 20:01:00.191   Aligner2 : A > D : Align : 0000MOV:ARLD;
// 2020-03-26 20:01:00.553   Aligner2 : D > A : ~0000MOV:ARLD;4A*
// 2020-03-26 20:01:37.424   Aligner2 : D > A : ~0000ABS:ARLD/D1;D2* (ABS=有error, D1=error code)

AnsiString ReplyStrAligner = "";
//unsigned char AlignerStatus[15];
//int LoadUnloadState;
// 0-None, 1-OK, 2-NG
int AlignerOFSEState = 0;

//AnsiString AlignerCommandCode = "";
//bool boolAlignerAck = false;
//bool boolAlignerComplete = false;
//bool boolAlignerNak = false;

void __fastcall TfrnMain::ybAlignerCommNotify(TObject *Sender,
      int NotifyType)
{
char Buf[8192+1];
AnsiString msg,msg1,lcode;
int len,pos,n;
bool boolstas = false;
bool boolclearerrorcode = false;

   // 2022 12 19 - chc Tazmo
   if(RobotMode == ROBOT_MODE_TAZMO) {
      // 先不管
      //if(NotifyType == EV_RXCHAR) {

         n = ybAligner->Read(Buf,8192);
         if(n > 0) {
            Buf[n] = 0;
            for(int i=0 ; i<n ; i++) {
               // 0x03
               if(Buf[i] == ACK || Buf[i] == NAK || Buf[i] == BUSY || Buf[i] == CR) {
                  // Display
                  if(Buf[i] == ACK)
                     lcode = "[Ack]";
                  else if(Buf[i] == NAK)
                     lcode = "[Nak]";
                  else if(Buf[i] == BUSY)
                     lcode = "[Busy]";
                  else if(Buf[i] == CR)
                     lcode = ReplyStrAligner + "[Cr]";
                  AddAlignerRecvMessage(lcode);
                  WriteSystemLog("Aligner1 Recv= " + lcode);

                  if(Buf[i] == ACK) {
                     boolAlignerAck = true;
                     WriteSystemLog("Aligner1Cmd-1 = [Ack]");
                  }
                  else if(Buf[i] == NAK) {
                     boolAlignerNak = true;
                     WriteSystemLog("Aligner1Cmd-1 = [Nak]");
                  }
                  else if(Buf[i] == BUSY) {
                     WriteSystemLog("Aligner1Cmd-1 = [Busy]");
                  }
                  else if(Buf[i] == CR) {
                     WriteSystemLog("Aligner1Cmd-1 = [Cr]");
                     if(ReplyStrAligner.SubString(1,3) == "ERR") {
                        boolAlignerNak = true;
                        WriteSystemLog("Aligner1Cmd-1 = [Err]");
                     }
                     else if(ReplyStrAligner.SubString(1,3) == AlignerCommandCode) {
                        tmAlignerAck->Enabled = true;
                        boolAlignerComplete = true;
                        pnlAlignerOperation->Caption = "Ready";
                        pnlAligner->Enabled = true;
                        if(ReplyStrAligner.SubString(1,3) == "STS") {
                           // STS,100[Cr]
                           // 123456789
                           pnlAlingerStatus->Caption = ReplyStrAligner.SubString(5,3);
                           //if(pnlAlingerStatus->Caption == "100")
                           //   pnlAlignerWithWafer->Color = clSilver;
                           //else if(pnlAlingerStatus->Caption == "101")
                           //   pnlAlignerWithWafer->Color = clLime;
                        }
                        else if(ReplyStrAligner.SubString(1,3) == "RST") {
                           boolAligner1PRP = false;
                        }
                        else if(ReplyStrAligner.SubString(1,3) == "HOM") {
                           boolAligner1PRP = false;
                        }
                        else if(ReplyStrAligner.SubString(1,3) == "PRP") {
                           boolAligner1PRP = true;
                        }
                        else if(ReplyStrAligner.SubString(1,3) == "WCH") {
                           boolAligner1PRP = false;
                           if(ReplyStrAligner.SubString(5,1) == "1")
                              pnlAlignerWithWafer->Color = clLime;
                           else if(ReplyStrAligner.SubString(5,1) == "0")
                              pnlAlignerWithWafer->Color = clSilver;
                           else
                              pnlAlignerWithWafer->Color = clRed;
                        }
                     }
                  }

                  // Clear
                  ReplyStrAligner = "";
                  // Ignore LRC
                  i++;
               }
               else {
                  ReplyStrAligner += Buf[i];
               }
            }
         }

      // 先不管
      //}

      if(pnlAligner->Enabled == true) {
         btnAlignerEnable->Visible = false;
      }
   }
   else {

      // 先不管
      //if(NotifyType == EV_RXCHAR) {

         n = ybAligner->Read(Buf,8192);
         if(n > 0) {
            Buf[n] = 0;

            // 2022 7 13 - chc 即時顯示
            // => 取消: 是USB轉RS232才可以, 否則有亂碼
            //msg.sprintf("[org]%s",Buf);
            //AddAlignerRecvMessage(msg);
            //WriteSystemLog(msg);
            //msg = "[X]";
            //for(int i=0 ; i<n ; i++) {
            //   msg1.sprintf("%2X ",Buf[i]);
            //   msg = msg + msg1;
            //}
            //WriteSystemLog(msg);

            for(int i=0 ; i<n ; i++) {
               if(Buf[i] == 0x0d) {
                  // Display
                  AddAlignerRecvMessage(ReplyStrAligner);
                  // Recv: 0000INF:FPML;41* (INF = 完成)
                  if(ReplyStrAligner.Pos("INF") > 0) {
                     pnlAlignerOperation->Caption = "Ready";
                     pnlAligner->Enabled = true;
                     boolclearerrorcode = true;
                     // ORGN加做STAS
                     if(ReplyStrAligner.Pos("ORGN") > 0) {
                        boolstas = true;
                        boolAlignerORGN = true;
                        pnlAlignerORGN->Color = clLime;

                        // 2022 8 23 - chc Log
                        WriteSystemLog("Aligner: 收到ORGN.");

                        // 2020 7 17 - chc 是ORGN, 加做STAT
                        // 2022 8 11 - chc 不做
                        //WriteSystemLog("Aligner: 是ORGN, 加做STAS...");

                     }
                     if(ReplyStrAligner.Pos("ARLD") > 0) {
                        pnlAlignerAlignment->Color = clLime;
                     }
                     if(ReplyStrAligner.Pos("ACOP") > 0) {
                        pnlAlignerVacuumOff->Color = clLime;
                     }
                     if(ReplyStrAligner.Pos("RSET") > 0) {
                        pnlAlignerReset->Color = clSilver;
                     }

                     // 2020 5 4 - chc 角度設定是否正確?
                     if(ReplyStrAligner.Pos("OFSE") > 0) {
                        AlignerOFSEState = 1;
                     }

                  }
                  // 0000ABS:FPML/16;D0* (ABS=有error, 16=error code)
                  // 12345678901234567890
                  else if(ReplyStrAligner.Pos("ABS") > 0) {
                     pos = ReplyStrAligner.Pos("ABS");
                     pnlAlignerOperation->Caption = "Error";
                     pnlAlignerErrorCode->Caption = ReplyStrAligner.SubString(pos+9,2);
                     pnlAlignerErrorCode1->Caption = ReplyStrAligner.SubString(pos+9,2);

                     // 2020 5 14 - chc Error Code
                     PutAlignerCodeMsg();

                     pnlAligner->Enabled = true;
                     if(ReplyStrAligner.Pos("ORGN") > 0) {
                        pnlAlignerORGN->Color = clRed;
                     }
                     if(ReplyStrAligner.Pos("ARLD") > 0) {
                        pnlAlignerAlignment->Color = clRed;
                     }
                     if(ReplyStrAligner.Pos("ACOP") > 0) {
                        pnlAlignerVacuumOff->Color = clRed;
                     }

                     // 2020 5 4 - chc 角度設定是否正確?
                     if(ReplyStrAligner.Pos("OFSE") > 0) {
                        AlignerOFSEState = 2;
                     }

                  }
                  else if(ReplyStrAligner.Pos("GET:STAS") > 0) {
                     pos = ReplyStrAligner.Pos("STAS/");
                     pnlAlignerOperation->Caption = "Ready";
                     pnlAligner->Enabled = true;
                     sprintf(AlignerStatus,"%s",ReplyStrAligner.SubString(pos+5,15).c_str());
                     UpdateAlignerStatus_1();
                  }
                  // 取回設定值: Offset/Speed/Type
                  else if(ReplyStrAligner.Pos("GET:") > 0 && ReplyStrAligner.Pos("/") > 0) {
                     pos = ReplyStrAligner.Pos("/");
                     int pos1 = ReplyStrAligner.Pos(";");
                     int len = pos1 - pos - 1;
                     pnlAlignerOperation->Caption = "Ready";
                     pnlAligner->Enabled = true;
                     AnsiString recv;
                     // 0000GET:OFSE/1800;A1
                     // 0000GET:SPED/100;01
                     // 0000GET:TYPE/5;B8
                     //             123456
                     if(ReplyStrAligner.Pos("OFSE") > 0) {
                        recv = ReplyStrAligner.SubString(pos+1,len);
                        edAlignerDegree->Text = recv;
                     }
                     else if(ReplyStrAligner.Pos("OFS2") > 0) {
                        recv = ReplyStrAligner.SubString(pos+1,len);
                        edAlignerDegree->Text = recv;
                     }
                     else if(ReplyStrAligner.Pos("SPED") > 0) {
                        recv = ReplyStrAligner.SubString(pos+1,len);
                        edAlignerSpeed->Text = recv;
                     }
                     else if(ReplyStrAligner.Pos("TYPE") > 0) {
                        recv = ReplyStrAligner.SubString(pos+1,len);
                        edAlignerType->Text = recv;
                     }
                  }

                  // 2020 5 20 - chc Clear Error Code & Msg
                  if(boolclearerrorcode == true) {
                     // Error code
                     pnlAlignerErrorCode->Caption = "";
                     pnlAlignerErrorCode1->Caption = "";
                     pnlAlignerErrorMsg->Caption = "";
                  }

                  // Clear
                  ReplyStrAligner = "";
               }
               else {
                  if(Buf[i] == 0x01)
                     ReplyStrAligner += "<";
                  else
                     ReplyStrAligner += Buf[i];
               }
            }
         }

      // 先不管
      //}

      if(pnlAligner->Enabled == true) {
         btnAlignerEnable->Visible = false;
         if(boolstas == true) {

            // 2020 7 17 - chc 是ORGN, 改由Timer加做STAT
            // 2022 8 11 - chc 不做
            //WriteSystemLog("Aligner: 是ORGN, 執行GetStas...");
            //btnAlignerStasClick(this);

         }
      }
   }
}
//---------------------------------------------------------------------------
// 2022 7 6 - chc Error Code
// 1 00 Normal status (no error)
// 2 09 Positioning error (Refer to error axis information.)
// 3 10 Emergency stop state
// 4 20 A-CAL does not end normally. (Refer to error axis information.)
// 5 30 The address is out of the limit.
// 6 31 The robot was tried to be moved to the END(??) point.
// 7 32 FAN alarm status (When FAN alarm function is active.)
// 8 40 The position data is out of the limited area. (Refer to error axis information.)
// 9 51 The robot is in overrun status. (Refer to error axis information.)
//10 61 Communication command error
//11 62 A command which could not be executed in the current mode was received.
//12 63 System data (SG, SP) is corrupted.
//13 64 The position data cannot be read from the memory card.
//14 67 Servo parameter is corrupted.
//15 70 Low encoder battery
//16 80 The robot received another command during command processing.
//17 82 Sensor input does not turn ON. (When sensor stop function is active.)
//18 84 The measurement result is out of the range. (When glass alignment function is active.)
//19 90 The robot was tried to be operated before A-CAL had been completed.
//20 95 Coordinate transformation error: The specified position data is invalid.
//21 A0 Driver error (Refer to error axis information.)
//22 B0 Servo lock does not work.
//23 C0 Program error (When HARL-U2 is in use.)
//24 D0 Aligner error: The line sensor cannot be initialized.
//25 D1 Aligner error: The wafer edge cannot be detected.
//26 D3 Aligner error: Too much scans
//27 D5 Aligner error: The pivot axis rotation frequency is not sufficient.
//28 D7 Aligner error: The correction amount exceeds the set value.
//29 D8 Aligner error: Wrong transfer robot is specified.
//30 D9 Aligner error: Wrong axis is specified for correction output.
//31 DA Aligner error: Wrong address is specified for correction output.
//32 DB Aligner error: Wrong direction is specified for motor rotation.
//33 DC Aligner error: Wrong parameter is specified.
//34 E0 Axis interlock (When axis interlock function is active.)
//E1, E2="0"~"9"(0x30∼0x39): "A"~"F"(0x41∼0x46)

void __fastcall TfrnMain::PutRobotErrorCodeMsg()
{
AnsiString msg = "";
AnsiString errorcode;
int code = 0;

   errorcode = pnlRobotErrorCode->Caption;
   if(errorcode == "")
      code = 0;
   else if(errorcode == "00")
      code = 1;
   else if(errorcode == "09")
      code = 2;
   else if(errorcode == "10")
      code = 3;
   else if(errorcode == "20")
      code = 4;
   else if(errorcode == "30")
      code = 5;
   else if(errorcode == "31")
      code = 6;
   else if(errorcode == "32")
      code = 7;
   else if(errorcode == "40")
      code = 8;
   else if(errorcode == "51")
      code = 9;
   else if(errorcode == "61")
      code = 10;
   else if(errorcode == "62")
      code = 11;
   else if(errorcode == "63")
      code = 12;
   else if(errorcode == "64")
      code = 13;
   else if(errorcode == "67")
      code = 14;
   else if(errorcode == "70")
      code = 15;
   else if(errorcode == "80")
      code = 16;
   else if(errorcode == "82")
      code = 17;
   else if(errorcode == "84")
      code = 18;
   else if(errorcode == "90")
      code = 19;
   else if(errorcode == "95")
      code = 20;
   else if(errorcode == "A0")
      code = 21;
   else if(errorcode == "B0")
      code = 22;
   else if(errorcode == "C0")
      code = 23;
   else if(errorcode == "D0")
      code = 24;
   else if(errorcode == "D1")
      code = 25;
   else if(errorcode == "D3")
      code = 26;
   else if(errorcode == "D5")
      code = 27;
   else if(errorcode == "D7")
      code = 28;
   else if(errorcode == "D8")
      code = 29;
   else if(errorcode == "D9")
      code = 30;
   else if(errorcode == "DA")
      code = 31;
   else if(errorcode == "DB")
      code = 32;
   else if(errorcode == "DC")
      code = 33;
   else if(errorcode == "E0")
      code = 34;

   switch(code) {
      case 0:
         msg = "";
         break;
      case 1:
         msg = "Normal status (no error)";
         break;
      case 2:
         msg = "Positioning error (Refer to error axis information.)";
         break;
      case 3:
         msg = "Emergency stop state";
         break;
      case 4:
         msg = "A-CAL does not end normally. (Refer to error axis information.)";
         break;
      case 5:
         msg = "The address is out of the limit";
         break;
      case 6:
         msg = "The robot was tried to be moved to the END(??) point";
         break;
      case 7:
         msg = "FAN alarm status (When FAN alarm function is active.)";
         break;
      case 8:
         msg = "The position data is out of the limited area. (Refer to error axis information.)";
         break;
      case 9:
         msg = "The robot is in overrun status. (Refer to error axis information.)";
         break;
      case 10:
         msg = "Communication command error";
         break;
      case 11:
         msg = "A command which could not be executed in the current mode was received.";
         break;
      case 12:
         msg = "System data (SG, SP) is corrupted.";
         break;
      case 13:
         msg = "The position data cannot be read from the memory card.";
         break;
      case 14:
         msg = "Servo parameter is corrupted.";
         break;
      case 15:
         msg = "Low encoder battery";
         break;
      case 16:
         msg = "The robot received another command during command processing.";
         break;
      case 17:
         msg = "Sensor input does not turn ON. (When sensor stop function is active.)";
         break;
      case 18:
         msg = "The measurement result is out of the range. (When glass alignment function is active.)";
         break;
      case 19:
         msg = "The robot was tried to be operated before A-CAL had been completed.";
         break;
      case 20:
         msg = "Coordinate transformation error: The specified position data is invalid.";
         break;
      case 21:
         msg = "Driver error (Refer to error axis information.)";
         break;
      case 22:
         msg = "Servo lock does not work.";
         break;
      case 23:
         msg = "Program error (When HARL-U2 is in use.)";
         break;
      case 24:
         msg = "Aligner error: The line sensor cannot be initialized.";
         break;
      case 25:
         msg = "Aligner error: The wafer edge cannot be detected.";
         break;
      case 26:
         msg = "Aligner error: Too much scans";
         break;
      case 27:
         msg = "Aligner error: The pivot axis rotation frequency is not sufficient.";
         break;
      case 28:
         msg = "Aligner error: The correction amount exceeds the set value.";
         break;
      case 29:
         msg = "Aligner error: Wrong transfer robot is specified.";
         break;
      case 30:
         msg = "Aligner error: Wrong axis is specified for correction output.";
         break;
      case 31:
         msg = "Aligner error: Wrong address is specified for correction output.";
         break;
      case 32:
         msg = "Aligner error: Wrong direction is specified for motor rotation.";
         break;
      case 33:
         msg = "Aligner error: Wrong parameter is specified.";
         break;
      case 34:
         msg = "Axis interlock (When axis interlock function is active.)";
         break;

   }
   pnlRobotErrorMsg->Caption = msg;
   pnlRobotErrorMsg->Hint = msg;

   // 2020 5 20a - chc Error Log
   if(code > 1) {
      AddErrorLog("[Robot] " + errorcode + ": " + msg);
   }

}
//---------------------------------------------------------------------------
//Inter Lock Code
//-------------------------------------------------
//01: Host AVAILABLE not input
//10: No FOUP mounting
//14: Clamping not completed
//15: Docking not completed
//16: Door vacuum not completed
//17: Unlatching not completed
//18: Door opening not completed
//19: Mapping not started
//1A: Mapping forward not completed
//1C: Z axis is not door position
//1D: Not in the mapping range
//1E: Undocking not completed
//-------------------------------------------------
// pnlLoadPortInterLockCode->Caption
void __fastcall TfrnMain::PutLoadPortInterLockMsg()
{
AnsiString msg = "";
int code = 0;

   if(pnlLoadPortInterLockCode->Caption == "")
      code = 0;
   else if(pnlLoadPortInterLockCode->Caption == "01")
      code = 1;
   else if(pnlLoadPortInterLockCode->Caption == "10")
      code = 2;
   else if(pnlLoadPortInterLockCode->Caption == "14")
      code = 3;
   else if(pnlLoadPortInterLockCode->Caption == "15")
      code = 4;
   else if(pnlLoadPortInterLockCode->Caption == "16")
      code = 5;
   else if(pnlLoadPortInterLockCode->Caption == "17")
      code = 6;
   else if(pnlLoadPortInterLockCode->Caption == "18")
      code = 7;
   else if(pnlLoadPortInterLockCode->Caption == "19")
      code = 8;
   else if(pnlLoadPortInterLockCode->Caption == "1A")
      code = 9;
   else if(pnlLoadPortInterLockCode->Caption == "1C")
      code = 10;
   else if(pnlLoadPortInterLockCode->Caption == "1D")
      code = 11;
   else if(pnlLoadPortInterLockCode->Caption == "1E")
      code = 12;

   switch(code) {
      case 0:
         msg = "";
         break;
      case 1:
         msg = "Host AVAILABLE not input";
         break;
      case 2:
         msg = "No FOUP mounting";
         break;
      case 3:
         msg = "Clamping not completed";
         break;
      case 4:
         msg = "Docking not completed";
         break;
      case 5:
         msg = "Door vacuum not completed";
         break;
      case 6:
         msg = "Unlatching not completed";
         break;
      case 7:
         msg = "Door opening not completed";
         break;
      case 8:
         msg = "Mapping not started";
         break;
      case 9:
         msg = "Mapping forward not completed";
         break;
      case 10:
         msg = "Z axis is not door position";
         break;
      case 11:
         msg = "Not in the mapping range";
         break;
      case 12:
         msg = "Undocking not completed";
         break;
   }
   pnlLoadPortInterLockMsg->Caption = msg;
   pnlLoadPortInterLockMsg->Hint = msg;

   // 2020 5 20a - chc Error Log
   if(code > 0) {
      AddErrorLog("[LoadPort Interlock] " + pnlLoadPortInterLockCode->Caption + ": " + msg);
   }
}
//---------------------------------------------------------------------------
// 2020 5 14 - chc LoadPort Error Code
// -------------------------------------------------------------------------------------------------------------------
//                                                      Error Code
// -------------------------------------------------------------------------------------------------------------------
// 0 0 Normal
// 1 0 Clamp time over
// 1 1 Unclamp time over
// 1 2 Dock time over
// 1 3 Undock time over
// 1 4 Latch time over
// 1 5 Unlatch time over
// 1 6 Vacuum time over
// 1 7 Vacuum release time over
// 1 8 Door open time over
// 1 9 Door close time over
// 1 A Mapping forward time over
// 1 B Mapping return time over
// 1 F communication error(3 times of resending  (T-Type)
// 2 0 Home return time over
// 2 1 Loading time over
// 2 2 Unloading time over
// 2 3 Positioning time over
// 2 8 Door open/close position movement time over (mapping elevating operation)
// 2 9 Mapping start position movement time over (elevating operation)
// 2 A Mapping end position movement time over (elevating operation)
// 2 B Load position movement time over (elevating operation)
// 4 0 Mapping data error
// 4 1 Mode select error
// 7 0 Clamp sensor error
// 7 1 Dock sensor
// 7 2 Latch sensor error
// 7 3 Door sensor error
// 7 4 Mapping sensor error
// 7 7 Elevator axis sensor error
// A 0 Wafer dropWafer drop
// A 1 Wafer protrusion
// A 2 FOUP mount error (Mount sensor)
// A 3 FOUP mount error (Load sensor)
// A 5 Air pressure drop
// B 0 Host error
// C 0 Parameter error
// E 0 FAN stop alarm
// E 3 Voltage drop
// F E Dock hand pinch error
void __fastcall TfrnMain::PutLoadPortErrorCodeMsg()
{
AnsiString msg = "";
AnsiString errorcode;
int code = 0;

   errorcode = pnlLoadPortS5->Caption + pnlLoadPortS6->Caption;
   if(errorcode == "")
      code = 0;
   else if(errorcode == "10")
      code = 1;
   else if(errorcode == "11")
      code = 2;
   else if(errorcode == "12")
      code = 3;
   else if(errorcode == "13")
      code = 4;
   else if(errorcode == "14")
      code = 5;
   else if(errorcode == "15")
      code = 6;
   else if(errorcode == "16")
      code = 7;
   else if(errorcode == "17")
      code = 8;
   else if(errorcode == "18")
      code = 9;
   else if(errorcode == "19")
      code = 10;
   else if(errorcode == "1A")
      code = 11;
   else if(errorcode == "1B")
      code = 12;
   else if(errorcode == "1F")
      code = 13;
   else if(errorcode == "20")
      code = 14;
   else if(errorcode == "21")
      code = 15;
   else if(errorcode == "22")
      code = 16;
   else if(errorcode == "23")
      code = 17;
   else if(errorcode == "28")
      code = 18;
   else if(errorcode == "29")
      code = 19;
   else if(errorcode == "2A")
      code = 20;
   else if(errorcode == "2B")
      code = 21;
   else if(errorcode == "40")
      code = 22;
   else if(errorcode == "41")
      code = 23;
   else if(errorcode == "70")
      code = 24;
   else if(errorcode == "71")
      code = 25;
   else if(errorcode == "72")
      code = 26;
   else if(errorcode == "73")
      code = 27;
   else if(errorcode == "74")
      code = 28;
   else if(errorcode == "77")
      code = 29;
   else if(errorcode == "A0")
      code = 30;
   else if(errorcode == "A1")
      code = 31;
   else if(errorcode == "A2")
      code = 32;
   else if(errorcode == "A3")
      code = 33;
   else if(errorcode == "A5")
      code = 34;
   else if(errorcode == "B0")
      code = 35;
   else if(errorcode == "C0")
      code = 36;
   else if(errorcode == "E0")
      code = 37;
   else if(errorcode == "E3")
      code = 38;
   else if(errorcode == "FE")
      code = 39;

   switch(code) {
      case 0:
         msg = "";
         break;
      case 1:
         msg = "Clamp time over";
         break;
      case 2:
         msg = "Unclamp time over";
         break;
      case 3:
         msg = "Dock time over";
         break;
      case 4:
         msg = "Undock time over";
         break;
      case 5:
         msg = "Latch time over";
         break;
      case 6:
         msg = "Unlatch time over";
         break;
      case 7:
         msg = "Vacuum time over";
         break;
      case 8:
         msg = "Vacuum release time over";
         break;
      case 9:
         msg = "Door open time over";
         break;
      case 10:
         msg = "Door close time over";
         break;
      case 11:
         msg = "Mapping forward time over";
         break;
      case 12:
         msg = "Mapping return time over";
         break;
      case 13:
         msg = "communication error(3 times of resending (T-Type)";
         break;
      case 14:
         msg = "Home return time over";
         break;
      case 15:
         msg = "Loading time over";
         break;
      case 16:
         msg = "Unloading time over";
         break;
      case 17:
         msg = "Positioning time over";
         break;
      case 18:
         msg = "Door open/close position movement time over (mapping elevating operation)";
         break;
      case 19:
         msg = "Mapping start position movement time over (elevating operation)";
         break;
      case 20:
         msg = "Mapping end position movement time over (elevating operation)";
         break;
      case 21:
         msg = "Load position movement time over (elevating operation)";
         break;
      case 22:
         msg = "Mapping data error";
         break;
      case 23:
         msg = "Mode select error";
         break;
      case 24:
         msg = "Clamp sensor error";
         break;
      case 25:
         msg = "Dock sensor";
         break;
      case 26:
         msg = "Latch sensor error";
         break;
      case 27:
         msg = "Door sensor error";
         break;
      case 28:
         msg = "Mapping sensor error";
         break;
      case 29:
         msg = "Elevator axis sensor error";
         break;
      case 30:
         msg = "Wafer dropWafer drop";
         break;
      case 31:
         msg = "Wafer protrusion";
         break;
      case 32:
         msg = "FOUP mount error (Mount sensor)";
         break;
      case 33:
         msg = "FOUP mount error (Load sensor)";
         break;
      case 34:
         msg = "Air pressure drop";
         break;
      case 35:
         msg = "Host error";
         break;
      case 36:
         msg = "Parameter error";
         break;
      case 37:
         msg = "FAN stop alarm";
         break;
      case 38:
         msg = "Voltage drop";
         break;
      case 39:
         msg = "Dock hand pinch error";
         break;

   }
   pnlLoadPortErrorMsg->Caption = msg;
   pnlLoadPortErrorMsg->Hint = msg;

   // 2020 5 20a - chc Error Log
   if(code > 0) {
      AddErrorLog("[LoadPort] " + errorcode + ": " + msg);
   }

}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnLoadPortMapClick(TObject *Sender)
{

   edLoadPortCmd->Text = "GET:MAPR;";                                           // 1 ~ 25
   btnLoadPortCMDClick(this);
}
//---------------------------------------------------------------------------
// Load/Unload LoadUnloadState = 1/2;
// 1: LPLD / LOUD
// 2: LOLD / LPUD
void __fastcall TfrnMain::tmLoadUnloadTimer(TObject *Sender)
{
long StartTime,StopTime,Elapsedms;
short StartTick,StopTick;
int step = 0;
AnsiString msg;

   tmLoadUnload->Enabled = false;

   if(pnlLoadPort->Enabled == false) {
      return;
   }

   GetTimeTic(&StartTime,&StartTick);
   while(1) {
      Sleep(1);
      Application->ProcessMessages();
      GetTimeTic(&StopTime,&StopTick);
      Elapsedms = ((StopTime*1000+StopTick) - (StartTime*1000+StartTick));
      if(Elapsedms > 5000) {
         WriteSystemLog("tmLoadUnloadTimer TimeOut! " + IntToStr(step));
         return;
      }
      if(pnlLoadPort->Enabled == true) {
         if(step == 0) {
            step = 1;
            if(LoadUnloadState == 1) {
               edLoadPortCmd->Text = "SET:LPLD;";
            }
            else {
               edLoadPortCmd->Text = "SET:LOLD;";
            }
            btnLoadPortCMDClick(this);
         }
         else if(step == 1) {
            step = 2;
            if(LoadUnloadState == 1) {
               edLoadPortCmd->Text = "SET:LOUD;";
            }
            else {
               edLoadPortCmd->Text = "SET:LPUD;";
            }
            btnLoadPortCMDClick(this);
            return;
         }
      }
   }
}
//---------------------------------------------------------------------------
// 2020 5 14 - chc Error Code
//00  Normal
//10  Suction ON time over
//11  Suction OFF time over
//12  Lift UP time over
//13  Lift DOWN time over
//14  Workpiece lost error
//40  AREA ERROR
//50  OVER RUN ERROR
//99  SYSTEM ERROR
//A0  DRIVER ERROR
//D0  LINE SENSOR NOT READY
//D1  SEARCHED FEW EDGES
//D3  SCAN DATA OVER FLOW
//D5  ROTATION.LESS
//D7  OFFSET LIMIT OVER
//D8  OFFSET ROBOT OVER
//D9  OFFSET AXIS OVER
//DA  OFFSET ADDR ERROR
//DB  MOTOR DIRECTION ERROR
//DC  PARAMETER ERROR
void __fastcall TfrnMain::PutAlignerCodeMsg()
{
AnsiString msg = "";
AnsiString errorcode;
int code = 0;

   errorcode = pnlAlignerErrorCode->Caption;
   if(errorcode == "")
      code = 0;
   else if(errorcode == "10")
      code = 1;
   else if(errorcode == "11")
      code = 2;
   else if(errorcode == "12")
      code = 3;
   else if(errorcode == "13")
      code = 4;
   else if(errorcode == "14")
      code = 5;
   else if(errorcode == "40")
      code = 6;
   else if(errorcode == "50")
      code = 7;
   else if(errorcode == "99")
      code = 8;
   else if(errorcode == "A0")
      code = 9;
   else if(errorcode == "D0")
      code = 10;
   else if(errorcode == "D1")
      code = 11;
   else if(errorcode == "D3")
      code = 12;
   else if(errorcode == "D5")
      code = 13;
   else if(errorcode == "D7")
      code = 14;
   else if(errorcode == "D8")
      code = 15;
   else if(errorcode == "D9")
      code = 16;
   else if(errorcode == "DA")
      code = 17;
   else if(errorcode == "DB")
      code = 18;
   else if(errorcode == "DC")
      code = 19;

   switch(code) {
      case 0:
         msg = "";
         break;
      case 1:
         msg = "Suction ON time over";
         break;
      case 2:
         msg = "Suction OFF time over";
         break;
      case 3:
         msg = "Lift UP time over";
         break;
      case 4:
         msg = "Lift DOWN time over";
         break;
      case 5:
         msg = "Workpiece lost error";
         break;
      case 6:
         msg = "AREA ERROR";
         break;
      case 7:
         msg = "OVER RUN ERROR";
         break;
      case 8:
         msg = "SYSTEM ERROR";
         break;
      case 9:
         msg = "DRIVER ERROR";
         break;
      case 10:
         msg = "LINE SENSOR NOT READY";
         break;
      case 11:
         msg = "SEARCHED FEW EDGES";
         break;
      case 12:
         msg = "SCAN DATA OVER FLOW";
         break;
      case 13:
         msg = "ROTATION.LESS";
         break;
      case 14:
         msg = "OFFSET LIMIT OVER";
         break;
      case 15:
         msg = "OFFSET ROBOT OVER";
         break;
      case 16:
         msg = "OFFSET AXIS OVER";
         break;
      case 17:
         msg = "OFFSET ADDR ERROR";
         break;
      case 18:
         msg = "MOTOR DIRECTION ERROR";
         break;
      case 19:
         msg = "PARAMETER ERROR";
         break;

   }
   pnlAlignerErrorMsg->Caption = msg;
   pnlAlignerErrorMsg->Hint = msg;

   // 2020 5 20a - chc Error Log
   if(code > 0) {
      AddErrorLog("[Aligner] " + errorcode + ": " + msg);
   }

}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnAlignerStasClick(TObject *Sender)
{

   // 2022 12 19 - chc Tazmo
   if(RobotMode == ROBOT_MODE_TAZMO) {
      edAlignerCmd->Text = "STS";
      // 要Refresh
      edAlignerCmd->Refresh();
      btnAlignerCMDClick(this);
      return;
   }

   edAlignerCmd->Text = "GET:STAS;";

   // 2020 7 17 - chc 是ORGN, 加做STAT
   //WriteSystemLog("Aligner: 是ORGN, 送出GET:STAS...");

   btnAlignerCMDClick(this);
}
//---------------------------------------------------------------------------
// 2022 7 6 - chc Error Log
// ErrorLog.txt
void __fastcall TfrnMain::AddErrorLog(AnsiString msg)
{
AnsiString temp;

   DateTimeToString(temp,"yyyy'/'mm'/'dd hh':'nn':'ss",Now());
   msg = temp + "> " + msg + "\n";
   mmLog->Lines->Append(msg);

   FILE *logFile;
   logFile = fopen(ErrorLogFileName.c_str(),"a+t");
   fprintf(logFile,msg.c_str());
   fclose(logFile);

}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnRobotEnableClick(TObject *Sender)
{

   pnlRobot->Enabled = true;
   btnRobotEnable->Visible = false;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnLoadPortEnableClick(TObject *Sender)
{

   pnlLoadPort->Enabled = true;
   btnLoadPortEnable->Visible = false;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnAlignerEnableClick(TObject *Sender)
{

   pnlAligner->Enabled = true;
   btnAlignerEnable->Visible = false;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnRobotStasClick(TObject *Sender)
{

   // 2022 12 22 - chc Chuck Wafer? Tazmo
   if(RobotMode == ROBOT_MODE_TAZMO) {
      edRobotCmd->Text = "STS";
      // 要Refresh
      edRobotCmd->Refresh();
      btnRobotCMDClick(this);
      return;
   }   

   edRobotCmd->Text = "LS";
   btnRobotCMDClick(this);
}
//---------------------------------------------------------------------------
// 2022 7 7 - chc change Com Port
void __fastcall TfrnMain::combRobotComportChange(TObject *Sender)
{

   InitRobotCom();
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::combLoadPortComportChange(TObject *Sender)
{

   InitLoadPortCom();
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::combAlignerComportChange(TObject *Sender)
{

   InitAlignerCom();
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::combRobotBaudrateChange(TObject *Sender)
{

   InitRobotCom();
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::combLoadPortBaudrateChange(TObject *Sender)
{

   InitLoadPortCom();
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::combAlignerBaudrateChange(TObject *Sender)
{

   InitAlignerCom();
}
//---------------------------------------------------------------------------
// 2022 7 8 - chc Beep結束
void __fastcall TfrnMain::tmBeepTimer(TObject *Sender)
{

   tmBeep->Enabled = false;
   //frnMain->cbID5Bit15->Checked = false;
   //WriteDO(IO3_ID);
   frnMain->cbBit15->Checked = false;
   WriteDO(IO1_ID);
}
//---------------------------------------------------------------------------
// 2022 7 8 - chc Setting ComPort
void __fastcall TfrnMain::btnRobotConnectClick(TObject *Sender)
{

   try {
      ybRobot->SettingsDialog(this,true);
      if(boolRobotStatus == false)
         ybRobot->Active = true;
      boolRobotStatus = true;
      RobotButton();
   }
   catch(Exception &e) {
      ShowMessage("ybRobot: " + e.Message);
      boolRobotStatus = false;
      RobotButton();
      pnlSystemMessage->Caption = "COM Port(Robot) 啟動失敗!";
      WriteSystemLog(pnlSystemMessage->Caption);
   }
   UpdateRobotStatus();
}
//---------------------------------------------------------------------------
// 2022 7 8 - chc Robot 點位
void __fastcall TfrnMain::btnRobotPosClick(TObject *Sender)
{
int pos;

   pnlRobotOriginal->Color = clSilver;

   // 2022 12 19 - chc Tazmo
   if(RobotMode == ROBOT_MODE_TAZMO) {
bool ret;
int no,slot,arm;
AnsiString str;

      no = edRobotPos->Text.ToInt();
      if(no == 1 || no == 2 || no == 11 || no == 12 || no == 21 || no == 22 || no == 23 || no == 31 || no == 32 || no == 33) {
         if(no == 1 || no == 11 || no == 21 || no == 22 || no == 23)
            arm = 1;
         else
            arm = 2;
         slot = 1;
         if(no == 1 || no == 2)
            slot = combRobotTrayNo->Text.ToInt();
         str.sprintf("MTP,%d,%d,%d",no,slot,arm);
         edRobotCmd->Text = str;
         // 要Refresh
         edRobotCmd->Refresh();
         btnRobotCMDClick(this);
         ret = WaitTMRobotDone(30000);
         if(ret == true)
            pnlRobotOriginal->Color = clLime;
         else
            pnlRobotOriginal->Color = clRed;
      }
      else
         pnlRobotOriginal->Color = clRed;
      return;
   }

   pos = edRobotPos->Text.ToInt();
   pnlRobotPos->Color = clSilver;
   if(SendRobotPosCMD(pos) == false)
      pnlRobotPos->Color = clRed;
   else
      pnlRobotPos->Color = clLime;
}
//---------------------------------------------------------------------------

//#define WAFER_TOP                0
//#define WAFER_BACK               1
int WafeFromFOUP = 0;
// 取片:
// rgWaferLocatino: LoadPort(880/881/882/883), Aligner(810/811/812/813), Chuck(1810/1811/1812/1813)
// => Aligner:
//    WCH(Down) - No: finish
//    WCH(Down) - Yes: PRP - finish
void __fastcall TfrnMain::btnRobotGetClick(TObject *Sender)
{
bool ret;
int no,zvalue,waferno;
AnsiString msg,offsetstr,name,waferid;
TPanel *panel,*panela;
int slotno,foupno,stageno,cnt,timeout;

   pnlRobotGet->Color = clSilver;

   // 2022 9 6 - chc 確認Robot無片
   if(boolInLoad != true && boolInUnLoad != true) {
      // Robot是否有片?
      btnRobotWithWaferClick(this);

      // 2022 9 22 - chc 等待完成 2000ms: pnlRobotWithWafer->Color
      /*
      // 等
      cnt = 0;

      // 2022 9 12 - chc 延長到4秒
      //timeout = 20;
      timeout = 40;

      while(1) {
         if(pnlRobot->Enabled == true)
            break;
         Sleep(100);
         Application->ProcessMessages();
         cnt++;
         if(cnt > timeout) {
            pnlLoadWafer->Color = clRed;
            pnlRobotMessage->Caption = "Get失敗: Robot通訊異常!";
            WriteSystemLog(pnlRobotMessage->Caption);
            pnlRobotGet->Color = clRed;
            return;
         }
      }
      if(pnlRobotWithWafer->Color == clLime) {
      */
      if(pnlRobotWithWafer->Color == clLime || pnlRobotWithWafer->Color == clRed) {

         pnlRobotMessage->Caption = "Get失敗: Robot上有Wafer!";
         WriteSystemLog(pnlRobotMessage->Caption);
         pnlRobotGet->Color = clRed;
         return;
      }
      WriteSystemLog("Get: Robot無片 Ok");
   }

   // 2022 9 6 - chc 若是在取退片呼叫, 則不用檢查
   if(boolInLoad == true || boolInUnLoad == true)
      goto ready;

   // 確認LP1是否已Load?
   if(rgWaferLocation->ItemIndex == LOCATION_LP1) {
      WriteSystemLog("確認LP1是否Ready?");
      btnLoadPortStasClick(this);
      ret = WaitLoadPortDone(5000);
      if(ret == false) {
         pnlRobotMessage->Caption = "LoadPort1: Timeout!";
         pnlRobotGet->Color = clRed;
         WriteSystemLog(pnlRobotMessage->Caption);
         return;
      }
      if(pnlLoadPortS3->Caption != "2") {
         pnlRobotMessage->Caption = "LoadPort1: 動作中!";
         pnlRobotGet->Color = clRed;
         WriteSystemLog(pnlRobotMessage->Caption);
         return;
      }
      WriteSystemLog("確認LP1已Ready.");
   }
   // 確認LP2是否已Load?
   else if(rgWaferLocation->ItemIndex == LOCATION_LP2) {
      WriteSystemLog("確認LP2是否Ready?");
      btnLoadPort2StasClick(this);
      ret = WaitLoadPort2Done(5000);
      if(ret == false) {
         pnlRobotMessage->Caption = "LoadPort2: Timeout!";
         pnlRobotGet->Color = clRed;
         WriteSystemLog(pnlRobotMessage->Caption);
         return;
      }
      if(pnlLoadPort2S3->Caption != "2") {
         pnlRobotMessage->Caption = "LoadPort2: 動作中!";
         pnlRobotGet->Color = clRed;
         WriteSystemLog(pnlRobotMessage->Caption);
         return;
      }
      WriteSystemLog("確認LP2已Ready.");
   }

   // Aligner
   //   WCH(Down) - No: finish
   //   WCH(Down) - Yes: PRP - finish
   // 2022 12 19 - chc Tazmo
   else if(rgWaferLocation->ItemIndex == LOCATION_ALIGNER1 && RobotMode == ROBOT_MODE_TAZMO) {
      btnAlignerWithWaferClick(this);
      if(pnlAlignerWithWafer->Color != clLime) {
         pnlRobotMessage->Caption = "Get失敗: Alinger1上無Wafer!";
         WriteSystemLog(pnlRobotMessage->Caption);
         pnlRobotGet->Color = clRed;
         return;
      }
      else {
         btnAlignerPRPClick(this);
         if(pnlAlignerPRP->Color != clLime) {
            pnlRobotMessage->Caption = "Alinger1: PRP Fail!";
            pnlRobotGet->Color = clRed;
            WriteSystemLog(pnlRobotMessage->Caption);
            return;
         }
      }
   }
   else if(rgWaferLocation->ItemIndex == LOCATION_ALIGNER2 && RobotMode == ROBOT_MODE_TAZMO) {
      btnAligner2WithWaferClick(this);
      if(pnlAligner2WithWafer->Color != clLime) {
         pnlRobotMessage->Caption = "Get失敗: Alinger12無Wafer!";
         WriteSystemLog(pnlRobotMessage->Caption);
         pnlRobotGet->Color = clRed;
         return;
      }
      else {
         btnAligner2PRPClick(this);
         if(pnlAligner2PRP->Color != clLime) {
            pnlRobotMessage->Caption = "Alinger2: PRP Fail!";
            pnlRobotGet->Color = clRed;
            WriteSystemLog(pnlRobotMessage->Caption);
            return;
         }
      }
   }

   // 2022 12 28 - chc Tazmo
   else if(rgWaferLocation->ItemIndex == LOCATION_MACRO) {

      // 2023 1 11 - chc all do
      //if(frnMain->RobotMode != ROBOT_MODE_TAZMO) {

         // Check DI : ID3 DI00~DI13全亮, input_DI2
         if(CheckMacroReady() == false) {
            btnMacroHomeClick(this);
            if(pnlMacroHome->Color != clLime) {
               pnlRobotMessage->Caption = "Macro Home Fail!";
               pnlRobotGet->Color = clRed;
               WriteSystemLog(pnlRobotMessage->Caption);
               return;
            }
         }

      //}

   }

ready:
   // 2022 7 27 - chc 檢查W
   if(cbPause->Checked == true) {
      if(Application->MessageBox("移動Robot軸(取片)     ", "取片作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         pnlRobotGet->Color = clRed;
         return;
      }
   }

   // 2022 12 20 - chc Tazmo
   if(frnMain->RobotMode != ROBOT_MODE_TAZMO) {

      WriteSystemLog("Robot Arm收回...");
      // 2022 9 2 - chc Get/Put前先將Arm收回
      if(RobotArmWithDraw() == false) {
         pnlRobotGet->Color = clRed;
         pnlAlarmMessage->Caption = "Robot(取片)Arm收回失敗!";
         frnMain->AddMainLog("Robot(Get)Arm Error!", ROBOT_ARM_GET_ERR,true);
         return;
      }
      WriteSystemLog("Robot Arm收回.");
   }

   if(GoRobotWAxis(0) == false) {
      pnlRobotGet->Color = clRed;
      pnlAlarmMessage->Caption = "W軸(取片)移動失敗!";
      frnMain->AddMainLog("WAxis(Get)Move Error!", RAXIS_GET_ERR,true);
      return;
   }
   WriteSystemLog("W軸到位.");

   ChangeWaferPosition(rgWaferLocation->ItemIndex,WAFER_GET,1);
   waferno = combRobotTrayNo->Text.ToInt();

   // 2022 12 20 - chc Tazmo
   if(frnMain->RobotMode == ROBOT_MODE_TAZMO) {
      if(rgWaferLocation->ItemIndex == LOCATION_LP1) {
         no = 1;
         name = "Cassette";
         WafeFromFOUP = 1;
         rgCST->ItemIndex = WafeFromFOUP - 1;
      }
      else if(rgWaferLocation->ItemIndex == LOCATION_LP2) {
         no = 2;
         name = "Cassette";
         WafeFromFOUP = 2;
         rgCST->ItemIndex = WafeFromFOUP - 1;
      }
      else if(rgWaferLocation->ItemIndex == LOCATION_ALIGNER1) {
         no = 11;
         name = "Aligner";
         waferno = 1;
         WafeFromFOUP = 1;
      }
      else if(rgWaferLocation->ItemIndex == LOCATION_ALIGNER2) {
         no = 12;
         name = "Aligner";
         waferno = 1;
         WafeFromFOUP = 2;
      }
      else if(rgWaferLocation->ItemIndex == LOCATION_CHUCK) {
         if(rgCST->ItemIndex == LOADPORT_1) {
            no = 23;
            WafeFromFOUP = 1;
         }
         else {
            no = 33;
            WafeFromFOUP = 2;
         }
         name = "Chuck";
         waferno = 1;
         // 到入料點
         btnToLoadPositionClick(this);
         if(pnlToLoadPosition->Color != clLime) {
            pnlRobotGet->Color = clRed;
            pnlAlarmMessage->Caption = "Stage(入料點)移動失敗!";
            frnMain->AddMainLog("Stage Move Error!", STAGE_MOVE_ERR,true);
            return;
         }
      }
      else if(rgWaferLocation->ItemIndex == LOCATION_MACRO) {
         WafeFromFOUP = rgCST->ItemIndex + 1;
         if(WafeFromFOUP == 0) {
            if(rgCST->ItemIndex == LOADPORT_1)
               WafeFromFOUP = 1;
            else
               WafeFromFOUP = 2;
         }
         if(WafeFromFOUP == 1 && rgSide->ItemIndex == WAFER_TOP)
            no = 21;
         else if(WafeFromFOUP == 1 && rgSide->ItemIndex == WAFER_BACK)
            no = 22;
         else if(WafeFromFOUP == 2 && rgSide->ItemIndex == WAFER_TOP)
            no = 31;
         else if(WafeFromFOUP == 2 && rgSide->ItemIndex == WAFER_BACK)
            no = 32;
         name = "Macro";
         waferno = 1;
      }
      if(rgWaferLocation->ItemIndex == LOCATION_LP1 || rgWaferLocation->ItemIndex == LOCATION_LP2) {
         if(rgWaferLocation->ItemIndex == LOCATION_LP2)
            panel = (TPanel*)(FindComponent("pnlTray2_" + IntToStr(waferno)));
         else
            panel = (TPanel*)(FindComponent("pnlTray" + IntToStr(waferno)));
         panela = (TPanel*)(frmRecipe->FindComponent("pnlTray" + IntToStr(waferno)));
      }

      // 點位,Slot,Arm
      msg.sprintf("MTP,%d,%d,%d",no,waferno,WafeFromFOUP);
   }
   else {

      offsetstr.sprintf(" (0 0 0 0)");
      // 點位
      if(rgWaferLocation->ItemIndex == LOCATION_LP1) {
         no = 880;
         // 2020 4 27 - chc 降1mm
         offsetstr.sprintf(" ( 0 0 %d 0)",(waferno-1)*10);
         //offsetstr.sprintf(" ( 0 0 %d 0)",(waferno-1)*10-1);
         name = "Cassette";
      }
      else if(rgWaferLocation->ItemIndex == LOCATION_ALIGNER1) {
         no = 810;
         name = "Aligner";
      }
      else if(rgWaferLocation->ItemIndex == LOCATION_CHUCK) {
         no = 1810;
         name = "Chuck";

         // 2022 8 10 - chc 到入料點
         btnToLoadPositionClick(this);
         if(pnlToLoadPosition->Color != clLime) {
            pnlRobotGet->Color = clRed;
            pnlAlarmMessage->Caption = "Stage(入料點)移動失敗!";
            frnMain->AddMainLog("Stage Move Error!", STAGE_MOVE_ERR,true);
            return;
         }

      }

      // 2022 7 10 - chc 加入LP2/Macro
      else if(rgWaferLocation->ItemIndex == LOCATION_LP2) {
         no = 980;
         offsetstr.sprintf(" ( 0 0 %d 0)",(waferno-1)*10);
         name = "Cassette2";
      }
      else if(rgWaferLocation->ItemIndex == LOCATION_MACRO) {
         no = 710;
         name = "Macro";
         // 到Robot位置 & 關內外環真空
         btnMacroRobotPositionClick(this);
         if(pnlMacroRobotPosition->Color != clLime) {
            pnlRobotMessage->Caption = "Macro(Get): Robot位置異常!";
            pnlRobotPut->Color = clRed;
            WriteSystemLog(pnlRobotMessage->Caption);
            pnlAlarmMessage->Caption = pnlRobotMessage->Caption;
            return;
         }
      }

      // 2020 4 21 - chc LoadPort
      // 880
      // 2022 7 27 - chc 加入LP2/Macro
      //if(rgWaferLocation->ItemIndex == LOCATION_LP1)
      if(rgWaferLocation->ItemIndex == LOCATION_LP1 || rgWaferLocation->ItemIndex == LOCATION_LP2) {
         msg.sprintf("GP %d%s",no,offsetstr);
         if(rgWaferLocation->ItemIndex == LOCATION_LP2)
            panel = (TPanel*)(FindComponent("pnlTray2_" + IntToStr(waferno)));
         else

            panel = (TPanel*)(FindComponent("pnlTray" + IntToStr(waferno)));
         panela = (TPanel*)(frmRecipe->FindComponent("pnlTray" + IntToStr(waferno)));
      }
      else

         msg.sprintf("GP %d",no);
   }

   edRobotCmd->Text = msg;
   // ==> 1
   // 2020 4 23 - chc Log
   WriteSystemLog("Robot取片1: " + msg);

   if(cbPause->Checked == true) {
      if(Application->MessageBox(("Robot-1準備由" + name + "取第" + IntToStr(waferno) + "片(MTP)? " + msg).c_str(), "取片作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         pnlRobotGet->Color = clRed;
         return;
      }
   }

   // 2020 4 27 - chc 要先設定狀態
   RobotCmdState = ROBOT_CMD_STATE_NONE;

   // 2020 5 6 - chc Log
   WriteSystemLog("RobotCmdState-10 = ROBOT_CMD_STATE_NONE");

   // 2022 12 20 - chc Tazmo
   if(frnMain->RobotMode == ROBOT_MODE_TAZMO)
      RobotCmd = ROBOT_CMD_MTP;
   else

      RobotCmd = ROBOT_CMD_GP;

   // 2020 5 6 - chc Log
   WriteSystemLog("RobotCmd-10 = ROBOT_CMD_GP");

   // 2020 4 27 - chc Robot是否已動作?
   boolRobot4401 = false;

   btnRobotCMDClick(this);

   // 2022 12 20 - chc Tazmo
   if(frnMain->RobotMode == ROBOT_MODE_TAZMO)
      ret = WaitTMRobotDone(30000);
   else

      ret = WaitRobotDone(10000);

   if(ret == false) {
      pnlRobotMessage->Caption = IntToStr(no) + ": Timeout!";
      pnlRobotGet->Color = clRed;
      return;
   }

   // 2022 12 20 - chc Tazmo
   if(frnMain->RobotMode == ROBOT_MODE_TAZMO) {
      ChangeWaferPosition(rgWaferLocation->ItemIndex,WAFER_GET,2);
      // Vacuum off
      if(rgWaferLocation->ItemIndex == LOCATION_MACRO) {
         WriteSystemLog("RobotCmd-12 = 內外環真空Off...");
         MacroVacuum(false);
         WriteSystemLog("RobotCmd-12 = 內外環真空Off.");
      }
      // 放真空
      else if(rgWaferLocation->ItemIndex == LOCATION_CHUCK) {
         WriteSystemLog("RobotCmd-12 = Chuck真空關...");
         // Chuck放真空
         ChuckVacuum(false);
         WriteSystemLog("RobotCmd-12 = Chuck真空關.");
      }
      // 點位,Slot,Arm
      msg.sprintf("GET,%d,%d,%d",no,waferno,WafeFromFOUP);
      edRobotCmd->Text = msg;
      WriteSystemLog("Robot取片1a: " + msg);
      if(cbPause->Checked == true) {
         if(Application->MessageBox(("Robot-1準備由" + name + "取第" + IntToStr(waferno) + "片(GET)? " + msg).c_str(), "取片作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
            pnlRobotGet->Color = clRed;
            return;
         }
      }
      // 要先設定狀態
      RobotCmdState = ROBOT_CMD_STATE_NONE;
      WriteSystemLog("RobotCmdState-10 = ROBOT_CMD_STATE_NONE");
      RobotCmd = ROBOT_CMD_GET;
      WriteSystemLog("RobotCmd-10 = ROBOT_CMD_GET");
      btnRobotCMDClick(this);
      ret = WaitTMRobotDone(10000);
      if(ret == false) {
         pnlRobotMessage->Caption = IntToStr(no) + ": Timeout!";
         pnlRobotGet->Color = clRed;
         return;
      }
      pnlWaferRobotInformation->Color = clLime;
   }
   else {

      no++;
      // LoadPort
      // 881
      // 2022 7 27 - chc 加入LP2/Macro
      //if(rgWaferLocation->ItemIndex == LOCATION_LP1)
      if(rgWaferLocation->ItemIndex == LOCATION_LP1 || rgWaferLocation->ItemIndex == LOCATION_LP2)

         msg.sprintf("GP %d%s",no,offsetstr);
      else

         msg.sprintf("GP %d",no);
      edRobotCmd->Text = msg;

      // ==> 2
      // 2020 4 23 - chc Log
      WriteSystemLog("Robot取片2: " + msg);

      if(cbPause->Checked == true) {
         if(Application->MessageBox(("Robot-2準備由" + name + "取第" + IntToStr(waferno) + "片? " + msg).c_str(), "取片作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
            pnlRobotGet->Color = clRed;
            return;
         }
      }

      ChangeWaferPosition(rgWaferLocation->ItemIndex,WAFER_GET,2);

      // 2020 4 27 - chc 要先設定狀態
      RobotCmdState = ROBOT_CMD_STATE_NONE;

      // 2020 5 6 - chc Log
      WriteSystemLog("RobotCmdState-11 = ROBOT_CMD_STATE_NONE");

      RobotCmd = ROBOT_CMD_GP;

      // 2020 5 6 - chc Log
      WriteSystemLog("RobotCmd-11 = ROBOT_CMD_GP");

      // 2020 4 27 - chc Robot是否已動作?
      boolRobot4401 = false;

      btnRobotCMDClick(this);
      ret = WaitRobotDone(10000);
      if(ret == false) {
         pnlRobotMessage->Caption = IntToStr(no) + ": Timeout!";
         pnlRobotGet->Color = clRed;
         return;
      }

      // 2022 7 26 - chc Aligner 放真空
      if(rgWaferLocation->ItemIndex == LOCATION_ALIGNER1) {
         WriteSystemLog("RobotCmd-11a = Aligner放真空");
         btnAlignerVacuumOffClick(this);
         WaitTime(100);
      }

      // 2022 8 15 - chc 移到前面, 不用等待=> 利用Robor Vacuum
      if(rgWaferLocation->ItemIndex == LOCATION_MACRO) {
         WriteSystemLog("RobotCmd-12 = 內外環真空...");
         cbBit1->Checked = false;
         cbBit2->Checked = false;
         WriteDO(IO1_ID);
         WriteSystemLog("RobotCmd-12 = 內外環真空.");
      }

      // 放真空
      else if(rgWaferLocation->ItemIndex == LOCATION_CHUCK) {
         WriteSystemLog("RobotCmd-12 = Chuck真空關...");
         // Chuck放真空
         ChuckVacuum(false);
         WriteSystemLog("RobotCmd-12 = Chuck真空關.");
      }

      // 開真空
      RobotCmd = ROBOT_CMD_VACUUM;

      // 2020 5 6 - chc Log
      WriteSystemLog("RobotCmd-12 = ROBOT_CMD_VACUUM on");

      btnRobotVacuumOnClick(this);
      ret = WaitRobotDone(10000);
      if(ret == false) {
         pnlRobotMessage->Caption = "Vacuum On: Timeout!";
         pnlRobotGet->Color = clRed;
         return;
      }
      WriteSystemLog("RobotCmd-12 = ROBOT_CMD_VACUUM on ok.");

      no++;
      // 2020 4 21 - chc LoadPort
      // 882
      // 2022 7 27 - chc 加入LP2/Macro
      //if(rgWaferLocation->ItemIndex == LOCATION_LP1)
      if(rgWaferLocation->ItemIndex == LOCATION_LP1 || rgWaferLocation->ItemIndex == LOCATION_LP2)
         msg.sprintf("GP %d%s",no,offsetstr);
      else

         msg.sprintf("GP %d",no);
      edRobotCmd->Text = msg;

      // 2022 7 26 - chc 關內外
      // 2022 8 15 - chc 移到前面, 不用等待=> 利用Robor Vacuum
      //if(rgWaferLocation->ItemIndex == LOCATION_MACRO) {
      //   WriteSystemLog("RobotCmd-12 = 內外環真空...");
      //   cbBit1->Checked = false;
      //   cbBit2->Checked = false;
      //   WriteDO(IO1_ID);
      //   // 2022 8 15 - chc 改成200ms
      //   WaitTime(200);
      //   WriteSystemLog("RobotCmd-12 = 內外環真空.");
      //}
      //
      //// 2022 8 8 - chc 放真空
      //else if(rgWaferLocation->ItemIndex == LOCATION_CHUCK) {
      //   WriteSystemLog("RobotCmd-12 = Chuck真空關...");
      //   // Chuck放真空
      //   ChuckVacuum(false);
      //   // 2022 8 15 - chc 改成200ms
      //   WaitTime(200);
      //   WriteSystemLog("RobotCmd-12 = Chuck真空關.");
      //}

      // ==> 3
      // 2020 4 23 - chc Log
      WriteSystemLog("Robot取片3: " + msg);

      if(cbPause->Checked == true) {
         if(Application->MessageBox(("Robot-3準備由" + name + "取第" + IntToStr(waferno) + "片? " + msg).c_str(), "取片作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
            pnlRobotGet->Color = clRed;
            return;
         }
      }

      // 2020 4 27 - chc 要先設定狀態
      RobotCmdState = ROBOT_CMD_STATE_NONE;

      // 2020 5 6 - chc Log
      WriteSystemLog("RobotCmdState-12 = ROBOT_CMD_STATE_NONE");

      RobotCmd = ROBOT_CMD_GP;

      // 2020 5 6 - chc Log
      WriteSystemLog("RobotCmd-13 = ROBOT_CMD_GP");

      // 2020 4 27 - chc Robot是否已動作?
      boolRobot4401 = false;

      btnRobotCMDClick(this);
      ret = WaitRobotDone(10000);
      if(ret == false) {
         pnlRobotMessage->Caption = IntToStr(no) + ": Timeout!";
         pnlRobotGet->Color = clRed;
         return;
      }
      pnlWaferRobotInformation->Color = clLime;
   }

   if(rgWaferLocation->ItemIndex == LOCATION_ALIGNER1) {
      pnlWaferAlignerInformation->Color = (TColor)0x0068C6AA;
      pnlWaferAlignerInformation->Caption = "";
      stageno = STAGE_ALIGNER;
   }
   else if(rgWaferLocation->ItemIndex == LOCATION_LP1) {
      panel->Color = (TColor)0x0068C6AA;
      panela->Color = (TColor)0x0068C6AA;
   }
   else if(rgWaferLocation->ItemIndex == LOCATION_LP2) {
      panel->Color = (TColor)0x0068C6AA;
      panela->Color = (TColor)0x0068C6AA;
   }
   else if(rgWaferLocation->ItemIndex == LOCATION_CHUCK) {
      pnlWaferChuckInformation->Color = (TColor)0x0068C6AA;
      stageno = STAGE_CHUCK;
      pnlWaferChuckInformation->Caption = "";
   }
   else if(rgWaferLocation->ItemIndex == LOCATION_MACRO) {
      pnlWaferMacroInformation->Color = (TColor)0x0068C6AA;
      stageno = STAGE_MACRO;
      pnlWaferMacroInformation->Caption = "";
   }

   // 2022 12 20 - chc Tazmo
   if(frnMain->RobotMode == ROBOT_MODE_TAZMO) {
      if(rgWaferLocation->ItemIndex == LOCATION_ALIGNER2) {
         pnlWaferAlignerInformation->Color = (TColor)0x0068C6AA;
         pnlWaferAlignerInformation->Caption = "";
         stageno = STAGE_ALIGNER;
      }
   }

   // 2022 8 23 - chc LP1/LP2不用轉換
   if(rgWaferLocation->ItemIndex != LOCATION_LP1 && rgWaferLocation->ItemIndex != LOCATION_LP2) {
      StageInformation[stageno].boolWithWafer = false;
      StageInformation[STAGE_ROBOT].boolWithWafer = true;
      StageInformation[STAGE_ROBOT].WaferID = StageInformation[stageno].WaferID;
      StageInformation[STAGE_ROBOT].SlotNo = StageInformation[stageno].SlotNo;
      StageInformation[STAGE_ROBOT].FoupNo = StageInformation[stageno].FoupNo;
      pnlWaferRobotInformation->Caption = IntToStr(StageInformation[STAGE_ROBOT].FoupNo) + "," + IntToStr(StageInformation[STAGE_ROBOT].SlotNo) + " " + StageInformation[STAGE_ROBOT].WaferID;
   }
   else {
      StageInformation[STAGE_ROBOT].boolWithWafer = true;
      StageInformation[STAGE_ROBOT].WaferID = "---";
      StageInformation[STAGE_ROBOT].SlotNo = 25 - rgWaferNo->ItemIndex;
      StageInformation[STAGE_ROBOT].FoupNo = rgFoupSource->ItemIndex + 1;
      pnlWaferRobotInformation->Caption = IntToStr(StageInformation[STAGE_ROBOT].FoupNo) + "," + IntToStr(StageInformation[STAGE_ROBOT].SlotNo) + " " + StageInformation[STAGE_ROBOT].WaferID;
   }

   // 2020 5 21 - chc 確認是否有真空(有片)?
   WriteSystemLog("Robot上有Wafer?");
   btnRobotWithWaferClick(this);

   // 2022 9 22 - chc 等待完成 2000ms: pnlRobotWithWafer->Color
   /*
   // 等待
   int timecnt = 0;

   // 2022 9 14a - chc 改成1000ms
   //int timemax = 5000;
   int timemax = 1000;

   while(1) {
      if(RobotWithWafer == ROBOT_WAFER_YES)
         break;
      WaitTime(100);
      timecnt += 100;
      if(timecnt > timemax) {
         pnlRobotMessage->Caption = IntToStr(no) + ": 無片!";
         pnlOperationMessage->Caption = "異常: Robot取片後Fork上無片!";
         pnlRobotGet->Color = clRed;

         // 2022 9 14a - chc 不管
         //return;
         break;

      }
   }
   */
   if(RobotWithWafer == ROBOT_WAFER_NO || pnlRobotWithWafer->Color == clRed) {
      pnlRobotMessage->Caption = IntToStr(no) + ": 無片!";
      pnlOperationMessage->Caption = "異常: Robot取片後Fork上無片!";
      pnlRobotGet->Color = clRed;
      return;
   }
   WriteSystemLog("Robot上有Wafer.");

   // 2022 12 20 - chc Tazmo
   if(frnMain->RobotMode != ROBOT_MODE_TAZMO) {

      no++;
      // 2020 4 21 - chc LoadPort
      // 883
      // 2022 7 27 - chc 加入LP2/Macro
      //if(rgWaferLocation->ItemIndex == LOCATION_LP1)
      if(rgWaferLocation->ItemIndex == LOCATION_LP1 || rgWaferLocation->ItemIndex == LOCATION_LP2)
         msg.sprintf("GP %d%s",no,offsetstr);
      else

         msg.sprintf("GP %d",no);
      edRobotCmd->Text = msg;

      // ==> 4
      // 2020 4 23 - chc Log
      WriteSystemLog("Robot取片4: " + msg);

      if(cbPause->Checked == true) {
         if(Application->MessageBox(("Robot-4準備由" + name + "取第" + IntToStr(waferno) + "片? " + msg).c_str(), "取片作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
            pnlRobotGet->Color = clRed;
            return;
         }
      }

      // 2020 4 27 - chc 要先設定狀態
      RobotCmdState = ROBOT_CMD_STATE_NONE;

      // 2020 5 6 - chc Log
      WriteSystemLog("RobotCmdState-13 = ROBOT_CMD_STATE_NONE");

      RobotCmd = ROBOT_CMD_GP;

      // 2020 5 6 - chc Log
      WriteSystemLog("RobotCmd-14 = ROBOT_CMD_GP");

      // 2020 4 27 - chc Robot是否已動作?
      boolRobot4401 = false;

      btnRobotCMDClick(this);
      ret = WaitRobotDone(10000);
      if(ret == false) {
         pnlRobotMessage->Caption = IntToStr(no) + ": Timeout!";
         pnlRobotGet->Color = clRed;
         return;
      }
   }
   pnlRobotMessage->Caption = "GET: Succ.";
   pnlRobotGet->Color = clLime;

   ChangeWaferPosition(rgWaferLocation->ItemIndex,WAFER_GET,4);

   // 2020 4 27 - chc 若為Aligner, 取片後要做ORGN
   if(rgWaferLocation->ItemIndex == LOCATION_ALIGNER1 || rgWaferLocation->ItemIndex == LOCATION_ALIGNER2) {

      // 2020 8 12 - chc TSMC修改: 改用timer
      /*
      long StartTime,StopTime,Elapsedms;
      short StartTick,StopTick;
      int timeout = 10000;
      boolAlignerORGN = false;
      btnAlignerORGNClick(this);
      WriteSystemLog("Wait... Aligner ORGN");
      GetTimeTic(&StartTime,&StartTick);
      while(1) {
         if(boolAlignerORGN == true && pnlAlignerORGN->Color == clLime)
            break;
         Sleep(50);
         Application->ProcessMessages();
         GetTimeTic(&StopTime,&StopTick);
         Elapsedms = ((StopTime*1000+StopTick) - (StartTime*1000+StartTick));
         if(Elapsedms > timeout) {
            pnlRobotGet->Color = clRed;
            pnlOperationMessage->Caption = "取片失敗: Aligner取片後歸Home異常!";
            WriteSystemLog(pnlOperationMessage->Caption);
            return;
         }
      }
      */
      tmAlignerORG->Enabled = true;

   }
}
//---------------------------------------------------------------------------
// 放片: 180/181/182/183
// rgWaferLocation: LoadPort(680/681/682/683), Aligner(610/611/612/613), Chuck(1610/1611/1612/1613)
// => Aligner:
//    WCH(Down) - Yes: finish
//    WCH(Down) - No: HOM - PRP - finish
void __fastcall TfrnMain::btnRobotPutClick(TObject *Sender)
{
bool ret;
int no,zvalue,waferno;
AnsiString msg,offsetstr,name,waferid;
TPanel *panel,*pnlstage,*panela;
int stageno,slotno,foupno,cnt,timeout,wno;

   // 2020 4 23 - chc LoadPort
   pnlRobotPut->Color = clSilver;

   // 2022 9 6 - chc 確認Robot無片
   if(boolInLoad != true && boolInUnLoad != true) {
      // Robot是否有片?
      btnRobotWithWaferClick(this);

      // 2022 9 22 - chc 等待完成 2000ms: pnlRobotWithWafer->Color
      /*
      // 等
      cnt = 0;

      // 2022 9 12 - chc 延長到4秒
      //timeout = 20;
      timeout = 40;

      while(1) {
         if(pnlRobot->Enabled == true)
            break;
         Sleep(100);
         Application->ProcessMessages();
         cnt++;
         if(cnt > timeout) {
            pnlLoadWafer->Color = clRed;
            pnlRobotMessage->Caption = "Put失敗: Robot通訊異常!";
            WriteSystemLog(pnlRobotMessage->Caption);
            pnlRobotPut->Color = clRed;
            return;
         }
      }
      if(pnlRobotWithWafer->Color != clLime) {
      */
      if(pnlRobotWithWafer->Color == clSilver || pnlRobotWithWafer->Color == clRed) {

         pnlRobotMessage->Caption = "Put失敗: Robot上無Wafer!";
         WriteSystemLog(pnlRobotMessage->Caption);
         pnlRobotPut->Color = clRed;
         return;
      }
      WriteSystemLog("Put: Robot有片 Ok");
   }

   // 2022 9 6 - chc 若是在取退片呼叫, 則不用檢查
   if(boolInLoad == true || boolInUnLoad == true)
      goto ready;

   // 確認LP1是否已Load?
   if(rgWaferLocation->ItemIndex == LOCATION_LP1) {
      WriteSystemLog("確認LP1是否Ready?");
      btnLoadPortStasClick(this);
      ret = WaitLoadPortDone(5000);
      if(ret == false) {
         pnlRobotMessage->Caption = "LoadPort1: Timeout!";
         pnlRobotPut->Color = clRed;
         WriteSystemLog(pnlRobotMessage->Caption);
         return;
      }
      if(pnlLoadPortS3->Caption != "2") {
         pnlRobotMessage->Caption = "LoadPort1: 動作中!";
         pnlRobotPut->Color = clRed;
         WriteSystemLog(pnlRobotMessage->Caption);
         return;
      }
      WriteSystemLog("確認LP1已Ready.");
   }
   // 確認LP2是否已Load?
   else if(rgWaferLocation->ItemIndex == LOCATION_LP2) {
      WriteSystemLog("確認LP2是否Ready?");
      btnLoadPort2StasClick(this);
      ret = WaitLoadPort2Done(5000);
      if(ret == false) {
         pnlRobotMessage->Caption = "LoadPort2: Timeout!";
         pnlRobotPut->Color = clRed;
         WriteSystemLog(pnlRobotMessage->Caption);
         return;
      }
      if(pnlLoadPort2S3->Caption != "2") {
         pnlRobotMessage->Caption = "LoadPort2: 動作中!";
         pnlRobotPut->Color = clRed;
         WriteSystemLog(pnlRobotMessage->Caption);
         return;
      }
      WriteSystemLog("確認LP2已Ready.");
   }

   // Aligner
   //   WCH(Down) - Yes: finish
   //   WCH(Down) - No: HOM - PRP - finish
   else if(rgWaferLocation->ItemIndex == LOCATION_ALIGNER1) {
      btnAlignerWithWaferClick(this);
      if(pnlAlignerWithWafer->Color == clLime) {
         pnlRobotMessage->Caption = "Put失敗: Alinger1上有Wafer!";
         WriteSystemLog(pnlRobotMessage->Caption);
         pnlRobotPut->Color = clRed;
         return;
      }
      else {
         btnAlignerPRPClick(this);
         if(pnlAlignerPRP->Color != clLime) {
            pnlRobotMessage->Caption = "Alinger1: PRP Fail!";
            pnlRobotPut->Color = clRed;
            WriteSystemLog(pnlRobotMessage->Caption);
            return;
         }
      }
   }
   else if(rgWaferLocation->ItemIndex == LOCATION_ALIGNER2) {
      btnAligner2WithWaferClick(this);
      if(pnlAligner2WithWafer->Color == clLime) {
         pnlRobotMessage->Caption = "Put失敗: Alinger12有Wafer!";
         WriteSystemLog(pnlRobotMessage->Caption);
         pnlRobotPut->Color = clRed;
         return;
      }
      else {
         btnAligner2PRPClick(this);
         if(pnlAligner2PRP->Color != clLime) {
            pnlRobotMessage->Caption = "Alinger2: PRP Fail!";
            pnlRobotPut->Color = clRed;
            WriteSystemLog(pnlRobotMessage->Caption);
            return;
         }
      }
   }

   // 2022 12 28 - chc Tazmo
   else if(rgWaferLocation->ItemIndex == LOCATION_MACRO) {

      // 2023 1 11 - chc All do
      //if(frnMain->RobotMode != ROBOT_MODE_TAZMO) {

         // Check DI : ID3 DI00~DI13全亮, input_DI2
         if(CheckMacroReady() == false) {
            btnMacroHomeClick(this);
            if(pnlMacroHome->Color != clLime) {
               pnlRobotMessage->Caption = "Macro Home Fail!";
               pnlRobotPut->Color = clRed;
               WriteSystemLog(pnlRobotMessage->Caption);
               return;
            }
         }

      //}

   }

ready:
   // 2022 7 27 - chc 檢查W
   if(cbPause->Checked == true) {
      if(Application->MessageBox("移動Robot軸(放片)     ", "取片作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         pnlRobotPut->Color = clRed;
         return;
      }
   }

   // 2022 12 20 - chc Tazmo
   if(frnMain->RobotMode != ROBOT_MODE_TAZMO) {

      // 2022 9 2 - chc Get/Put前先將Arm收回
      WriteSystemLog("Robot Arm收回...");
      if(RobotArmWithDraw() == false) {
         pnlRobotPut->Color = clRed;
         pnlAlarmMessage->Caption = "Robot(退片)Arm收回失敗!";
         frnMain->AddMainLog("Robot(Put)Arm Error!", ROBOT_ARM_PUT_ERR,true);
         return;
      }
      WriteSystemLog("Robot Arm收回.");
   }

   if(GoRobotWAxis(1) == false) {
      pnlRobotPut->Color = clRed;
      pnlAlarmMessage->Caption = "W軸(放片)移動失敗!";
      frnMain->AddMainLog("RAxis(Put)Error!", RAXIS_PUT_ERR,true);
      return;
   }
   WriteSystemLog("W軸到位.");

   ChangeWaferPosition(rgWaferLocation->ItemIndex,WAFER_PUT,1);

   // 2020 4 23 - chc LoadPort
   waferno = combRobotTrayNo->Text.ToInt();

   // 2022 12 20 - chc Tazmo
   if(frnMain->RobotMode == ROBOT_MODE_TAZMO) {
      if(rgWaferLocation->ItemIndex == LOCATION_LP1) {
         no = 1;
         name = "Cassette";
         WafeFromFOUP = 1;
         rgCST->ItemIndex = WafeFromFOUP - 1;
      }
      else if(rgWaferLocation->ItemIndex == LOCATION_LP2) {
         no = 2;
         name = "Cassette";
         WafeFromFOUP = 2;
         rgCST->ItemIndex = WafeFromFOUP - 1;
      }
      else if(rgWaferLocation->ItemIndex == LOCATION_ALIGNER1) {
         no = 11;
         name = "Aligner";
         waferno = 1;
      }
      else if(rgWaferLocation->ItemIndex == LOCATION_ALIGNER2) {
         no = 12;
         name = "Aligner";
         waferno = 1;
      }
      else if(rgWaferLocation->ItemIndex == LOCATION_CHUCK) {
         if(rgCST->ItemIndex == LOADPORT_1)
            no = 23;
         else
            no = 33;
         name = "Chuck";
         waferno = 1;
         // 到入料點
         btnToLoadPositionClick(this);
         if(pnlToLoadPosition->Color != clLime) {
            pnlRobotGet->Color = clRed;
            pnlAlarmMessage->Caption = "Stage(入料點)移動失敗!";
            frnMain->AddMainLog("Stage Move Error!", STAGE_MOVE_ERR,true);
            return;
         }
      }
      else if(rgWaferLocation->ItemIndex == LOCATION_MACRO) {
         WafeFromFOUP = rgCST->ItemIndex + 1;
         if(WafeFromFOUP == 1 && rgSide->ItemIndex == WAFER_TOP)
            no = 21;
         else if(WafeFromFOUP == 1 && rgSide->ItemIndex == WAFER_BACK)
            no = 22;
         else if(WafeFromFOUP == 2 && rgSide->ItemIndex == WAFER_TOP)
            no = 31;
         else if(WafeFromFOUP == 2 && rgSide->ItemIndex == WAFER_BACK)
            no = 32;
         else {
            pnlRobotGet->Color = clRed;
            pnlAlarmMessage->Caption = "Macro參數未定義!";
            frnMain->AddMainLog("Macro Parameters Error!", WAFER_GET_ERR,true);
            return;
         }
         name = "Macro";
         waferno = 1;
      }
      if(rgWaferLocation->ItemIndex == LOCATION_LP1 || rgWaferLocation->ItemIndex == LOCATION_LP2) {
         if(rgWaferLocation->ItemIndex == LOCATION_LP2)
            panel = (TPanel*)(FindComponent("pnlTray2_" + IntToStr(waferno)));
         else
            panel = (TPanel*)(FindComponent("pnlTray" + IntToStr(waferno)));
         panela = (TPanel*)(frmRecipe->FindComponent("pnlTray" + IntToStr(waferno)));
      }
      // 點位,Slot,Arm
      msg.sprintf("MTP,%d,%d,%d",no,waferno,WafeFromFOUP);
   }
   else {

      offsetstr.sprintf(" ( 0 0 0 0)");

      // 點位
      if(rgWaferLocation->ItemIndex == LOCATION_LP1) {
         name = "Cassette";
         no = 680;

         // 2020 4 23 - chc LoadPort
         // 2020 4 27 - chc 降1mm
         offsetstr.sprintf(" ( 0 0 %d 0)",(waferno-1)*10);
         //offsetstr.sprintf(" ( 0 0 %d 0)",(waferno-1)*10-1);

      }
      else if(rgWaferLocation->ItemIndex == LOCATION_ALIGNER1) {
         name = "Aligner";
         no = 610;
      }
      else if(rgWaferLocation->ItemIndex == LOCATION_CHUCK) {
         name = "Chuck";
         no = 1610;
         // Chuck開真空
         ChuckVacuum(true);

         // 2022 8 10 - chc 到入料點
         btnToLoadPositionClick(this);
         if(pnlToLoadPosition->Color != clLime) {
            pnlRobotPut->Color = clRed;
            pnlAlarmMessage->Caption = "Stage(入料點)移動失敗!";
            frnMain->AddMainLog("Stage Move Error!", STAGE_MOVE_ERR,true);
            return;
         }

      }

      // 2022 7 10 - chc 加入LP2/Macro
      else if(rgWaferLocation->ItemIndex == LOCATION_LP2) {
         no = 780;
         offsetstr.sprintf(" ( 0 0 %d 0)",(waferno-1)*10);
         name = "Cassette2";
      }
      else if(rgWaferLocation->ItemIndex == LOCATION_MACRO) {
         no = 510;
         name = "Macro";
         // 到Robot位置 & 開內環真空
         btnMacroRobotPositionClick(this);
         if(pnlMacroRobotPosition->Color != clLime) {
            pnlRobotMessage->Caption = "Macro(Put): Robot位置異常!";
            pnlRobotPut->Color = clRed;
            WriteSystemLog(pnlRobotMessage->Caption);
            pnlAlarmMessage->Caption = pnlRobotMessage->Caption;
            return;
         }
         // 開內關外
         cbBit1->Checked = true;
         cbBit2->Checked = false;
         WriteDO(IO1_ID);
         // 2022 8 15 - chc 改成200
         WaitTime(200);
      }

      // 2020 4 23 - chc LoadPort, pnlTray1
      // 2022 7 27 - chc 加入LP2/Macro
      //if(rgWaferLocation->ItemIndex == LOCATION_LP1)
      if(rgWaferLocation->ItemIndex == LOCATION_LP1 || rgWaferLocation->ItemIndex == LOCATION_LP2) {
         msg.sprintf("GP %d%s",no,offsetstr);
         if(rgWaferLocation->ItemIndex == LOCATION_LP2)
            panel = (TPanel*)(FindComponent("pnlTray2_" + IntToStr(waferno)));
         else

            panel = (TPanel*)(FindComponent("pnlTray" + IntToStr(waferno)));
         panela = (TPanel*)(frmRecipe->FindComponent("pnlTray" + IntToStr(waferno)));
      }
      else

         msg.sprintf("GP %d",no);

   }

   edRobotCmd->Text = msg;

   // ==> 1
   // 2020 4 23 - chc Log
   WriteSystemLog("Robot放片1: " + msg);

   // 2020 4 23 - chc LoadPort
   if(cbPause->Checked == true) {
      if(Application->MessageBox(("Robot-1準備由" + name + "放第" + IntToStr(waferno) + "片(MTP)? " + msg).c_str(), "退片作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         pnlRobotPut->Color = clRed;
         return;
      }
   }

   // 2020 4 27 - chc 要先設定狀態
   RobotCmdState = ROBOT_CMD_STATE_NONE;

   // 2020 5 6 - chc Log
   WriteSystemLog("RobotCmdState-6 = ROBOT_CMD_STATE_NONE");

   // 2022 12 20 - chc Tazmo
   if(frnMain->RobotMode == ROBOT_MODE_TAZMO)
      RobotCmd = ROBOT_CMD_MTP;
   else

      RobotCmd = ROBOT_CMD_GP;

   // 2020 5 6 - chc Log
   WriteSystemLog("RobotCmd-5 = ROBOT_CMD_GP");

   // 2020 4 27 - chc Robot是否已動作?
   boolRobot4401 = false;

   btnRobotCMDClick(this);

   // 2022 12 23 - chc Tazmo
   if(frnMain->RobotMode == ROBOT_MODE_TAZMO)
      ret = WaitTMRobotDone(30000);
   else

      ret = WaitRobotDone(10000);
   if(ret == false) {
      pnlRobotMessage->Caption = IntToStr(no) + ": Timeout!";
      pnlRobotPut->Color = clRed;
      return;
   }

   // 2022 12 20 - chc Tazmo
   if(frnMain->RobotMode == ROBOT_MODE_TAZMO) {
      ChangeWaferPosition(rgWaferLocation->ItemIndex,WAFER_PUT,2);
      // Vacuum On
      if(rgWaferLocation->ItemIndex == LOCATION_MACRO) {
         WriteSystemLog("RobotCmd-12 = 內外環真空On...");
         MacroVacuum(true);
         WriteDO(IO1_ID);
         WriteSystemLog("RobotCmd-12 = 內外環真空On.");
      }
      // 開真空
      else if(rgWaferLocation->ItemIndex == LOCATION_CHUCK) {
         WriteSystemLog("RobotCmd-12 = Chuck真空開...");
         // Chuck放真空
         ChuckVacuum(true);
         WriteSystemLog("RobotCmd-12 = Chuck真空開.");
      }
      // 點位,Slot,Arm
      msg.sprintf("PUT,%d,%d,%d",no,waferno,WafeFromFOUP);
      edRobotCmd->Text = msg;
      WriteSystemLog("Robotz放片1a: " + msg);
      if(cbPause->Checked == true) {
         if(Application->MessageBox(("Robot-1準備由" + name + "放第" + IntToStr(waferno) + "片(PUT)? " + msg).c_str(), "取片作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
            pnlRobotGet->Color = clRed;
            return;
         }
      }
      // 要先設定狀態
      RobotCmdState = ROBOT_CMD_STATE_NONE;
      WriteSystemLog("RobotCmdState-10 = ROBOT_CMD_STATE_NONE");
      RobotCmd = ROBOT_CMD_PUT;
      WriteSystemLog("RobotCmd-10 = ROBOT_CMD_PUT");
      btnRobotCMDClick(this);
      ret = WaitTMRobotDone(10000);
      if(ret == false) {
         pnlRobotMessage->Caption = IntToStr(no) + ": Timeout!";
         pnlRobotGet->Color = clRed;
         return;
      }
   }
   else {

      no++;

      // 2022 8 24 - chc 移到前面: 切換速度會破壞 edRobotCmd->Text
      if(cbPause->Checked == true) {
         if(Application->MessageBox(("Robot-2準備由" + name + "放第" + IntToStr(waferno) + "片? " + msg).c_str(), "退片作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
            pnlRobotPut->Color = clRed;
            return;
         }
      }

      // 2022 8 23 - chc 切換Scan Speed
      int robotspeed,scanspeed;
      if(rgWaferLocation->ItemIndex == LOCATION_CHUCK) {
         if(cbChuckScan->Checked == true) {

            // 2022 8 26 - chc Send Move to YuanLi
            WriteSystemLog("Put: YuanLi Move");
            pnlOperationMessage->Caption = "YuanLi Move...";
            pnlSystemMessage->Caption = "Put: YuanLi Move...";
            if(WaitYuanliCmd(CMD_MOVE) != CMD_ACK_E) {
               pnlOperationMessage->Caption = "YuanLi Move通訊失敗!";
               //pnlAlarmMessage->Caption = "YuanLi Move異常, 停止執行.";
               //pnlSystemMessage->Caption = "";
               //return;
            }
            else
               pnlOperationMessage->Caption = "YuanLi Move OK.";

            robotspeed = edRobotABSpeed->Text.ToInt();
            scanspeed = edRobotABScanSpeed->Text.ToInt();
            if(scanspeed < 1)
               scanspeed = 1;
            if(scanspeed > 100)
               scanspeed = 100;
            edRobotABScanSpeed->Text = IntToStr(scanspeed);
            WriteSystemLog("切換Robot速度: " + edRobotABSpeed->Text + " To " + edRobotABScanSpeed->Text);
            edRobotABSpeed->Text = edRobotABScanSpeed->Text;
            btnRobotSpeedClick(this);
            WaitTime(200);
         }
      }

      // 點位
      // LoadPort
      // 2022 7 27 - chc 加入LP2/Macro
      //if(rgWaferLocation->ItemIndex == LOCATION_LP1)
      if(rgWaferLocation->ItemIndex == LOCATION_LP1 || rgWaferLocation->ItemIndex == LOCATION_LP2)
         msg.sprintf("GP %d%s",no,offsetstr);
      else

         msg.sprintf("GP %d",no);
      edRobotCmd->Text = msg;

      // ==> 2
      // 2020 4 23 - chc Log
      WriteSystemLog("Robot放片2: " + msg);

      // 2020 4 23 - chc LoadPort
      // 2022 8 24 - chc 移到前面: 切換速度會破壞 edRobotCmd->Text
      //if(cbPause->Checked == true) {
      //   if(Application->MessageBox(("Robot-2準備由" + name + "放第" + IntToStr(waferno) + "片? " + msg).c_str(), "退片作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
      //      pnlRobotPut->Color = clRed;
      //      return;
      //   }
      //}
      //
      //// 2022 8 23 - chc 切換Scan Speed
      //int robotspeed,scanspeed;
      //if(rgWaferLocation->ItemIndex == LOCATION_CHUCK) {
      //   if(cbChuckScan->Checked == true) {
      //      robotspeed = edRobotABSpeed->Text.ToInt();
      //      scanspeed = edRobotABScanSpeed->Text.ToInt();
      //      if(scanspeed < 1)
      //         scanspeed = 1;
      //      if(scanspeed > 100)
      //         scanspeed = 100;
      //      edRobotABScanSpeed->Text = IntToStr(scanspeed);
      //      WriteSystemLog("切換Robot速度: " + edRobotABSpeed->Text + " To " + edRobotABScanSpeed->Text);
      //      edRobotABSpeed->Text = edRobotABScanSpeed->Text;
      //      btnRobotSpeedClick(this);
      //      WaitTime(200);
      //   }
      //}

      ChangeWaferPosition(rgWaferLocation->ItemIndex,WAFER_PUT,2);

      // 2020 4 27 - chc 要先設定狀態
      RobotCmdState = ROBOT_CMD_STATE_NONE;

      // 2020 5 6 - chc Log
      WriteSystemLog("RobotCmdState-7 = ROBOT_CMD_STATE_NONE");

      RobotCmd = ROBOT_CMD_GP;

      // 2020 5 6 - chc Log
      WriteSystemLog("RobotCmd-6 = ROBOT_CMD_GP");

      // 2020 4 27 - chc Robot是否已動作?
      boolRobot4401 = false;

      btnRobotCMDClick(this);
      ret = WaitRobotDone(10000);
      if(ret == false) {
         pnlRobotMessage->Caption = IntToStr(no) + ": Timeout!";
         pnlRobotPut->Color = clRed;

         // 2022 8 23 - chc 切換Scan Speed
         if(rgWaferLocation->ItemIndex == LOCATION_CHUCK) {
            if(cbChuckScan->Checked == true) {
               WriteSystemLog("切換Robot速度: " + edRobotABSpeed->Text + " To " + IntToStr(robotspeed));
               edRobotABSpeed->Text = IntToStr(robotspeed);
               btnRobotSpeedClick(this);
               WaitTime(200);
            }
         }

         return;
      }

      // 放真空
      RobotCmd = ROBOT_CMD_VACUUM;

      // 2020 5 6 - chc Log
      WriteSystemLog("RobotCmd-7 = ROBOT_CMD_VACUUM");

      btnRobotVacuumOffClick(this);
      ret = WaitRobotDone(10000);
      if(ret == false) {
         pnlRobotMessage->Caption = "Vacuum Off: Timeout!";
         pnlRobotPut->Color = clRed;

         // 2022 8 23 - chc 切換Scan Speed
         if(rgWaferLocation->ItemIndex == LOCATION_CHUCK) {
            if(cbChuckScan->Checked == true) {
               WriteSystemLog("切換Robot速度: " + edRobotABSpeed->Text + " To " + IntToStr(robotspeed));
               edRobotABSpeed->Text = IntToStr(robotspeed);
               btnRobotSpeedClick(this);
               WaitTime(200);
            }
         }

         return;
      }

      // 2022 8 23 - chc 切換Scan Speed
      if(rgWaferLocation->ItemIndex == LOCATION_CHUCK) {
         if(cbChuckScan->Checked == true) {
            WriteSystemLog("切換Robot速度: " + edRobotABSpeed->Text + " To " + IntToStr(robotspeed));
            edRobotABSpeed->Text = IntToStr(robotspeed);
            btnRobotSpeedClick(this);
            WaitTime(200);
         }
      }

      no++;

      // LoadPort
      // 2022 7 27 - chc 加入LP2/Macro
      //if(rgWaferLocation->ItemIndex == LOCATION_LP1)
      if(rgWaferLocation->ItemIndex == LOCATION_LP1 || rgWaferLocation->ItemIndex == LOCATION_LP2)
         msg.sprintf("GP %d%s",no,offsetstr);
      else

         msg.sprintf("GP %d",no);
      edRobotCmd->Text = msg;

      // ==> 3
      // 2020 4 23 - chc Log
      WriteSystemLog("Robot放片3: " + msg);

      // 2020 4 23 - chc LoadPort
      if(cbPause->Checked == true) {
         if(Application->MessageBox(("Robot-3準備由" + name + "放第" + IntToStr(waferno) + "片? " + msg).c_str(), "退片作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
            pnlRobotPut->Color = clRed;
            return;
         }
      }

      // 2020 4 27 - chc 要先設定狀態
      RobotCmdState = ROBOT_CMD_STATE_NONE;

      // 2020 5 6 - chc Log
      WriteSystemLog("RobotCmdState-8 = ROBOT_CMD_STATE_NONE");

      RobotCmd = ROBOT_CMD_GP;

      // 2020 5 6 - chc Log
      WriteSystemLog("RobotCmd-8 = ROBOT_CMD_GP");

      // 2020 4 27 - chc Robot是否已動作?
      boolRobot4401 = false;

      btnRobotCMDClick(this);
      ret = WaitRobotDone(10000);
      if(ret == false) {
         pnlRobotMessage->Caption = IntToStr(no) + ": Timeout!";
         pnlRobotPut->Color = clRed;
         return;
      }
   }

   pnlWaferRobotInformation->Color = (TColor)0x0068C6AA;
   pnlWaferRobotInformation->Caption = "";
   if(rgWaferLocation->ItemIndex == LOCATION_ALIGNER1) {
      pnlWaferAlignerInformation->Color = clLime;
      stageno = STAGE_ALIGNER;
      pnlstage = pnlWaferAlignerInformation;
   }
   else if(rgWaferLocation->ItemIndex == LOCATION_LP1) {
      panel->Color = clLime;
      panela->Color = clLime;
   }
   else if(rgWaferLocation->ItemIndex == LOCATION_LP2) {
      panel->Color = clLime;
      panela->Color = clLime;
   }
   else if(rgWaferLocation->ItemIndex == LOCATION_CHUCK) {
      pnlWaferChuckInformation->Color = clLime;
      stageno = STAGE_CHUCK;
      pnlstage = pnlWaferChuckInformation;
   }
   else if(rgWaferLocation->ItemIndex == LOCATION_MACRO) {
      pnlWaferMacroInformation->Color = clLime;
      stageno = STAGE_MACRO;
      pnlstage = pnlWaferMacroInformation;
   }

   // 2022 12 20 - chc Tazmo
   else if(frnMain->RobotMode == ROBOT_MODE_TAZMO) {
      if(rgWaferLocation->ItemIndex == LOCATION_ALIGNER2) {
         pnlWaferAlignerInformation->Color = clLime;
         stageno = STAGE_ALIGNER;
         pnlstage = pnlWaferAlignerInformation;
      }
   }

   // 2022 8 23 - chc LP1/LP2不用轉換
   if(rgWaferLocation->ItemIndex != LOCATION_LP1 && rgWaferLocation->ItemIndex != LOCATION_LP2) {
      StageInformation[stageno].boolWithWafer = true;
      StageInformation[STAGE_ROBOT].boolWithWafer = false;
      StageInformation[stageno].WaferID = StageInformation[STAGE_ROBOT].WaferID;
      StageInformation[stageno].SlotNo = StageInformation[STAGE_ROBOT].SlotNo;
      StageInformation[stageno].FoupNo = StageInformation[STAGE_ROBOT].FoupNo;
      pnlstage->Caption = IntToStr(StageInformation[stageno].FoupNo) + "," + IntToStr(StageInformation[stageno].SlotNo) + " " + StageInformation[stageno].WaferID;
   }

   // 2022 12 20 - chc Tazmo
   if(frnMain->RobotMode != ROBOT_MODE_TAZMO) {

      no++;

      // LoadPort
      // 2022 7 27 - chc 加入LP2/Macro
      //if(rgWaferLocation->ItemIndex == LOCATION_LP1)
      if(rgWaferLocation->ItemIndex == LOCATION_LP1 || rgWaferLocation->ItemIndex == LOCATION_LP2)
         msg.sprintf("GP %d%s",no,offsetstr);
      else

         msg.sprintf("GP %d",no);
      edRobotCmd->Text = msg;

      // ==> 4
      // 2020 4 23 - chc Log
      WriteSystemLog("Robot放片4: " + msg);

      // 2020 4 23 - chc LoadPort
      if(cbPause->Checked == true) {
         if(Application->MessageBox(("Robot-4準備由" + name + "放第" + IntToStr(waferno) + "片? " + msg).c_str(), "退片作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
            pnlRobotPut->Color = clRed;
            return;
         }
      }

      // 2020 4 27 - chc 要先設定狀態
      RobotCmdState = ROBOT_CMD_STATE_NONE;

      // 2020 5 6 - chc Log
      WriteSystemLog("RobotCmdState-9 = ROBOT_CMD_STATE_NONE");

      RobotCmd = ROBOT_CMD_GP;

      // 2020 5 6 - chc Log
      WriteSystemLog("RobotCmd-9 = ROBOT_CMD_GP");

      // 2020 4 27 - chc Robot是否已動作?
      boolRobot4401 = false;

      btnRobotCMDClick(this);
      ret = WaitRobotDone(10000);
      if(ret == false) {
         pnlRobotMessage->Caption = IntToStr(no) + ": Timeout!";
         pnlRobotPut->Color = clRed;
         return;
      }
   }

   ChangeWaferPosition(rgWaferLocation->ItemIndex,WAFER_PUT,4);

   pnlRobotMessage->Caption = "PUT: Succ.";
   pnlRobotPut->Color = clLime;
}
//---------------------------------------------------------------------------
// SOD0 1 - Vacuum On
void __fastcall TfrnMain::btnRobotVacuumOnClick(TObject *Sender)
{

   // 2022 12 22 - chc Chuck Wafer? Tazmo
   if(RobotMode == ROBOT_MODE_TAZMO) {
      if(rgCST->ItemIndex == LOADPORT_1)
         edRobotCmd->Text = "HLD,1";
      else
         edRobotCmd->Text = "HLD,2";
      // 要Refresh
      edRobotCmd->Refresh();
      btnRobotCMDClick(this);
      int ret = WaitTMRobotDone(5000);
   }
   else {

      edRobotCmd->Text = "SOD0 1";
      btnRobotCMDClick(this);
   }
}
//---------------------------------------------------------------------------
// SOD0 2 - Vacuum Off
void __fastcall TfrnMain::btnRobotVacuumOffClick(TObject *Sender)
{

   // 2022 12 22 - chc Chuck Wafer? Tazmo
   if(RobotMode == ROBOT_MODE_TAZMO) {
      if(rgCST->ItemIndex == LOADPORT_1)
         edRobotCmd->Text = "REL,1";
      else
         edRobotCmd->Text = "REL,2";
      // 要Refresh
      edRobotCmd->Refresh();
      btnRobotCMDClick(this);
      int ret = WaitTMRobotDone(5000);
   }
   else {

      edRobotCmd->Text = "SOD0 2";
      btnRobotCMDClick(this);
   }
}
//---------------------------------------------------------------------------
// 是否有片? LID0: 0-有片, 1-無片
// Ret: 001 0/1
void __fastcall TfrnMain::btnRobotWithWaferClick(TObject *Sender)
{
int timeout = 100;
int cnt = 0;

   RobotWithWafer = ROBOT_WAFER_UNKOWN;

   // 2022 9 22 - chc 改成白色
   //pnlRobotWithWafer->Color = clSilver;
   pnlRobotWithWafer->Color = clWhite;

   // 2022 12 22 - chc Chuck Wafer? Tazmo
   if(RobotMode == ROBOT_MODE_TAZMO) {

      if(rgCST->ItemIndex == LOADPORT_1)
         edRobotCmd->Text = "WCH,1";
      else
         edRobotCmd->Text = "WCH,2";
      // 要Refresh
      edRobotCmd->Refresh();
      btnRobotCMDClick(this);
      // 等待完成 10000ms: pnlRobotWithWafer->Color
      while(1) {
         if(RobotWithWafer != ROBOT_WAFER_UNKOWN)
            break;
         Sleep(100);
         Application->ProcessMessages();
         cnt++;
         if(cnt > timeout) {
            pnlRobotWithWafer->Color = clRed;
            pnlRobotMessage->Caption = "btnRobotWithWaferClick: Timeout!";
            WriteSystemLog(pnlRobotMessage->Caption);
            return;
         }
      }
      return;
   }

   edRobotCmd->Text = "LID0";
   btnRobotCMDClick(this);

   // 2022 9 22 - chc 等待完成 2000ms: pnlRobotWithWafer->Color
   timeout = 20;
   cnt = 0;
   while(1) {
      if(RobotWithWafer != ROBOT_WAFER_UNKOWN)
         break;
      Sleep(100);
      Application->ProcessMessages();
      cnt++;
      if(cnt > timeout) {
         pnlRobotWithWafer->Color = clRed;
         pnlRobotMessage->Caption = "btnRobotWithWaferClick: Timeout!";
         WriteSystemLog(pnlRobotMessage->Caption);
         return;
      }
   }

}
//---------------------------------------------------------------------------
// 2022 7 10  - chc Robot Clear Alarm
// 回0601
void __fastcall TfrnMain::btnRobotClearAlarmClick(TObject *Sender)
{

   edRobotCmd->Text = "CL";
   btnRobotCMDClick(this);

   // 紅燈 => TSMC修改: 不關紅燈, 要清MotionError狀態
   //RedLamp(false);

   // TSMC修改: 清Robot狀態
   RobotCmd = ROBOT_CMD_NONE;
   boolEFEMError = false;
}
//---------------------------------------------------------------------------
// 2022 7 10  - chc Robot Enable
// GD後GE會看先到0621, 要再下LS才會看到0601
void __fastcall TfrnMain::btnRobotEanbleClick(TObject *Sender)
{

   edRobotCmd->Text = "GE";
   btnRobotCMDClick(this);
}
//---------------------------------------------------------------------------
// 2022 7 10  - chc Robot Disable
// 回0601
void __fastcall TfrnMain::btnRobotDisableClick(TObject *Sender)
{

   edRobotCmd->Text = "GD";
   btnRobotCMDClick(this);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnLoadPortConnectClick(TObject *Sender)
{

   try {
      ybLoadPort->SettingsDialog(this,true);
      if(boolLoadPortStatus == false)
         ybLoadPort->Active = true;
      boolLoadPortStatus = true;
      LoadPortButton(1);
   }
   catch(Exception &e) {
      ShowMessage("ybLoadPort: " + e.Message);
      boolLoadPortStatus = false;
      LoadPortButton(0);
      pnlSystemMessage->Caption = "COM Port(LoadPort) 啟動失敗!";
      WriteSystemLog(pnlSystemMessage->Caption);
   }
   UpdateLoadPortStatus();
}
//---------------------------------------------------------------------------
// MOV:FPML;
// Load And Mapping(開門, 進入, Mapping) 11sec
void __fastcall TfrnMain::btnLoadPortLoadClick(TObject *Sender)
{

   // 先做Robot ORGN(GP1/GP0) & 偵測pnlLoadPortS12是否為1?
   if(BeforeLoadPortLoadUnload() == false) {
      return;
   }

   edLoadPortCmd->Text = "MOV:FPML;";
   btnLoadPortCMDClick(this);
}
//---------------------------------------------------------------------------
// Load/UnLoad LoadPort
// 2022 7 10 - chc Get LED
// GET:LEST/abcdefgh(0-Off, 1-On, 2-blink)
// Presence, Placement, Load, UnLoad, Operator Access1, Status1, Status2, Operator Access2     <KWF-12F, Alarm, Power>
void __fastcall TfrnMain::btnLoadPortLEDClick(TObject *Sender)
{

   edLoadPortCmd->Text = "GET:LEST;";
   btnLoadPortCMDClick(this);
}
//---------------------------------------------------------------------------
// 2022 7 10 - chc Load Port Mapping
void __fastcall TfrnMain::btnLoadPortMappingClick(TObject *Sender)
{

   // 先做Robot ORGN(GP1/GP0) & 偵測pnlLoadPortS12是否為1?
   if(BeforeLoadPortLoadUnload() == false) {
      return;
   }

   edLoadPortCmd->Text = "MOV:MAPP;";                                           // Mapping
   btnLoadPortCMDClick(this);
}
//---------------------------------------------------------------------------
// 2022 7 10 - chc Reset Error
void __fastcall TfrnMain::btnLoadPortResetClick(TObject *Sender)
{

   pnlLoadPortReset->Color = clSilver;
   edLoadPortCmd->Text = "SET:RSET;";
   btnLoadPortCMDClick(this);

   // TSMC修改: 不關紅燈
   //RedLamp(false);
   boolEFEMError = false;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnAlignerConnectClick(TObject *Sender)
{

   try {
      ybAligner->SettingsDialog(this,true);
      if(boolAlignerStatus == false)
         ybAligner->Active = true;
      boolAlignerStatus = true;
      AlignerButton();
   }
   catch(Exception &e) {
      ShowMessage("ybAligner: " + e.Message);
      boolAlignerStatus = false;
      AlignerButton();
      pnlSystemMessage->Caption = "COM Port(Aligner) 啟動失敗!";
      WriteSystemLog(pnlSystemMessage->Caption);
   }
   UpdateAlignerStatus();
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnAlignerVacuumOffClick(TObject *Sender)
{

   pnlAlignerVacuumOff->Color = clSilver;
   edAlignerCmd->Text = "MOV:ACOP;";
   btnAlignerCMDClick(this);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnAlignerAlignmentClick(TObject *Sender)
{

   // 2022 12 19 - chc Tazmo
   if(RobotMode == ROBOT_MODE_TAZMO) {
bool ret;

      pnlAlignerAlignment->Color = clSilver;
      int degree = edAlignerDegree->Text.ToInt();
      degree /= 450;
      degree++;
      if(degree > 8)
         degree = 8;
      edAlignerCmd->Text = "ALG," + IntToStr(degree);
      // 要Refresh
      edAlignerCmd->Refresh();
      btnAlignerCMDClick(this);
      ret = WaitTMAlignerDone(30000);
      if(ret == true)
         pnlAlignerAlignment->Color = clLime;
      else
         pnlAlignerAlignment->Color = clRed;
      return;
   }

   // 選擇角度: AlignmentDegreeMode
   int degree;
   if(AlignmentDegreeMode == ALIGNMENT_DEGREE_UNLOAD) {
      // 備份角度值
      degree = edAlignerDegree->Text.ToInt();
      edAlignerDegree->Text = edAlignerDegreeOut->Text;
   }

   // 先做角度設定
   rgAlignerSet->ItemIndex = 1;
   AlignerOFSEState = 0;
   btnAlignerSetClick(this);

   // 還原角度值
   if(AlignmentDegreeMode == ALIGNMENT_DEGREE_UNLOAD) {
      edAlignerDegree->Text = IntToStr(degree);
   }

   int cnt = 0;
   int max = 20;
   while(1) {
      if(AlignerOFSEState == 1) {
         break;
      }
      else if(AlignerOFSEState == 2) {
         pnlAlignerAlignment->Color = clRed;
         pnlAlignerMessage->Caption = "角度設定失敗!";
         return;
      }
      cnt++;
      if(cnt > max) {
         pnlAlignerMessage->Caption = "角度設定Timeout!";
         return;
      }
      WaitTime(100);
   }

   pnlAlignerAlignment->Color = clSilver;
   edAlignerCmd->Text = "MOV:ARLD;";
   btnAlignerCMDClick(this);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnAlignerWithWaferClick(TObject *Sender)
{
int ret;

   // 2022 12 19 - chc Tazmo
   if(RobotMode == ROBOT_MODE_TAZMO) {
      pnlAlignerWithWafer->Color = clSilver;
      edAlignerCmd->Text = "WCH";
      // 要Refresh
      edAlignerCmd->Refresh();
      btnAlignerCMDClick(this);
      ret = WaitTMAlignerDone(30000);
      if(ret == false) {
         pnlAlignerWithWafer->Color = clRed;
         return;
      }
      WaitTime(1000);

      /*
      WaitTime(1000);
      edAlignerCmd->Text = "PRP,A";
      // 要Refresh
      edAlignerCmd->Refresh();
      btnAlignerCMDClick(this);
      ret = WaitTMAlignerDone(30000);
      if(ret == false) {
         pnlAlignerWithWafer->Color = clRed;
      }
      */

      return;
   }

   edAlignerCmd->Text = "GET:STAS;";
   btnAlignerCMDClick(this);
}
//---------------------------------------------------------------------------
// 2022 7 10 - chc SET
void __fastcall TfrnMain::btnAlignerSetClick(TObject *Sender)
{
char command[100];

   // RSET: Error reset
   if(rgAlignerSet->ItemIndex == 0)
      sprintf(command,"SET:RSET;");
   // OFSE: 1/10度, 0000~3600
   else if(rgAlignerSet->ItemIndex == 1)
      sprintf(command,"SET:OFSE%04d;",edAlignerDegree->Text.ToInt());
   // OFS2: 1/10度, 0000~3600
   else if(rgAlignerSet->ItemIndex == 2)
      sprintf(command,"SET:OFS2%04d;",edAlignerDegree->Text.ToInt());
   // SPED: 0000~0100(100%)
   else if(rgAlignerSet->ItemIndex == 3)
      sprintf(command,"SET:SPED%04d;",edAlignerSpeed->Text.ToInt());
   // TYPE: 00~06
   //   00 （06-orientation flat * standard setting)
   //   01 (08-orientation flat * standard setting)
   //   02 (* For enhancement)
   //   03（06-notch * standard setting)
   //   04 (08-notch * standard setting)
   //   05 (12-notch * standard setting)
   //   06 (18-notch * stnadrad setting)
   else if(rgAlignerSet->ItemIndex == 4)
      sprintf(command,"SET:TYPE%02d;",edAlignerType->Text.ToInt());

   edAlignerCmd->Text = command;
   btnAlignerCMDClick(this);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnAlignerGetClick(TObject *Sender)
{
char command[100];

   // STAS
   if(rgAlignerSet->ItemIndex == 0)
      sprintf(command,"GET:STAS;");
   // OFSE
   else if(rgAlignerSet->ItemIndex == 1)
      sprintf(command,"GET:OFSE;");
   // OFS2
   else if(rgAlignerSet->ItemIndex == 2)
      sprintf(command,"GET:OFS2;");
   // SPED
   else if(rgAlignerSet->ItemIndex == 3)
      sprintf(command,"GET:SPED;");
   // TYPE
   else if(rgAlignerSet->ItemIndex == 4)
      sprintf(command,"GET:TYPE;");

   edAlignerCmd->Text = command;
   btnAlignerCMDClick(this);
}
//---------------------------------------------------------------------------
// SET:RSET;
void __fastcall TfrnMain::btnAlignerResetClick(TObject *Sender)
{

   // 2022 12 19 - chc Tazmo
   if(RobotMode == ROBOT_MODE_TAZMO) {
bool ret;

      pnlAlignerReset->Color = clSilver;
      pnlAlignerORGN->Color = clSilver;
      edAlignerCmd->Text = "RST";
      // 要Refresh
      edAlignerCmd->Refresh();
      btnAlignerCMDClick(this);
      ret = WaitTMAlignerDone(60000);
      if(ret == true) {
         pnlAlignerReset->Color = clLime;
         pnlAlignerORGN->Color = clLime;
      }
      else {
         pnlAlignerReset->Color = clRed;
         pnlAlignerORGN->Color = clRed;
      }
      return;
   }
   
   pnlAlignerReset->Color = clSilver;
   edAlignerCmd->Text = "SET:RSET;";
   btnAlignerCMDClick(this);

   // TSMC修改: 不關紅燈
   //RedLamp(false);
   boolEFEMError = false;
}
//---------------------------------------------------------------------------
// 2022 7 10 - chc Save Aligner Parameters
void __fastcall TfrnMain::btnAlignerSaveClick(TObject *Sender)
{
TIniFile *pSystemFile;
AnsiString str;

   pnlSystemMessage->Caption = "Aligner參數更新中...";
   pnlAlignerMessage->Caption = pnlSystemMessage->Caption;
   // ini檔名與目錄
   pSystemFile = new TIniFile(SystemINIFilename);

   // Aligner
   AlignerDegree = edAlignerDegree->Text.ToInt();
   pSystemFile->WriteInteger("Aligner Parameter" ,"Degree"                      ,AlignerDegree);
   AlignerSpeed = edAlignerSpeed->Text.ToInt();
   pSystemFile->WriteInteger("Aligner Parameter" ,"Speed"                       ,AlignerSpeed);
   AlignerType = edAlignerType->Text.ToInt();
   pSystemFile->WriteInteger("Aligner Parameter" ,"Type"                        ,AlignerType);

   // AlignerOut
   AlignerDegreeOut = edAlignerDegreeOut->Text.ToInt();
   pSystemFile->WriteInteger("Aligner Parameter" ,"Degree Out"                  ,AlignerDegreeOut);

   delete pSystemFile;
   pnlSystemMessage->Caption = "Aligner參數更新完成.";
   pnlAlignerMessage->Caption = pnlSystemMessage->Caption;

}
//---------------------------------------------------------------------------
// 2022 7 10 - chc Init LoadPort2 ComPort
// COM3
void __fastcall TfrnMain::InitLoadPort2Com()
{

   // 由參數決定COM Port
   pnlSystemMessage->Caption = "啟動LoadPort2 Com Port...";
   try {
      pnlLoadPort2Status->Color = clSilver;
      ybLoadPort2->Active = false;
      Sleep(200);
      if(combLoadPort2Baudrate->Text == "115200")
         ybLoadPort2->Baud = ybLoadPort2->br115200;
      else if(combLoadPort2Baudrate->Text == "57600")
         ybLoadPort2->Baud = ybLoadPort2->br57600;
      else if(combLoadPort2Baudrate->Text == "38400")
         ybLoadPort2->Baud = ybLoadPort2->br38400;
      else if(combLoadPort2Baudrate->Text == "19200")
         ybLoadPort2->Baud = ybLoadPort2->br19200;
      else if(combLoadPort2Baudrate->Text == "9600")
         ybLoadPort2->Baud = ybLoadPort2->br9600;
      // 由參數決定COM Port
      ybLoadPort2->PortNo = combLoadPort2Comport->ItemIndex+1;

      // Parity, DataBit, StopBit
      //ybLoadPort2->Parity = ybLoadPort2->ptNoParity;
      //ybLoadPort2->ByteSize = 8;
      //ybLoadPort2->StopBits = ybLoadPort2->sbOneStopBit;

      // Parity
      //if(cbNoParity->Checked == true)
      //   ybLoadPort2->Parity = ybLoadPort2->ptNoParity;
      //else
      //   ybLoadPort2->Parity = ybLoadPort2->ptEvenParity;

      ybLoadPort2->Active = true;
      pnlLoadPort2Status->Color = clLime;
      boolLoadPort2Status = true;
      LoadPort2Button(0);
   }
   catch(Exception &e) {
      pnlSystemMessage->Caption = "ybLoadPort2: " + e.Message;
      sbSystem->Panels->Items[1]->Text = "ybLoadPort2: " + e.Message;
      pnlLoadPort2Status->Color = clRed;
      boolLoadPort2Status = false;
      LoadPort2Button(0);
   }
   UpdateLoadPort2Status();
   pnlSystemMessage->Caption = "啟動LoadPort2 Com Port.";

}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::combLoadPort2ComportChange(TObject *Sender)
{

   InitLoadPort2Com();
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::combLoadPort2BaudrateChange(TObject *Sender)
{

   InitLoadPort2Com();
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnLoadPort2ConnectClick(TObject *Sender)
{

   try {
      ybLoadPort2->SettingsDialog(this,true);
      if(boolLoadPort2Status == false)
         ybLoadPort2->Active = true;
      boolLoadPort2Status = true;
      LoadPort2Button(1);
   }
   catch(Exception &e) {
      ShowMessage("ybLoadPort2: " + e.Message);
      boolLoadPort2Status = false;
      LoadPort2Button(0);
      pnlSystemMessage->Caption = "COM Port(LoadPort2) 啟動失敗!";
      WriteSystemLog(pnlSystemMessage->Caption);
   }
   UpdateLoadPort2Status();
}
//---------------------------------------------------------------------------
// boolLoadPort2Status = false;
void __fastcall TfrnMain::LoadPort2Button(int mode)
{

   btnLoadPort2CMD->Enabled = boolLoadPort2Status;
   btnLoadPort2Load->Enabled = boolLoadPort2Status;
   btnLoadPort2UnLoad->Enabled = boolLoadPort2Status;
   btnLoadPort2LED->Enabled = boolLoadPort2Status;
   btnLoadPort2Map->Enabled = boolLoadPort2Status;
   btnLoadPort2Stas->Enabled = boolLoadPort2Status;
   btnLoadPort2Mapping->Enabled = boolLoadPort2Status;
   btnLoadPort2Reset->Enabled = boolLoadPort2Status;

   if(mode == 1 || boolLoadPort2Status == false)
      btnCassette2Load->Enabled = boolLoadPort2Status;
}
//---------------------------------------------------------------------------
// 2022 7 10 - chc LoadPort2 Active
void __fastcall TfrnMain::UpdateLoadPort2Status()
{

   if(boolLoadPort2Status == true) {
      pnlLoadPort2Status->Color = clLime;
      pnlLoadPort2Ready->Color = clLime;
   }
   else {
      pnlLoadPort2Status->Color = clRed;
      pnlLoadPort2Ready->Color = clRed;
   }
}
//---------------------------------------------------------------------------
// 2022 7 10 - chc LoadPort
// GET:MAPR;
// 0000GET:MDAT/0000000000000000000000000;1A*( bottem to top)
void __fastcall TfrnMain::btnLoadPort2CMDClick(TObject *Sender)
{
unsigned char command[50],buf[50];
AnsiString msg;
int len,cs1,cs2;
unsigned char checksum;

   if(boolLoadPort2Status == false) {
      pnlLoadPort2Message->Caption = "未連線!";
      return;
   }

   sprintf(command,"0000%s",edLoadPort2Cmd->Text);
   len = strlen(command);
   checksum = 0;
   for(int i=0 ; i<len ; i++) {
      checksum += command[i];
   }

   // LoadPort2
   int c1,c2;
   c1 = checksum & 0xf0;
   c1 = c1 >> 4;
   c2 = checksum & 0x0f;
   if(c1 < 10)
      c1 = c1 + '0';
   else
      c1 = c1 - 10 + 'A';
   if(c2 < 10)
      c2 = c2 + '0';
   else
      c2 = c2 - 10 + 'A';
   sprintf(buf,"%c%s%c%c%c",0x01,command,c1,c2,0x0d);

   len = strlen(buf);
   buf[len] = 0x0;
   ybLoadPort2->Write(buf,len);
   pnlLoadPort2Operation->Caption = "Busy";
   pnlLoadPort2->Enabled = false;
   btnLoadPort2Enable->Visible = true;

   msg.sprintf("CMD: %s",command);
   pnlSystemMessage->Caption = msg;
   WriteSystemLog(msg);

   // 2020 5 6 - chc 不能有Sleep, 會卡住!
   //Sleep(100);

   AddLoadPort2SendMessage(edLoadPort2Cmd->Text);
   pnlLoadPort2Message->Caption = msg;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnLoadPort2EnableClick(TObject *Sender)
{

   pnlLoadPort2->Enabled = true;
   btnLoadPort2Enable->Visible = false;
}
//---------------------------------------------------------------------------
// LoadPort2 Send
void __fastcall TfrnMain::AddLoadPort2SendMessage(AnsiString msg)
{
AnsiString putmsg;

   //putmsg = Now().FormatString("hh':'nn':'ss'-> '") + msg;
   //mmLoadPort2Msg->Lines->Insert(0,putmsg);
   //if(mmLoadPort2Msg->Lines->Count > 400) {
   //   for(int i=370 ; i<mmLoadPort2Msg->Lines->Count ; i++)
   //      mmLoadPort2Msg->Lines->Delete(i);
   //}

   // 2022 9 6 - chc 固定要清除, 否則速度會變慢!
   if(mmLoadPort2Msg->Lines->Count > 400) {
      for(int i=320 ; i<mmLoadPort2Msg->Lines->Count ; i++)
         mmLoadPort2Msg->Lines->Delete(i);
   }

   //putmsg = ">" + msg;
   //mmLoadPort2Msg->Lines->Insert(0,putmsg);
   putmsg = Now().FormatString("nn':'ss':'zzz' > '") + msg;
   mmLoadPort2Msg->Lines->Insert(0,putmsg);
}
//---------------------------------------------------------------------------
// 2022 7 10 - chc Read Aligner Parameters
void __fastcall TfrnMain::LoadAlignerParameter()
{
TIniFile *pSystemFile;
AnsiString str;

   pnlSystemMessage->Caption = "Aligner參數讀取中...";
   pnlAlignerMessage->Caption = pnlSystemMessage->Caption;
   // ini檔名與目錄
   pSystemFile = new TIniFile(SystemINIFilename);

   // Aligner
   AlignerDegree = pSystemFile->ReadInteger("Aligner Parameter" ,"Degree"       ,900);
   AlignerSpeed = pSystemFile->ReadInteger("Aligner Parameter" ,"Speed"         ,100);
   AlignerType = pSystemFile->ReadInteger("Aligner Parameter" ,"Type"           ,5);
   edAlignerDegree->Text = IntToStr(AlignerDegree);
   edAlignerSpeed->Text = IntToStr(AlignerSpeed);
   edAlignerType->Text = IntToStr(AlignerType);

   // Aligner Out
   AlignerDegreeOut = pSystemFile->ReadInteger("Aligner Parameter" ,"Degree Out"       ,900);
   edAlignerDegreeOut->Text = IntToStr(AlignerDegreeOut);

   delete pSystemFile;
   pnlSystemMessage->Caption = "Aligner參數讀取完成.";
   pnlAlignerMessage->Caption = pnlSystemMessage->Caption;

}
//---------------------------------------------------------------------------
// 2022 7 10 - chc TSMC修改: 改用timer
// Get後做ORG: 800ms
// 2022 8 22 - chc Interval由800ms改成2000ms, 太早做會影響效能
void __fastcall TfrnMain::tmAlignerORGTimer(TObject *Sender)
{
long StartTime,StopTime,Elapsedms;
short StartTick,StopTick;
int timeout = 10000;

   // 2022 8 17 - chc 不用等
   WriteSystemLog("Get Aligner後, 進行AlignerORG...");

   tmAlignerORG->Enabled = false;
   boolAlignerORGN = false;
   btnAlignerORGNClick(this);

   // 2022 8 17 - chc 不用等
   /*
   WriteSystemLog("Wait... Aligner ORGN(Get Timer)");
   GetTimeTic(&StartTime,&StartTick);
   while(1) {
      if(boolAlignerORGN == true && pnlAlignerORGN->Color == clLime)
         break;
      // 2022 8 12 - chc 不用Sleep
      // 恢復
      Sleep(50);
      Application->ProcessMessages();
      GetTimeTic(&StopTime,&StopTick);
      Elapsedms = ((StopTime*1000+StopTick) - (StartTime*1000+StartTick));
      if(Elapsedms > timeout) {
         pnlRobotGet->Color = clRed;
         pnlOperationMessage->Caption = "取片失敗: Aligner取片後歸Home異常!";
         WriteSystemLog(pnlOperationMessage->Caption);
         return;
      }
      WriteSystemLog("[Get]Wait...");
   }
   WriteSystemLog("Done... Aligner ORGN(Get Timer)");
   */
   WriteSystemLog("Get Aligner後, AlignerORG不用等完成");

}
//---------------------------------------------------------------------------
// MOV:FPML;
// Load And Mapping(開門, 進入, Mapping) 11sec
void __fastcall TfrnMain::btnLoadPort2LoadClick(TObject *Sender)
{

   // 先做Robot ORGN(GP1/GP0) & 偵測pnlLoadPortS12是否為1?
   if(BeforeLoadPortLoadUnload() == false) {
      return;
   }

   edLoadPort2Cmd->Text = "MOV:FPML;";
   btnLoadPort2CMDClick(this);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnLoadPort2UnLoadClick(TObject *Sender)
{

   // 先做Robot ORGN(GP1/GP0) & 偵測pnlLoadPortS12是否為1?
   if(BeforeLoadPortLoadUnload() == false) {
      return;
   }

   edLoadPort2Cmd->Text = "MOV:ORGN;";
   btnLoadPort2CMDClick(this);
}
//---------------------------------------------------------------------------
// Load/UnLoad LoadPort
// 2022 7 10 - chc Get LED
// GET:LEST/abcdefgh(0-Off, 1-On, 2-blink)
// Presence, Placement, Load, UnLoad, Operator Access1, Status1, Status2, Operator Access2     <KWF-12F, Alarm, Power>
void __fastcall TfrnMain::btnLoadPort2LEDClick(TObject *Sender)
{

   edLoadPort2Cmd->Text = "GET:LEST;";
   btnLoadPort2CMDClick(this);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnLoadPort2MapClick(TObject *Sender)
{

   edLoadPort2Cmd->Text = "GET:MAPR;";                                           // 1 ~ 25
   btnLoadPort2CMDClick(this);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnLoadPort2StasClick(TObject *Sender)
{

   edLoadPort2Cmd->Text = "GET:STAS;";
   btnLoadPort2CMDClick(this);
}
//---------------------------------------------------------------------------
// 2022 7 10 - chc Load Port2 Mapping
void __fastcall TfrnMain::btnLoadPort2MappingClick(TObject *Sender)
{

   // 先做Robot ORGN(GP1/GP0) & 偵測pnlLoadPortS12是否為1?
   if(BeforeLoadPortLoadUnload() == false) {
      return;
   }

   edLoadPort2Cmd->Text = "MOV:MAPP;";                                           // Mapping
   btnLoadPort2CMDClick(this);
}
//---------------------------------------------------------------------------
// 2022 7 10 - chc Reset Error
void __fastcall TfrnMain::btnLoadPort2ResetClick(TObject *Sender)
{

   pnlLoadPort2Reset->Color = clSilver;
   edLoadPort2Cmd->Text = "SET:RSET;";
   btnLoadPort2CMDClick(this);

   // TSMC修改: 不關紅燈
   //RedLamp(false);
   boolEFEMError = false;
}
//---------------------------------------------------------------------------
// Send: 0000MOV:FPML;
// Recv: 0000MOV:FPML;56*
// Recv: 0000INF:FPML;41* (INF = 完成)
// 結束碼: CR(0x0d)
// 開始碼: 0x01
//
// Loaf port 正常log:
// 2020-03-09 09:01:15.357   P2 : A > D : Load : 0000MOV:FPML;
// 2020-03-09 09:01:15.465   P2 : D > A : ~0000MOV:FPML;56*
// 2020-03-09 09:01:27.352   P2 : D > A : ~0000INF:FPML;41* (INF = 完成)
// Loaf port error log
// 2020-03-09 08:59:53.632   P2 : A > D : Load : 0000MOV:FPML;
// 2020-03-09 08:59:53.739   P2 : D > A : ~0000MOV:FPML;56*
// 2020-03-09 09:00:18.186   P2 : D > A : ~0000ABS:FPML/16;D0* (ABS=有error, 16=error code)

// Mapping
//0000GET:MAPR/0000000000000000000000000;1A*( bottem to top)

AnsiString ReplyStrLoadPort2 = "";
unsigned char LoadPort2Buffer[500];
int LoadPort2BufferLength = 0;
//unsigned char CassetteBuffer2[25];
//unsigned char LoadPort2Status[20];
//unsigned char LoadPort2LED[8];
int LoadUnloadState2;
bool boolMapping2 = false;
// 記錄為Load後的第一片
bool boolFirstAfterLoad2 = false;

void __fastcall TfrnMain::ybLoadPort2CommNotify(TObject *Sender,
      int NotifyType)
{
char Buf[8192+1];
AnsiString msg;
int len,pos,n;
bool boolmap = false;
bool boolstas = false;
// Load/Unload LoadUnloadState = 1/2;
bool boollpld = false;
bool boolclearerrorcode = false;

   // 先不管
   //if(NotifyType == EV_RXCHAR) {

      // 2020 4 20 - chc 有通訊則Power為On
      pnlLoadPort2Power->Color = clLime;
      pnlLoadPort2KWF->Color = clLime;

      n = ybLoadPort2->Read(Buf,8192);
      if(n > 0) {
         Buf[n] = 0;
         for(int i=0 ; i<n ; i++) {
            if(Buf[i] == 0x0d) {
               // Display
               AddLoadPort2RecvMessage(ReplyStrLoadPort2);
               // Recv: 0000INF:FPML;41* (INF = 完成)
               if(ReplyStrLoadPort2.Pos("INF") > 0) {
                  pnlLoadPort2Operation->Caption = "Ready";
                  pnlLoadPort2->Enabled = true;

                  // 2020 5 20 - chc Clear Error Code & Msg
                  boolclearerrorcode = true;

                  // 2020 5 14 - chc Reset Error Code
                  pnlLoadPort2ErrorCode1->Caption = "";
                  pnlLoadPort2ErrorMsg->Caption = "";

                  // FPML
                  if(ReplyStrLoadPort2.Pos("FPML") > 0) {
                     boolmap = true;
                     pnlEFEMCassette2->Color = clLime;
                     pnlLoadPort2Load->Color = clLime;
                     pnlLoadPort2UnLoad->Color = clSilver;
                     btnCassette2Load->Caption = "UnLoad";
                     frmRecipe->btnCassette2Load->Caption = "UnLoad";
                     LoadUnloadState2 = 1;
                     boolMapping2 = true;
                     boollpld = true;

                     // 2020 5 21 - chc 可以取片
                     btnLoadWafer->Enabled = true;

                     // 2020 5 4 - chc 已完成
                     boolLoadUnloadStatus2 = true;

                     // 2020 5 14 - chc 記錄為Load後的第一片
                     boolFirstAfterLoad2 = true;

                     // 2020 5 12 - chc 綠燈
                     SetGreenLamp(true);
                     SetYellowLamp(false);

                  }
                  else if(ReplyStrLoadPort2.Pos("ORGN") > 0) {
                     pnlEFEMCassette2->Color = clSilver;
                     pnlLoadPort2Load->Color = clSilver;
                     pnlLoadPort2UnLoad->Color = clLime;
                     btnCassette2Load->Caption = "Load";
                     frmRecipe->btnCassette2Load->Caption = "Load";
                     LoadUnloadState2 = 2;
                     boollpld = true;
                     UpdateCassette2State(0);
                     boolMapping2 = false;

                     // 2020 5 21 - chc 不可以取片
                     btnLoadWafer->Enabled = false;

                     // 2020 5 4 - chc 已完成
                     boolLoadUnloadStatus2 = true;

                     // 2020 5 14 - chc 記錄為Load後的第一片
                     boolFirstAfterLoad2 = false;

                     // 2020 5 12 - chc 綠燈
                     SetGreenLamp(false);
                     SetYellowLamp(true);

                  }

                  // 2020 4 29 - chc Mapping
                  else if(ReplyStrLoadPort.Pos("MAPP") > 0) {
                     boolmap = true;
                     LoadUnloadState2 = 1;
                     boolMapping2 = true;
                  }

                  // 2020 4 20 - chc Succ則Alarm為Off
                  pnlLoadPort2Alarm->Color = clSilver;
                  pnlLoadPort2InterLockCode->Caption = "";
                  pnlLoadPort2InterLockCode1->Caption = "";
                  PutLoadPort2InterLockMsg();

                  // 2020 4 27 - chc
                  // Power On: PWON, PDON: Normal Mount Status, PDOF: Load sensors and mount are all OFF
                  if(ReplyStrLoadPort2.Pos("PWON") > 0) {
                  }
                  if(ReplyStrLoadPort2.Pos("PDON") > 0) {
                  }
                  if(ReplyStrLoadPort2.Pos("PDOF") > 0) {
                  }

               }
               // 0000GET:STAS/02100010101000000000;45*
               // 12345678901234567890
               else if(ReplyStrLoadPort2.Pos("GET:STAS") > 0) {
                  pos = ReplyStrLoadPort2.Pos("STAS/");
                  sprintf(LoadPort2Status,"%s",ReplyStrLoadPort2.SubString(pos+5,20).c_str());
                  pnlLoadPort2Operation->Caption = "Ready";
                  pnlLoadPort2->Enabled = true;
                  UpdateLoadPort2Status_1();
                  // 2020 4 20 - chc Succ則Alarm為Off
                  pnlLoadPort2Alarm->Color = clSilver;
               }
               // InterLockCode: pnlLoadPort2InterLockCode
               // MOV:FPML/19;F3
               // 12345678901234567890
               // Error
               else if(ReplyStrLoadPort2.Pos("MOV:FPML/") > 0) {
                  pos = ReplyStrLoadPort2.Pos("FPML/");
                  pnlLoadPort2InterLockCode->Caption = ReplyStrLoadPort2.SubString(pos+5,2);
                  pnlLoadPort2InterLockCode1->Caption = ReplyStrLoadPort2.SubString(pos+5,2);
                  PutLoadPort2InterLockMsg();
                  pnlLoadPort2Operation->Caption = "Ready";
                  pnlLoadPort2->Enabled = true;
                  pnlLoadPort2Alarm->Color = clLime;
                  boolMapping2 = false;

                  // 2020 5 12 - chc 紅燈
                  // 2020 8 12 - chc TSMC修改
                  //RedLamp(true);
                  boolEFEMError = true;

               }
               // Error
               else if(ReplyStrLoadPort2.Pos("MOV:ORGN/") > 0) {
                  pos = ReplyStrLoadPort2.Pos("ORGN/");
                  pnlLoadPort2InterLockCode->Caption = ReplyStrLoadPort2.SubString(pos+5,2);
                  pnlLoadPort2InterLockCode1->Caption = ReplyStrLoadPort2.SubString(pos+5,2);
                  PutLoadPort2InterLockMsg();
                  pnlLoadPort2Operation->Caption = "Ready";
                  pnlLoadPort2->Enabled = true;
                  pnlLoadPort2Alarm->Color = clLime;
                  boolMapping2 = false;

                  // 2020 5 12 - chc 紅燈
                  // 2020 8 12 - chc TSMC修改
                  //RedLamp(true);
                  boolEFEMError = true;

               }
               // 0000GET:LEST/abcdefgh;45*
               // 12345678901234567890
               else if(ReplyStrLoadPort2.Pos("GET:LEST") > 0) {
                  pos = ReplyStrLoadPort2.Pos("LEST/");
                  sprintf(LoadPort2LED,"%s",ReplyStrLoadPort2.SubString(pos+5,8).c_str());
                  pnlLoadPort2Operation->Caption = "Ready";
                  pnlLoadPort2->Enabled = true;
                  UpdateLoadPort2LED_1();
                  // 2020 4 20 - chc Succ則Alarm為Off
                  pnlLoadPort2Alarm->Color = clSilver;
               }
               // 0000ABS:FPML/16;D0* (ABS=有error, 16=error code)
               // 12345678901234567890
               else if(ReplyStrLoadPort2.Pos("ABS") > 0) {
                  pos = ReplyStrLoadPort2.Pos("ABS");
                  pnlLoadPort2Operation->Caption = "Error";
                  pnlLoadPort2ErrorCode->Caption = ReplyStrLoadPort2.SubString(pos+9,2);
                  pnlLoadPort2ErrorCode1->Caption = ReplyStrLoadPort2.SubString(pos+9,2);

                  // 2020 9 3 - chc Error Code
                  pnlLoadPort2S5->Caption = ReplyStrLoadPort2.SubString(pos+9,1);
                  pnlLoadPort2S6->Caption = ReplyStrLoadPort2.SubString(pos+10,1);

                  pnlLoadPort2->Enabled = true;
                  // 2020 4 20 - chc ABS則Alarm為On
                  pnlLoadPort2Alarm->Color = clLime;

                  // 2020 5 14 - chc Error Code
                  PutLoadPort2ErrorCodeMsg();

                  // 2020 5 12 - chc 紅燈
                  // 2020 8 12 - chc TSMC修改
                  //RedLamp(true);
                  boolEFEMError = true;

               }
               // 0000GET:MAPR/0000000000000000000000000;1A*( bottem to top)
               // 12345678901234567890
               // CassetteBuffer[25]
               else if(ReplyStrLoadPort2.Pos("MAPR") > 0) {

                  // 2020 4 29 - chc 做一次就可以!
                  //for(int i=0 ; i<25 ; i++) {

                     pos = ReplyStrLoadPort2.Pos("MAPR");
                     sprintf(CassetteBuffer2,"%s",ReplyStrLoadPort2.SubString(pos+5,25).c_str());
                     pnlLoadPort2Operation->Caption = "Ready";
                     pnlLoadPort2->Enabled = true;
                     UpdateCassette2State(1);
                     boolstas = true;
                     // 2020 4 20 - chc Succ則Alarm為Off
                     pnlLoadPort2Alarm->Color = clSilver;
                     boolMapping2 = true;

                  //}

               }

               // 2020 4 29 - chc Mapping
               else if(ReplyStrLoadPort2.Pos("MOV:MAPP/") > 0) {
                  pos = ReplyStrLoadPort2.Pos("MAPP/");
                  pnlLoadPort2InterLockCode->Caption = ReplyStrLoadPort2.SubString(pos+5,2);
                  pnlLoadPort2InterLockCode1->Caption = ReplyStrLoadPort2.SubString(pos+5,2);
                  PutLoadPort2InterLockMsg();
                  pnlLoadPort2Operation->Caption = "Ready";
                  pnlLoadPort2->Enabled = true;
                  pnlLoadPort2Alarm->Color = clLime;
                  boolMapping2 = false;

                  // 2020 5 12 - chc 紅燈
                  // 2020 8 12 - chc TSMC修改
                  //RedLamp(true);
                  boolEFEMError = true;

               }

               // 2020 5 20 - chc Clear Error Code & Msg
               if(boolclearerrorcode == true) {
                  // Error code
                  pnlLoadPort2ErrorCode->Caption = "";
                  pnlLoadPort2ErrorCode1->Caption = "";
                  pnlLoadPort2ErrorMsg->Caption = "";
                  // Interlock code
                  pnlLoadPort2InterLockCode->Caption = "";
                  pnlLoadPort2InterLockCode1->Caption = "";
                  pnlLoadPort2InterLockMsg->Caption = "";
               }

               // Clear
               ReplyStrLoadPort2 = "";
            }
            else {
               if(Buf[i] == 0x01)
                  ReplyStrLoadPort2 += "<";
               else
                  ReplyStrLoadPort2 += Buf[i];
            }
         }
      }

   // 先不管
   //}

   if(pnlLoadPort2->Enabled == true) {
      btnLoadPort2Enable->Visible = false;
      if(boolmap == true)
         btnLoadPort2MapClick(this);
   }
   if(pnlLoadPort2->Enabled == true) {
      if(boolstas == true) {
         btnLoadPort2StasClick(this);
      }
   }
   // Load/Unload LoadUnload2State = 1/2;
   if(boollpld == true) {
      tmLoadUnload2->Enabled = true;
   }
}
//---------------------------------------------------------------------------
// LoadPort Recv
void __fastcall TfrnMain::AddLoadPort2RecvMessage(AnsiString msg)
{
AnsiString putmsg;

   //putmsg = Now().FormatString("hh':'nn':'ss'-> '") + msg;
   //mmLoadPort2Msg->Lines->Insert(0,putmsg);
   //if(mmLoadPort2Msg->Lines->Count > 400) {
   //   for(int i=370 ; i<mmLoadPort2Msg->Lines->Count ; i++)
   //      mmLoadPort2Msg->Lines->Delete(i);
   //}

   // 2022 9 6 - chc 固定要清除, 否則速度會變慢!
   if(mmLoadPort2Msg->Lines->Count > 400) {
      for(int i=320 ; i<mmLoadPort2Msg->Lines->Count ; i++)
         mmLoadPort2Msg->Lines->Delete(i);
   }

   //putmsg = "<" + msg;
   //putmsg = msg;
   //mmLoadPort2Msg->Lines->Insert(0,putmsg);
   putmsg = Now().FormatString("nn':'ss':'zzz' < '") + msg;
   mmLoadPort2Msg->Lines->Insert(0,putmsg);
}
//---------------------------------------------------------------------------
// CassetteBuffer[]
// pnlTray25
// 0：no wafer exists
// 1：wafer exists
// 2：Cross
// 3：Thickness error（Thick）
// 4：Thickness error（Thin）
// 5：position error
// mode: 0-Clear, 1-Set

void __fastcall TfrnMain::UpdateCassette2State(int mode)
{
TPanel *panel,*panel1,*panela;
bool first = true;

   // Set Mapping Status
   boolMappingStatus2 = true;

   for(int i=0 ; i<25 ; i++) {
      panel = (TPanel*)(FindComponent("pnlTray2_" + IntToStr(i+1)));
      panel1 = (TPanel*)(FindComponent("pnlTray2_" + IntToStr(i+1) + "Select"));
      panela = (TPanel*)(frmRecipe->FindComponent("pnlTray" + IntToStr(i+1)));
      // Set
      if(mode == 1) {
         if(CassetteBuffer2[i] == '0') {
            panel->Color = clSilver;
            panela->Color = clSilver;
            panel1->Enabled = false;
            panel1->Color = clGray;
         }
         else if(CassetteBuffer2[i] == '1') {
            panel->Color = clLime;
            panela->Color = clLime;
            panel1->Enabled = true;
            panel1->Color = clLime;

            // 第一片位置
            // 小到大
            if(rgLoadOrder->ItemIndex == 0) {
               if(first == true) {
                  first = false;
                  rgWaferNo->ItemIndex = 24 - i;
               }
            }
            // 大到小
            else {
               rgWaferNo->ItemIndex = 24 - i;
            }

         }
         else {
            panel->Color = clRed;
            panela->Color = clRed;
            panel1->Enabled = false;
            panel1->Color = clGray;

            // 2020 7 17 - chc Set Mapping Status
            boolMappingStatus2 = false;

         }
      }
      // Clear: ORGN(UnLoad)
      else {
         CassetteBuffer2[i] = '0';
         panel->Color = clSilver;
         panela->Color = clSilver;
         panel1->Enabled = false;
         panel1->Color = clGray;
      }
   }
}
//---------------------------------------------------------------------------
//Inter Lock Code
//-------------------------------------------------
//01: Host AVAILABLE not input
//10: No FOUP mounting
//14: Clamping not completed
//15: Docking not completed
//16: Door vacuum not completed
//17: Unlatching not completed
//18: Door opening not completed
//19: Mapping not started
//1A: Mapping forward not completed
//1C: Z axis is not door position
//1D: Not in the mapping range
//1E: Undocking not completed
//-------------------------------------------------
// pnlLoadPortInterLockCode->Caption
void __fastcall TfrnMain::PutLoadPort2InterLockMsg()
{
AnsiString msg = "";
int code = 0;

   if(pnlLoadPort2InterLockCode->Caption == "")
      code = 0;
   else if(pnlLoadPort2InterLockCode->Caption == "01")
      code = 1;
   else if(pnlLoadPort2InterLockCode->Caption == "10")
      code = 2;
   else if(pnlLoadPort2InterLockCode->Caption == "14")
      code = 3;
   else if(pnlLoadPort2InterLockCode->Caption == "15")
      code = 4;
   else if(pnlLoadPort2InterLockCode->Caption == "16")
      code = 5;
   else if(pnlLoadPort2InterLockCode->Caption == "17")
      code = 6;
   else if(pnlLoadPort2InterLockCode->Caption == "18")
      code = 7;
   else if(pnlLoadPort2InterLockCode->Caption == "19")
      code = 8;
   else if(pnlLoadPort2InterLockCode->Caption == "1A")
      code = 9;
   else if(pnlLoadPort2InterLockCode->Caption == "1C")
      code = 10;
   else if(pnlLoadPort2InterLockCode->Caption == "1D")
      code = 11;
   else if(pnlLoadPort2InterLockCode->Caption == "1E")
      code = 12;

   switch(code) {
      case 0:
         msg = "";
         break;
      case 1:
         msg = "Host AVAILABLE not input";
         break;
      case 2:
         msg = "No FOUP mounting";
         break;
      case 3:
         msg = "Clamping not completed";
         break;
      case 4:
         msg = "Docking not completed";
         break;
      case 5:
         msg = "Door vacuum not completed";
         break;
      case 6:
         msg = "Unlatching not completed";
         break;
      case 7:
         msg = "Door opening not completed";
         break;
      case 8:
         msg = "Mapping not started";
         break;
      case 9:
         msg = "Mapping forward not completed";
         break;
      case 10:
         msg = "Z axis is not door position";
         break;
      case 11:
         msg = "Not in the mapping range";
         break;
      case 12:
         msg = "Undocking not completed";
         break;
   }
   pnlLoadPort2InterLockMsg->Caption = msg;
   pnlLoadPort2InterLockMsg->Hint = msg;

   // 2020 5 20a - chc Error Log
   if(code > 0) {
      AddErrorLog("[LoadPort2 Interlock] " + pnlLoadPort2InterLockCode->Caption + ": " + msg);
   }
}
//---------------------------------------------------------------------------
//unsigned char LoadPort2Status[20];
void __fastcall TfrnMain::UpdateLoadPort2Status_1()
{
TPanel *panel;
AnsiString msg;

   for(int i=0 ; i<20 ; i++) {
      // pnlLoadPort2S1
      panel = (TPanel*)(FindComponent("pnlLoadPort2S" + IntToStr(i+1)));
      msg.sprintf("%c",LoadPort2Status[i]);
      panel->Caption = msg;
   }
}
//---------------------------------------------------------------------------
//unsigned char LoadPort2LED[8];
void __fastcall TfrnMain::UpdateLoadPort2LED_1()
{
TPanel *panel;
AnsiString msg;

   for(int i=0 ; i<8 ; i++) {
      switch(i) {
         case 0:
            panel = pnlLoadPort2Presence;
            break;
         case 1:
            panel = pnlLoadPort2Placement;
            break;
         case 2:
            panel = pnlLoadPort2Load;
            break;
         case 3:
            panel = pnlLoadPort2UnLoad;
            break;
         case 4:
            return;
            break;
         case 5:
            panel = pnlLoadPort2Status1;
            break;
         case 6:
            panel = pnlLoadPort2Status2;
            break;
         case 7:
            return;
            break;
      }
      if(LoadPort2LED[i] == '0')
         panel->Color = clSilver;
      else if(LoadPort2LED[i] == '1')
         panel->Color = clLime;
      else if(LoadPort2LED[i] == '2')
         panel->Color = clYellow;

      // Load
      if(i == 2) {
         pnlEFEMCassette2->Color = panel->Color;
         if(panel->Color == clLime) {
            btnCassette2Load->Caption = "UnLoad";
            frmRecipe->btnCassette2Load->Caption = "UnLoad";

            // 2020 5 21 - chc 可以取片
            btnLoadWafer->Enabled = true;

         }
      }
      // UnLoad
      if(i == 3) {
         pnlEFEMCassette2->Color = panel->Color;
         if(panel->Color == clLime) {
            btnCassette2Load->Caption = "Load";
            frmRecipe->btnCassette2Load->Caption = "Load";

            // 2020 5 21 - chc 不可以取片
            btnLoadWafer->Enabled = false;

         }
      }

   }
}
//---------------------------------------------------------------------------
// 2022 7 10 - chc LoadPort2 Error Code
// -------------------------------------------------------------------------------------------------------------------
//                                                      Error Code
// -------------------------------------------------------------------------------------------------------------------
// 0 0 Normal
// 1 0 Clamp time over
// 1 1 Unclamp time over
// 1 2 Dock time over
// 1 3 Undock time over
// 1 4 Latch time over
// 1 5 Unlatch time over
// 1 6 Vacuum time over
// 1 7 Vacuum release time over
// 1 8 Door open time over
// 1 9 Door close time over
// 1 A Mapping forward time over
// 1 B Mapping return time over
// 1 F communication error(3 times of resending  (T-Type)
// 2 0 Home return time over
// 2 1 Loading time over
// 2 2 Unloading time over
// 2 3 Positioning time over
// 2 8 Door open/close position movement time over (mapping elevating operation)
// 2 9 Mapping start position movement time over (elevating operation)
// 2 A Mapping end position movement time over (elevating operation)
// 2 B Load position movement time over (elevating operation)
// 4 0 Mapping data error
// 4 1 Mode select error
// 7 0 Clamp sensor error
// 7 1 Dock sensor
// 7 2 Latch sensor error
// 7 3 Door sensor error
// 7 4 Mapping sensor error
// 7 7 Elevator axis sensor error
// A 0 Wafer dropWafer drop
// A 1 Wafer protrusion
// A 2 FOUP mount error (Mount sensor)
// A 3 FOUP mount error (Load sensor)
// A 5 Air pressure drop
// B 0 Host error
// C 0 Parameter error
// E 0 FAN stop alarm
// E 3 Voltage drop
// F E Dock hand pinch error
void __fastcall TfrnMain::PutLoadPort2ErrorCodeMsg()
{
AnsiString msg = "";
AnsiString errorcode;
int code = 0;

   errorcode = pnlLoadPort2S5->Caption + pnlLoadPort2S6->Caption;
   if(errorcode == "")
      code = 0;
   else if(errorcode == "10")
      code = 1;
   else if(errorcode == "11")
      code = 2;
   else if(errorcode == "12")
      code = 3;
   else if(errorcode == "13")
      code = 4;
   else if(errorcode == "14")
      code = 5;
   else if(errorcode == "15")
      code = 6;
   else if(errorcode == "16")
      code = 7;
   else if(errorcode == "17")
      code = 8;
   else if(errorcode == "18")
      code = 9;
   else if(errorcode == "19")
      code = 10;
   else if(errorcode == "1A")
      code = 11;
   else if(errorcode == "1B")
      code = 12;
   else if(errorcode == "1F")
      code = 13;
   else if(errorcode == "20")
      code = 14;
   else if(errorcode == "21")
      code = 15;
   else if(errorcode == "22")
      code = 16;
   else if(errorcode == "23")
      code = 17;
   else if(errorcode == "28")
      code = 18;
   else if(errorcode == "29")
      code = 19;
   else if(errorcode == "2A")
      code = 20;
   else if(errorcode == "2B")
      code = 21;
   else if(errorcode == "40")
      code = 22;
   else if(errorcode == "41")
      code = 23;
   else if(errorcode == "70")
      code = 24;
   else if(errorcode == "71")
      code = 25;
   else if(errorcode == "72")
      code = 26;
   else if(errorcode == "73")
      code = 27;
   else if(errorcode == "74")
      code = 28;
   else if(errorcode == "77")
      code = 29;
   else if(errorcode == "A0")
      code = 30;
   else if(errorcode == "A1")
      code = 31;
   else if(errorcode == "A2")
      code = 32;
   else if(errorcode == "A3")
      code = 33;
   else if(errorcode == "A5")
      code = 34;
   else if(errorcode == "B0")
      code = 35;
   else if(errorcode == "C0")
      code = 36;
   else if(errorcode == "E0")
      code = 37;
   else if(errorcode == "E3")
      code = 38;
   else if(errorcode == "FE")
      code = 39;

   switch(code) {
      case 0:
         msg = "";
         break;
      case 1:
         msg = "Clamp time over";
         break;
      case 2:
         msg = "Unclamp time over";
         break;
      case 3:
         msg = "Dock time over";
         break;
      case 4:
         msg = "Undock time over";
         break;
      case 5:
         msg = "Latch time over";
         break;
      case 6:
         msg = "Unlatch time over";
         break;
      case 7:
         msg = "Vacuum time over";
         break;
      case 8:
         msg = "Vacuum release time over";
         break;
      case 9:
         msg = "Door open time over";
         break;
      case 10:
         msg = "Door close time over";
         break;
      case 11:
         msg = "Mapping forward time over";
         break;
      case 12:
         msg = "Mapping return time over";
         break;
      case 13:
         msg = "communication error(3 times of resending (T-Type)";
         break;
      case 14:
         msg = "Home return time over";
         break;
      case 15:
         msg = "Loading time over";
         break;
      case 16:
         msg = "Unloading time over";
         break;
      case 17:
         msg = "Positioning time over";
         break;
      case 18:
         msg = "Door open/close position movement time over (mapping elevating operation)";
         break;
      case 19:
         msg = "Mapping start position movement time over (elevating operation)";
         break;
      case 20:
         msg = "Mapping end position movement time over (elevating operation)";
         break;
      case 21:
         msg = "Load position movement time over (elevating operation)";
         break;
      case 22:
         msg = "Mapping data error";
         break;
      case 23:
         msg = "Mode select error";
         break;
      case 24:
         msg = "Clamp sensor error";
         break;
      case 25:
         msg = "Dock sensor";
         break;
      case 26:
         msg = "Latch sensor error";
         break;
      case 27:
         msg = "Door sensor error";
         break;
      case 28:
         msg = "Mapping sensor error";
         break;
      case 29:
         msg = "Elevator axis sensor error";
         break;
      case 30:
         msg = "Wafer dropWafer drop";
         break;
      case 31:
         msg = "Wafer protrusion";
         break;
      case 32:
         msg = "FOUP mount error (Mount sensor)";
         break;
      case 33:
         msg = "FOUP mount error (Load sensor)";
         break;
      case 34:
         msg = "Air pressure drop";
         break;
      case 35:
         msg = "Host error";
         break;
      case 36:
         msg = "Parameter error";
         break;
      case 37:
         msg = "FAN stop alarm";
         break;
      case 38:
         msg = "Voltage drop";
         break;
      case 39:
         msg = "Dock hand pinch error";
         break;

   }
   pnlLoadPort2ErrorMsg->Caption = msg;
   pnlLoadPort2ErrorMsg->Hint = msg;

   // 2020 5 20a - chc Error Log
   if(code > 0) {
      AddErrorLog("[LoadPort2] " + errorcode + ": " + msg);
   }

}
//---------------------------------------------------------------------------
// LoadPort2
void __fastcall TfrnMain::tmLoadUnload2Timer(TObject *Sender)
{
long StartTime,StopTime,Elapsedms;
short StartTick,StopTick;
int step = 0;
AnsiString msg;

   tmLoadUnload2->Enabled = false;

   if(pnlLoadPort2->Enabled == false) {
      return;
   }

   GetTimeTic(&StartTime,&StartTick);
   while(1) {
      Sleep(1);
      Application->ProcessMessages();
      GetTimeTic(&StopTime,&StopTick);
      Elapsedms = ((StopTime*1000+StopTick) - (StartTime*1000+StartTick));
      if(Elapsedms > 5000) {
         WriteSystemLog("tmLoadUnload2Timer TimeOut! " + IntToStr(step));
         return;
      }
      if(pnlLoadPort2->Enabled == true) {
         if(step == 0) {
            step = 1;
            if(LoadUnloadState2 == 1) {
               edLoadPort2Cmd->Text = "SET:LPLD;";
            }
            else {
               edLoadPort2Cmd->Text = "SET:LOLD;";
            }
            btnLoadPort2CMDClick(this);
         }
         else if(step == 1) {
            step = 2;
            if(LoadUnloadState2 == 1) {
               edLoadPort2Cmd->Text = "SET:LOUD;";
            }
            else {
               edLoadPort2Cmd->Text = "SET:LPUD;";
            }
            btnLoadPort2CMDClick(this);
            return;
         }
      }
   }
}
//---------------------------------------------------------------------------
// Load / Unload
void __fastcall TfrnMain::btnCassetteLoadClick(TObject *Sender)
{

   // 2022 12 22 - chc set CST
   rgFoupSource->ItemIndex = LOADPORT_1;
   rgCST->ItemIndex = LOADPORT_1;
   pnlCST->Enabled = false;
   btnCassetteLoad->Enabled = false;

   pnlCassetteLoad->Color = clSilver;
   frmRecipe->pnlCassetteLoad->Color = clSilver;
   if(pnlLoadPort->Enabled == true) {
      // Load...
      if(btnCassetteLoad->Caption == "Load") {
         pnlStartMessage->Caption = "Cassette Loading前檢查...";
         pnlStartMessage->Visible = true;
         pnlStartMessage->Refresh();
      }
      else {
         pnlStartMessage->Caption = "Cassette Unloading前檢查...";
         pnlStartMessage->Visible = true;
         pnlStartMessage->Refresh();
      }

      // 先做Robot ORGN(GP1/GP0) & 偵測pnlLoadPortS12是否為1?
      if(BeforeLoadPortLoadUnload() == false) {
         pnlCassetteLoad->Color = clRed;
         frmRecipe->pnlCassetteLoad->Color = clRed;
         pnlCST->Enabled = true;
         btnCassetteLoad->Enabled = true;
         return;
      }

      // UnLoad
      if(btnCassetteLoad->Caption == "UnLoad") {
         if(BeforeUnload() == false) {
            pnlCassetteLoad->Color = clRed;
            frmRecipe->pnlCassetteLoad->Color = clRed;
            pnlCST->Enabled = true;
            btnCassetteLoad->Enabled = true;
            return;
         }
      }

      boolLoadUnloadStatus = false;

      if(btnCassetteLoad->Caption == "Load") {
         // Load...
         pnlStartMessage->Caption = "Cassette Loading...";
         pnlStartMessage->Visible = true;
         pnlStartMessage->Refresh();

         edLoadPortCmd->Text = "MOV:FPML;";
         btnLoadPortCMDClick(this);
         if(pnlCassetteLoad->Color == clLime) {
            pnlOperationMessage->Caption = "Load完成.";
            pnlAlarmMessage->Caption = pnlOperationMessage->Caption;
         }
      }
      else {
         // Unload...
         pnlStartMessage->Caption = "Cassette Unloading...";
         pnlStartMessage->Visible = true;
         pnlStartMessage->Refresh();

         edLoadPortCmd->Text = "MOV:ORGN;";
         btnLoadPortCMDClick(this);
         if(pnlCassetteLoad->Color == clLime) {
            pnlOperationMessage->Caption = "UnLoad完成.";
            pnlAlarmMessage->Caption = pnlOperationMessage->Caption;
         }
      }

      // 等20秒
      int cnt = 0;
      int max = 40;
      while(1) {
         if(boolLoadUnloadStatus == true) {
            pnlCassetteLoad->Color = clLime;
            frmRecipe->pnlCassetteLoad->Color = clLime;
            break;
         }
         cnt++;
         if(cnt > max) {
            pnlCassetteLoad->Color = clRed;
            frmRecipe->pnlCassetteLoad->Color = clRed;
            break;
         }
         WaitTime(500);
      }
      // Load...
      pnlStartMessage->Visible = false;
   }
   pnlCST->Enabled = true;
   btnCassetteLoad->Enabled = true;
}
//---------------------------------------------------------------------------
// Load / Unload
void __fastcall TfrnMain::btnCassette2LoadClick(TObject *Sender)
{

   // 2022 12 22 - chc set CST
   rgFoupSource->ItemIndex = LOADPORT_2;
   rgCST->ItemIndex = LOADPORT_2;
   pnlCST->Enabled = false;
   btnCassette2Load->Enabled = false;

   pnlCassette2Load->Color = clSilver;
   frmRecipe->pnlCassette2Load->Color = clSilver;
   if(pnlLoadPort2->Enabled == true) {
      // Load...
      if(btnCassette2Load->Caption == "Load") {
         pnlStartMessage->Caption = "Cassette2 Loading前檢查...";
         pnlStartMessage->Visible = true;
         pnlStartMessage->Refresh();
      }
      else {
         pnlStartMessage->Caption = "Cassette2 Unloading前檢查...";
         pnlStartMessage->Visible = true;
         pnlStartMessage->Refresh();
      }

      // 先做Robot ORGN(GP1/GP0) & 偵測pnlLoadPortS12是否為1?
      if(BeforeLoadPortLoadUnload() == false) {
         pnlCassette2Load->Color = clRed;
         frmRecipe->pnlCassette2Load->Color = clRed;
         pnlCST->Enabled = true;
         btnCassette2Load->Enabled = true;
         return;
      }

      // UnLoad
      if(btnCassette2Load->Caption == "UnLoad") {
         if(BeforeUnload() == false) {
            pnlCassette2Load->Color = clRed;
            frmRecipe->pnlCassette2Load->Color = clRed;
            pnlCST->Enabled = true;
            btnCassette2Load->Enabled = true;
            return;
         }
      }

      boolLoadUnloadStatus2 = false;

      if(btnCassette2Load->Caption == "Load") {
         // Load...
         pnlStartMessage->Caption = "Cassette2 Loading...";
         pnlStartMessage->Visible = true;
         pnlStartMessage->Refresh();

         edLoadPort2Cmd->Text = "MOV:FPML;";
         btnLoadPort2CMDClick(this);
         if(pnlCassette2Load->Color == clLime) {
            pnlOperationMessage->Caption = "Load完成.";
            pnlAlarmMessage->Caption = pnlOperationMessage->Caption;
         }
      }
      else {
         // Unload...
         pnlStartMessage->Caption = "Cassette2 Unloading...";
         pnlStartMessage->Visible = true;
         pnlStartMessage->Refresh();

         edLoadPort2Cmd->Text = "MOV:ORGN;";
         btnLoadPort2CMDClick(this);
         if(pnlCassette2Load->Color == clLime) {
            pnlOperationMessage->Caption = "UnLoad完成.";
            pnlAlarmMessage->Caption = pnlOperationMessage->Caption;
         }
      }

      // 等20秒
      int cnt = 0;
      int max = 40;
      while(1) {
         if(boolLoadUnloadStatus2 == true) {
            pnlCassette2Load->Color = clLime;
            frmRecipe->pnlCassette2Load->Color = clLime;
            break;
         }
         cnt++;
         if(cnt > max) {
            pnlCassette2Load->Color = clRed;
            frmRecipe->pnlCassette2Load->Color = clRed;
            break;
         }
         WaitTime(500);
      }
      // Load...
      pnlStartMessage->Visible = false;
   }
   pnlCST->Enabled = true;
   btnCassette2Load->Enabled = true;
}
//---------------------------------------------------------------------------
// 2022 7 10 - chc Robot/Chuck/Aligner has wafer?
// => 少Macro檢查@@@
bool __fastcall TfrnMain::BeforeUnload()
{

   // 2022 12 27 - chc Tazmo
   if(RobotMode == ROBOT_MODE_TAZMO) {
      // Aligner
      if(rgFoupSource->ItemIndex == LOADPORT_1) {
         btnAlignerWithWaferClick(this);
         if(pnlAlignerWithWafer->Color == clLime) {
            pnlOperationMessage->Caption = "Aligner1有Wafer!";
            pnlAlarmMessage->Caption = pnlOperationMessage->Caption;
            WriteSystemLog(pnlOperationMessage->Caption);
            return false;
         }
      }
      else {
         btnAligner2WithWaferClick(this);
         if(pnlAligner2WithWafer->Color == clLime) {
            pnlOperationMessage->Caption = "Aligner2有Wafer!";
            pnlAlarmMessage->Caption = pnlOperationMessage->Caption;
            WriteSystemLog(pnlOperationMessage->Caption);
            return false;
         }
      }
      // Chuck
      btnChuckWithWaferClick(this);
      if(pnlChuckWithWafer->Color == clLime) {
         pnlOperationMessage->Caption = "Chuck上有Wafer!";
         pnlAlarmMessage->Caption = pnlOperationMessage->Caption;
         WriteSystemLog(pnlOperationMessage->Caption);
         return false;
      }
      // Macro
      btnMacroWithWaferClick(this);
      if(pnlMacroWithWafer->Color == clLime) {
         pnlOperationMessage->Caption = "Macro上有Wafer!";
         pnlAlarmMessage->Caption = pnlOperationMessage->Caption;
         WriteSystemLog(pnlOperationMessage->Caption);
         return false;
      }
   }
   else {

      // 1. 確認Chuck是否無片?
      pnlOperationMessage->Caption = "檢查Chuck...";
      WriteSystemLog(pnlOperationMessage->Caption);
      if(pnlBit7->Color == clLime) {
         pnlOperationMessage->Caption = "Chuck有Wafer!";
         pnlAlarmMessage->Caption = pnlOperationMessage->Caption;
         WriteSystemLog(pnlOperationMessage->Caption);
         return false;
      }

      // 2. 確認Aligner是否無片?
      pnlOperationMessage->Caption = "檢查Aligner...";
      btnAlignerStasClick(this);
      int cnt,timeout;
      cnt = 0;
      timeout = 20;
      // 等
      while(1) {
         if(pnlAligner->Enabled == true)
            break;
         Sleep(100);
         Application->ProcessMessages();
         cnt++;
         if(cnt > timeout) {
            pnlOperationMessage->Caption = "Aligner Timeout Error!";
            pnlAlarmMessage->Caption = pnlOperationMessage->Caption;
            WriteSystemLog(pnlOperationMessage->Caption);
            return false;
         }
      }
      if(pnlAlignerS6->Caption != "011") {
         pnlOperationMessage->Caption = "Aligner有Wafer!";
         pnlAlarmMessage->Caption = pnlOperationMessage->Caption;
         WriteSystemLog(pnlOperationMessage->Caption);
         return false;
      }
   }

   // 3. 確認Robot是否無片?
   pnlOperationMessage->Caption = "檢查Robot...";
   btnRobotWithWaferClick(this);

   // 2022 9 22 - chc 等待完成 2000ms: pnlRobotWithWafer->Color
   /*
   // 等
   cnt = 0;

   // 2022 9 12 - chc 延長到4秒
   //timeout = 20;
   timeout = 40;

   while(1) {
      if(pnlRobot->Enabled == true)
         break;
      Sleep(100);
      Application->ProcessMessages();
      cnt++;
      if(cnt > timeout) {
         pnlOperationMessage->Caption = "Robot通訊異常!";
         pnlAlarmMessage->Caption = pnlOperationMessage->Caption;
         WriteSystemLog(pnlOperationMessage->Caption);
         return false;
      }
   }
   if(pnlRobotWithWafer->Color == clLime) {
   */
   if(pnlRobotWithWafer->Color == clLime || pnlRobotWithWafer->Color == clRed) {

      pnlOperationMessage->Caption = "Robot上有Wafer!";
      pnlAlarmMessage->Caption = pnlOperationMessage->Caption;
      WriteSystemLog(pnlOperationMessage->Caption);
      return false;
   }
   pnlOperationMessage->Caption = "UnLoad前檢查Ok.";

   return true;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnSaveWPositionClick(TObject *Sender)
{
TIniFile *pSystemFile;

   // ini檔名與目錄
   pSystemFile = new TIniFile(RobotWINIFilename);

   TLMDEdit *edit;
   for(int no=0 ; no<MAX_W_POSITION ; no++) {
      // 不區分8"/12"
      edit = (TLMDEdit *)(FindComponent("edWPosition" + IntToStr(no+1)));
      WPositionSet[no] = edit->Text.ToInt();
      pSystemFile->WriteInteger(ROBOTW_PARAMETER_SECTION,"W Position" + IntToStr(no+1)    ,WPositionSet[no]);
   }

   delete pSystemFile;
}
//---------------------------------------------------------------------------
// 2022 7 13 - chc 4個W點位
void __fastcall TfrnMain::LoadWPosition()
{
TIniFile *pSystemFile;

   WriteSystemLog(AnsiString("LoadWPosition(): ") + RobotWINIFilename);
   if(!FileExists(RobotWINIFilename)) {
      WriteSystemLog("RobotW.ini Not Exist!");
      return;
   }

   // ini檔名與目錄
   pSystemFile = new TIniFile(RobotWINIFilename);

   // W Position
   TLMDEdit *edit;
   for(int no=0 ; no<MAX_W_POSITION ; no++) {
      WPositionSet[no] = pSystemFile->ReadInteger(ROBOTW_PARAMETER_SECTION,"W Position" + IntToStr(no+1)    ,100000);
      edit = (TLMDEdit *)(FindComponent("edWPosition" + IntToStr(no+1)));
      edit->Text = WPositionSet[no];
      WriteSystemLog(IntToStr(no+1) + ": WPosition=" + IntToStr(WPositionSet[no]));
   }

   delete pSystemFile;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnSetWPosition1Click(TObject *Sender)
{

   SetWPosition(1);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnSetWPosition2Click(TObject *Sender)
{

   SetWPosition(2);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnSetWPosition3Click(TObject *Sender)
{

   SetWPosition(3);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnSetWPosition4Click(TObject *Sender)
{

   SetWPosition(4);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnSetWPosition5Click(TObject *Sender)
{

   SetWPosition(5);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnToWPosition1Click(TObject *Sender)
{

   ToWPositionFun(1);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnToWPosition2Click(TObject *Sender)
{

   ToWPositionFun(2);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnToWPosition3Click(TObject *Sender)
{

   ToWPositionFun(3);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnToWPosition4Click(TObject *Sender)
{

   ToWPositionFun(4);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnToWPosition5Click(TObject *Sender)
{

   ToWPositionFun(5);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::combLED1ComportChange(TObject *Sender)
{

   //InitLED1Com();
   InitLampControl1();
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::combLED2ComportChange(TObject *Sender)
{

   //InitLED2Com();
   InitLampControl2();
}
//---------------------------------------------------------------------------
// 202 7 14 - chc Init LED1 ComPort
// COM6
void __fastcall TfrnMain::InitLED1Com()
{

   // 由參數決定COM Port
   pnlSystemMessage->Caption = "啟動LED1 Com Port...";
   try {
      pnlLampControl1->Color = clSilver;
      ybLampControl1->Active = false;
      Sleep(200);
      // 由參數決定COM Port
      ybLampControl1->PortNo = combLED1Comport->ItemIndex+1;

      ybLampControl1->Active = true;
      pnlLampControl1->Color = clLime;
   }
   catch(Exception &e) {
      pnlSystemMessage->Caption = "ybLampControl1: " + e.Message;
      sbSystem->Panels->Items[1]->Text = "ybLampControl1: " + e.Message;
      pnlLampControl1->Color = clRed;
   }
   pnlSystemMessage->Caption = "啟動LED1 Com Port.";

}
//---------------------------------------------------------------------------
// 202 7 14 - chc Init LED1 ComPort
// COM22
void __fastcall TfrnMain::InitLED2Com()
{

   // 由參數決定COM Port
   pnlSystemMessage->Caption = "啟動LED2 Com Port...";
   try {
      pnlLampControl2->Color = clSilver;
      ybLampControl2->Active = false;
      Sleep(200);
      // 由參數決定COM Port
      ybLampControl2->PortNo = combLED2Comport->ItemIndex+1;

      ybLampControl2->Active = true;
      pnlLampControl2->Color = clLime;
   }
   catch(Exception &e) {
      pnlSystemMessage->Caption = "ybLampControl2: " + e.Message;
      sbSystem->Panels->Items[1]->Text = "ybLampControl2: " + e.Message;
      pnlLampControl2->Color = clRed;
   }
   pnlSystemMessage->Caption = "啟動LED2 Com Port.";

}
//---------------------------------------------------------------------------
bool boolFormWheel = false;
// Mouse Wheel
void __fastcall TfrnMain::FormMouseWheelUp(TObject *Sender,
      TShiftState Shift, TPoint &MousePos, bool &Handled)
{
int x,y,w,h,dh;
int leftx,lefty,rightx,righty,value;
bool booldo = false;

   Handled = true;

   // Scroll
   if(cbWaferMap->Checked == true) {
      x = MousePos.x;
      y = MousePos.y;
      leftx = sbWaferMap->Left;
      lefty = sbWaferMap->Top;
      rightx = sbWaferMap->Left + sbWaferMap->Width - 1;
      righty = sbWaferMap->Top + sbWaferMap->Height - 1;
      if(x >= leftx && x <= rightx && y >= lefty && y <= righty) {
         int factor;
         factor = tbZoom->Position / 10;
         if(factor < 1)
            factor = 1;
         if(rgWheelDirection->ItemIndex == 0) {
            value = sbWaferMap->VertScrollBar->Position - (5*factor);
            if(value < 0)
               sbWaferMap->VertScrollBar->Position = 0;
            else
               sbWaferMap->VertScrollBar->Position -= (5*factor);
         }
         else if(rgWheelDirection->ItemIndex == 1) {
            value = sbWaferMap->HorzScrollBar->Position - (5*factor);
            if(value < 0)
               sbWaferMap->HorzScrollBar->Position = 0;
            else
               sbWaferMap->HorzScrollBar->Position -= (5*factor);
         }
         // 縮小
         else {
            if(tbZoom->Position > 10) {
               tbZoom->Position--;
               ZoomImage();
            }
         }
         //Sleep(100);
         AdjustCenterLine();
      }
      return;
   }

   dh = 30;

   // Z-
   x = MousePos.x;
   y = MousePos.y;

   // 對應到Form上
   int fx = frnMain->Left;
   int fy = frnMain->Top;
   x -= fx;
   y -= fy;

   w = pnlLeftMacroLamp->Width;
   h = pnlLeftMacroLamp->Height;
   leftx = pnlSystem->Left + pnlLeftMacroLamp->Left;
   lefty = pnlSystem->Top + pnlLeftMacroLamp->Top + dh;
   rightx = pnlSystem->Left + pnlRightMacroLamp->Left;
   righty = pnlSystem->Top + pnlRightMacroLamp->Top + dh;

   // Up
   if((x >= leftx && x <= (leftx+w)) && (y >= lefty && y <= (lefty+h))) {
      if(tbLED2CH1->Position < 253)
         tbLED2CH1->Position += 2;
      else
         tbLED2CH1->Position = 255;
      booldo = true;
      pnlLED2CH1->Caption = IntToStr(tbLED2CH1->Position);
      LED2CH1Value = tbLED2CH1->Position;
      SetLED2Value(1,LED2CH1Value);
      return;
   }
   else if((x >= rightx && x <= (rightx+w)) && (y >= righty && y <= (righty+h))) {
      if(tbLED2CH2->Position < 253)
         tbLED2CH2->Position += 2;
      else
         tbLED2CH2->Position = 255;
      booldo = true;
      pnlLED2CH2->Caption = IntToStr(tbLED2CH2->Position);
      LED2CH2Value = tbLED2CH2->Position;
      SetLED2Value(2,LED2CH2Value);
      return;
   }

   // 放大
   if(pnlMaintenance->Visible == true && pcMaintenance->ActivePage == tsMainCCD) {
      leftx = pnlMaintenance->Left + pcMaintenance->Left + imOperation->Left;
      rightx = leftx + imOperation->Width;
      lefty = pnlMaintenance->Top + pcMaintenance->Top + imOperation->Top;
      righty = lefty + imOperation->Height;
      if(x >= leftx && x <= rightx && y >= lefty && y <= righty) {
         boolFormWheel = true;
         imAddClick(this);
         boolFormWheel = false;
      }
   }

}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::FormMouseWheelDown(TObject *Sender,
      TShiftState Shift, TPoint &MousePos, bool &Handled)
{
int x,y,w,h,dh;
int leftx,lefty,rightx,righty,value;
bool booldo = false;

   Handled = true;

   // Scroll
   if(cbWaferMap->Checked == true) {
      x = MousePos.x;
      y = MousePos.y;
      leftx = sbWaferMap->Left;
      lefty = sbWaferMap->Top;
      rightx = sbWaferMap->Left + sbWaferMap->Width - 1;
      righty = sbWaferMap->Top + sbWaferMap->Height - 1;
      if(x >= leftx && x <= rightx && y >= lefty && y <= righty) {
         int factor;
         factor = tbZoom->Position / 10;
         if(factor < 1)
            factor = 1;
         if(rgWheelDirection->ItemIndex == 0) {
            value = sbWaferMap->VertScrollBar->Position + (5*factor);
            if(value > imWaferMap->Height - (iBoxHeight+0))
               sbWaferMap->VertScrollBar->Position = imWaferMap->Height - (iBoxHeight+0);
            else
               sbWaferMap->VertScrollBar->Position += (5*factor);
         }
         else if(rgWheelDirection->ItemIndex == 1) {
            value = sbWaferMap->HorzScrollBar->Position + (5*factor);
            if(value > imWaferMap->Width - (iBoxWidth+0))
               sbWaferMap->HorzScrollBar->Position = imWaferMap->Width - (iBoxWidth+0);
            else
               sbWaferMap->HorzScrollBar->Position += (5*factor);
         }
         // 縮小
         else {
            if(tbZoom->Position < 200) {
               tbZoom->Position++;
               ZoomImage();
            }
         }
         //Sleep(100);
         AdjustCenterLine();
      }
      return;
   }

   dh = 30;

   // Z-
   x = MousePos.x;
   y = MousePos.y;

   // 對應到Form上
   int fx = frnMain->Left;
   int fy = frnMain->Top;
   x -= fx;
   y -= fy;

   w = pnlLeftMacroLamp->Width;
   h = pnlLeftMacroLamp->Height;
   leftx = pnlSystem->Left + pnlLeftMacroLamp->Left;
   lefty = pnlSystem->Top + pnlLeftMacroLamp->Top + dh;
   rightx = pnlSystem->Left + pnlRightMacroLamp->Left;
   righty = pnlSystem->Top + pnlRightMacroLamp->Top + dh;

   // Macro Light
   // Up
   if((x >= leftx && x <= (leftx+w)) && (y >= lefty && y <= (lefty+h))) {
      if(tbLED2CH1->Position > 2)
         tbLED2CH1->Position -= 2;
      else
         tbLED2CH1->Position = 0;
      booldo = true;
      pnlLED2CH1->Caption = IntToStr(tbLED2CH1->Position);
      LED2CH1Value = tbLED2CH1->Position;
      SetLED2Value(1,LED2CH1Value);
      return;
   }
   else if((x >= rightx && x <= (rightx+w)) && (y >= righty && y <= (righty+h))) {
      if(tbLED2CH2->Position > 2)
         tbLED2CH2->Position -= 2;
      else
         tbLED2CH2->Position = 0;
      booldo = true;
      pnlLED2CH2->Caption = IntToStr(tbLED2CH2->Position);
      LED2CH2Value = tbLED2CH2->Position;
      SetLED2Value(2,LED2CH2Value);
      return;
   }

   // 縮小
   if(pnlMaintenance->Visible == true && pcMaintenance->ActivePage == tsMainCCD) {
      leftx = pnlMaintenance->Left + pcMaintenance->Left + imOperation->Left;
      rightx = leftx + imOperation->Width;
      lefty = pnlMaintenance->Top + pcMaintenance->Top + imOperation->Top;
      righty = lefty + imOperation->Height;
      if(x >= leftx && x <= rightx && y >= lefty && y <= righty) {
         boolFormWheel = true;
         imDecClick(this);
         boolFormWheel = false;
      }   
   }

}
//---------------------------------------------------------------------------
// 2022 7 15 - chc Measure On/Off
void __fastcall TfrnMain::cbMeasureChange(TObject *Sender)
{

   if(cbMeasure->Checked == true) {
      pnlMeasureResult->Visible = true;
      mmMeasure->Visible = true;
   }
   else {
      pnlMeasureResult->Visible = false;
      mmMeasure->Visible = false;
   }
   shMeasure->Visible = false;
   shEllipse->Visible = false;
}
//---------------------------------------------------------------------------
// 2022 7 15 - chc 加入訊息 : mmMeasure
void __fastcall TfrnMain::AddMeasureMessage(AnsiString msg)
{
AnsiString putmsg;

   //putmsg = Now().FormatString("hh':'nn':'ss'-> '") + msg;
   //mmMeasure->Lines->Insert(0,putmsg);
   //if(lbMeasure->Lines->Count > 400) {
   //   for(int i=370 ; i<lbMeasure->Lines->Count ; i++)
   //      lbMeasure->Lines->Delete(i);
   //}

   // 2022 9 6 - chc 固定要清除, 否則速度會變慢!
   if(mmMeasure->Lines->Count > 400) {
      for(int i=320 ; i<mmMeasure->Lines->Count ; i++)
         mmMeasure->Lines->Delete(i);
   }

   mmMeasure->Lines->Insert(0,msg);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::mnClearClick(TObject *Sender)
{
        
   mmMeasure->Lines->Clear();
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::mnSaveFileClick(TObject *Sender)
{

AnsiString filename;

   spCCDImage->InitialDir = ExportDirectory;
   // 設定filtet
   spCCDImage->Filter = "TXT(*.txt)|*.txt";
   if(spCCDImage->Execute()) {
      // 改變副檔名
      filename = ChangeFileExt(spCCDImage->FileName,".txt");
      mmMeasure->Lines->SaveToFile(filename);
      pnlSystemMessage->Caption = "訊息已存檔.";
   }
}
//---------------------------------------------------------------------------
// Measure
void __fastcall TfrnMain::shMeasureMouseMove(TObject *Sender,
      TShiftState Shift, int X, int Y)
{
int gray,sx,sy,x,y;

   // 2016 10 14 - chc for Move
   x = X + shMeasure->Left - imCCD->Left;
   y = Y + shMeasure->Top - imCCD->Top;
   // 主畫面
   unsigned char r,g,b;
   TColor color;
   sx = 0;
   sy = 0;
   color = imCCD->Canvas->Pixels[x][y];
   b = (color & 0xff0000) >> 16;
   g = (color & 0x00ff00) >> 8;
   r = color & 0x0000ff;
   // 顯示游標值
   pnlCCDR->Caption = r;
   pnlCCDG->Caption = g;
   pnlCCDB->Caption = b;
   pnlCCDX->Caption = x + sx;
   pnlCCDY->Caption = y + sy;
   AnsiString str;
   str.sprintf("XY:(%d,%d)",x,y);
   sbSystem->Panels->Items[3]->Text = str;
   str.sprintf("RGB:(%3d,%3d,%3d)",r,g,b);
   sbSystem->Panels->Items[4]->Text = str;

   if(MeasureState == 1 && cbMeasure->Checked == true)
      imCCDMouseMove(this,Shift,X-imCCD->Left+shMeasure->Left, Y-imCCD->Top+shMeasure->Top);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::shMeasureMouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{
static long StartTime=-1,StopTime,Elapsedms;
static short StartTick,StopTick;

   // for double click
   if(StartTime == -1) {
      GetTimeTic(&StartTime,&StartTick);
   }
   else {
      GetTimeTic(&StopTime,&StopTick);
      Elapsedms = ((StopTime*1000+StopTick) - (StartTime*1000+StartTick));
      // Double Click
      if(Elapsedms < 400) {
         DoubleClickX = X + shMeasure->Left - imCCD->Left;
         DoubleClickY = Y + shMeasure->Top - imCCD->Top;
         imCCDDblClick(this);
      }
      StartTime = StopTime;
      StartTick = StopTick;
   }
   if(MeasureState == 1 && cbMeasure->Checked == true)
      imCCDMouseDown(this,Button,Shift,X-imCCD->Left+shMeasure->Left, Y-imCCD->Top+shMeasure->Top);

}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::shMeasureMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   //imCCDMouseUp(this,Button,Shift,X + shMeasure->Left - imCCD->Left,Y + shMeasure->Top - imCCD->Top);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::shEllipseMouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{
static long StartTime=-1,StopTime,Elapsedms;
static short StartTick,StopTick;

   // for double click
   if(StartTime == -1) {
      GetTimeTic(&StartTime,&StartTick);
   }
   else {
      GetTimeTic(&StopTime,&StopTick);
      Elapsedms = ((StopTime*1000+StopTick) - (StartTime*1000+StartTick));
      // Double Click
      if(Elapsedms < 400) {
         DoubleClickX = X + shMeasure->Left - imCCD->Left;
         DoubleClickY = Y + shMeasure->Top - imCCD->Top;
         imCCDDblClick(this);
      }
      StartTime = StopTime;
      StartTick = StopTick;
   }
   if(MeasureState == 1 && cbMeasure->Checked == true)
      imCCDMouseDown(this,Button,Shift,X-imCCD->Left+shMeasure->Left, Y-imCCD->Top+shMeasure->Top);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::shEllipseMouseMove(TObject *Sender,
      TShiftState Shift, int X, int Y)
{
int gray,sx,sy,x,y;

   // for Move
   x = X + shMeasure->Left - imCCD->Left;
   y = Y + shMeasure->Top - imCCD->Top;
   // 主畫面
   unsigned char r,g,b;
   TColor color;
   sx = 0;
   sy = 0;
   color = imCCD->Canvas->Pixels[x][y];
   b = (color & 0xff0000) >> 16;
   g = (color & 0x00ff00) >> 8;
   r = color & 0x0000ff;
   // 顯示游標值
   pnlCCDR->Caption = r;
   pnlCCDG->Caption = g;
   pnlCCDB->Caption = b;
   pnlCCDX->Caption = x + sx;
   pnlCCDY->Caption = y + sy;
   AnsiString str;
   str.sprintf("XY:(%d,%d)",x,y);
   sbSystem->Panels->Items[3]->Text = str;
   str.sprintf("RGB:(%3d,%3d,%3d)",r,g,b);
   sbSystem->Panels->Items[4]->Text = str;

   if(MeasureState == 1 && cbMeasure->Checked == true)
      imCCDMouseMove(this,Shift,X-imCCD->Left+shMeasure->Left, Y-imCCD->Top+shMeasure->Top);

}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::shEllipseMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   //imCCDMouseUp(this,Button,Shift,X + shMeasure->Left - imCCD->Left,Y + shMeasure->Top - imCCD->Top);
}
//---------------------------------------------------------------------------
// 2022 7 15 - chc 3points - circle
// (a,b), (c,d), (e,f)
// (cx,cy)
// a1=a-c
// b1=b-d
// c1=(a*a+b*b-c*c-d*d)/2
// a2=a-e
// b2=b-f
// c2=(a*a+b*b-e*e-f*f)/2
// cx=(c1*b2-c2*b1) / (c1*a2-c2*a1)
// cy=(c1*a2-c2*a1) / (b1*a2-b2*a1)
bool boolCircle = false;
#define MEASURE_CIRCLE         0
#define MEASURE_ANGLE          1
int MeasureMode;

// 點圓心長度
double CircleCX1=0,CircleCY1=0;
double CirclePX1=0,CirclePY1=0;
double CircleCX2=0,CircleCY2=0;
double CirclePX2=0,CirclePY2=0;

void __fastcall TfrnMain::btnCircleClick(TObject *Sender)
{

   pnlCircle->Left = 1118;
   pnlCircle->Top = 649;
   laMessage->Caption = "三點量測圓心與半徑/面積";
   pnlCircle->Visible = true;
   shCircle->Visible = false;
   pnlCircleP1Status->Color = clSilver;
   pnlCircleP2Status->Color = clSilver;
   pnlCircleP3Status->Color = clSilver;
   shPoint1->Visible = false;
   shPoint2->Visible = false;
   shPoint3->Visible = false;

   // Visible
   laCircleCenter->Visible = true;
   pnlCircleCenterX->Visible = true;
   pnlCircleCenterY->Visible = true;
   laCircleRadius->Visible = true;
   pnlCircleRadius->Visible = true;
   laCircleRadiusUnit->Visible = true;
   if(pnlUnit->Caption == "um")
      laCircleRadiusUnit->Caption = "um";
   else
      laCircleRadiusUnit->Caption = "mm";
   laCircleArea->Visible = true;
   if(pnlUnit->Caption == "um")
      pnlCircleArea->Caption = "um*um";
   else
      pnlCircleArea->Caption = "mm*mm";
   pnlCircleArea->Visible = true;
   laCircleAreaUnit->Visible = true;

   // 016 12 16 - chc 圓心編號
   rgCircleNo->Visible = true;

   // InVisible
   laAngle->Visible = false;
   pnlAngle->Visible = false;
   laAngleUnit->Visible = false;
   pnlAngle12->Visible = false;

   MeasureMode = MEASURE_CIRCLE;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnAngleClick(TObject *Sender)
{

   pnlCircle->Left = 1118;
   pnlCircle->Top = 649;
   laMessage->Caption = "三點量測夾角";
   pnlCircle->Visible = true;
   shCircle->Visible = false;
   pnlCircleP1Status->Color = clSilver;
   pnlCircleP2Status->Color = clSilver;
   pnlCircleP3Status->Color = clSilver;
   shPoint1->Visible = false;
   shPoint2->Visible = false;
   shPoint3->Visible = false;
   MeasureMode = MEASURE_ANGLE;

   // InVisible
   laCircleCenter->Visible = false;
   pnlCircleCenterX->Visible = false;
   pnlCircleCenterY->Visible = false;
   laCircleRadius->Visible = false;
   pnlCircleRadius->Visible = false;
   laCircleRadiusUnit->Visible = false;
   laCircleArea->Visible = false;
   pnlCircleArea->Visible = false;
   laCircleAreaUnit->Visible = false;

   // 圓心編號
   rgCircleNo->Visible = false;

   // Visible
   laAngle->Visible = true;
   pnlAngle->Visible = true;
   laAngleUnit->Visible = true;
   pnlAngle12->Visible = true;
}
//---------------------------------------------------------------------------
int MapX,MapY;

void __fastcall TfrnMain::mnPoint1Click(TObject *Sender)
{

   pnlCircleP1X->Caption = IntToStr(DoubleClickX);
   pnlCircleP1Y->Caption = IntToStr(DoubleClickY);
   pnlCircleP1Status->Color = clLime;
   shPoint1->Left = DoubleClickX + imCCD->Left - shPoint1->Width/2;
   shPoint1->Top = DoubleClickY + imCCD->Top - shPoint1->Height/2;
   if(cbPointSetDisplay->Checked == true)
      shPoint1->Visible = true;

   // 2016 12 16 - chc 加入說明
   pnlPoint1->Top = shPoint1->Top - pnlPoint1->Height - 2;
   pnlPoint1->Left = shPoint1->Left + shPoint1->Width + 2;
   if(cbPointSetDisplay->Checked == true)
      pnlPoint1->Visible = true;

   // 2022 8 8 - chc 獨立
   shDot1->Left = MapX;
   shDot1->Top = MapY;
   shDot1->Visible = true;

   // 2016 12 9 - chc Record
   // 2016 10 16 - chc 加入訊息 : AddMeasureMessage, mmMeasure
   //lbMeasure->Items->Add(AnsiString("第1點(X,Y): ") + IntToStr(DoubleClickX) + "," + IntToStr(DoubleClickY));
   if(MeasureMode == MEASURE_CIRCLE)
      AddMeasureMessage(AnsiString("圓第1點(X,Y)Pixel: ") + IntToStr(DoubleClickX) + "," + IntToStr(DoubleClickY));
   else
      AddMeasureMessage(AnsiString("角第1點(X,Y)Pixel: ") + IntToStr(DoubleClickX) + "," + IntToStr(DoubleClickY));

}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::mnPoint2Click(TObject *Sender)
{


   pnlCircleP2X->Caption = IntToStr(DoubleClickX);
   pnlCircleP2Y->Caption = IntToStr(DoubleClickY);
   pnlCircleP2Status->Color = clLime;
   shPoint2->Left = DoubleClickX + imCCD->Left - shPoint2->Width/2;
   shPoint2->Top = DoubleClickY + imCCD->Top - shPoint2->Height/2;
   if(cbPointSetDisplay->Checked == true)
      shPoint2->Visible = true;

   // 2016 12 16 - chc 加入說明
   pnlPoint2->Top = shPoint2->Top - pnlPoint2->Height - 2;
   pnlPoint2->Left = shPoint2->Left + shPoint2->Width + 2;
   if(cbPointSetDisplay->Checked == true)
      pnlPoint2->Visible = true;

   // 2022 8 8 - chc 獨立
   shDot2->Left = MapX;
   shDot2->Top = MapY;
   shDot2->Visible = true;

   // 2016 12 9 - chc Record
   // 2016 10 16 - chc 加入訊息 : AddMeasureMessage, mmMeasure
   //lbMeasure->Items->Add(AnsiString("第2點(X,Y): ") + IntToStr(DoubleClickX) + "," + IntToStr(DoubleClickY));
   if(MeasureMode == MEASURE_CIRCLE)
      AddMeasureMessage(AnsiString("圓第1點(X,Y)Pixel: ") + IntToStr(DoubleClickX) + "," + IntToStr(DoubleClickY));
   else
      AddMeasureMessage(AnsiString("角第1點(X,Y)Pixel: ") + IntToStr(DoubleClickX) + "," + IntToStr(DoubleClickY));
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::mnPoint3Click(TObject *Sender)
{

   pnlCircleP3X->Caption = IntToStr(DoubleClickX);
   pnlCircleP3Y->Caption = IntToStr(DoubleClickY);
   pnlCircleP3Status->Color = clLime;
   shPoint3->Left = DoubleClickX + imCCD->Left - shPoint3->Width/2;
   shPoint3->Top = DoubleClickY + imCCD->Top - shPoint3->Height/2;
   if(cbPointSetDisplay->Checked == true)
      shPoint3->Visible = true;

   // 2016 12 16 - chc 加入說明
   pnlPoint3->Top = shPoint3->Top - pnlPoint3->Height - 2;
   pnlPoint3->Left = shPoint3->Left + shPoint3->Width + 2;
   if(cbPointSetDisplay->Checked == true)
      pnlPoint3->Visible = true;

   // 2022 8 8 - chc 獨立
   shDot3->Left = MapX;
   shDot3->Top = MapY;
   shDot3->Visible = true;

   // 2016 12 9 - chc Record
   // 2016 10 16 - chc 加入訊息 : AddMeasureMessage, mmMeasure
   //lbMeasure->Items->Add(AnsiString("第3點(X,Y): ") + IntToStr(DoubleClickX) + "," + IntToStr(DoubleClickY));
   if(MeasureMode == MEASURE_CIRCLE)
      AddMeasureMessage(AnsiString("圓第3點(X,Y)Pixle: ") + IntToStr(DoubleClickX) + "," + IntToStr(DoubleClickY));
   else
      AddMeasureMessage(AnsiString("角第3點(X,Y)Pixel: ") + IntToStr(DoubleClickX) + "," + IntToStr(DoubleClickY));

}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnCircleComputeClick(TObject *Sender)
{
double a,b,c,d,e,f,a1,b1,c1,a2,b2,c2,r,area,cx,cy,resolution;
AnsiString msg;
double fx,fy;

   if(pnlCircleP1Status->Color == clSilver || pnlCircleP1Status->Color == clSilver || pnlCircleP1Status->Color == clSilver) {
      return;
   }

   // 校正值
   //fx = pnlXFactor->Caption.ToDouble();
   //fy = pnlYFactor->Caption.ToDouble();

   resolution = GetLensPrecision();
   a = pnlCircleP1X->Caption.ToDouble();
   b = pnlCircleP1Y->Caption.ToDouble();
   c = pnlCircleP2X->Caption.ToDouble();
   d = pnlCircleP2Y->Caption.ToDouble();
   e = pnlCircleP3X->Caption.ToDouble();
   f = pnlCircleP3Y->Caption.ToDouble();
   if(MeasureMode == MEASURE_CIRCLE) {
      a1 = a - c;
      b1 = b - d;
      c1 = (a*a + b*b - c*c - d*d) / 2;
      a2 = a - e;
      b2 = b - f;
      c2 = (a*a + b*b - e*e - f*f) / 2;
      cx = (c1*b2-c2*b1) / (a1*b2-a2*b1);
      cy = (c1*a2-c2*a1) / (a2*b1-a1*b2);
      msg.sprintf("%.1f",cx);
      pnlCircleCenterX->Caption = msg;
      msg.sprintf("%.1f",cy);
      pnlCircleCenterY->Caption = msg;
      r = sqrt((a-cx)*(a-cx) + (b-cy)*(b-cy));
      shCircle->Left = int(cx - r) + imCCD->Left;
      shCircle->Top = int(cy - r) + imCCD->Top;
      shCircle->Width = int(r*2);
      shCircle->Height = int(r*2);
      shCircle->Visible = true;
      r *= resolution;
      if(pnlUnit->Caption == "um")
         msg.sprintf("%.1f",r);
      else
         msg.sprintf("%.3f",r/1000.0);
      pnlCircleRadius->Caption = msg;
      area = M_PI * r * r;
      if(pnlUnit->Caption == "um")
         msg.sprintf("%.2f",area);
      else
         msg.sprintf("%.4f",area/(1000.0*1000.0));
      pnlCircleArea->Caption = msg;

      // 2016 12 9 - chc Add Measure Item
      if(MeasureState == 1 && cbMeasure->Checked == true) {
         if(pnlUnit->Caption == "um")
            msg.sprintf("面積(半徑): %.2fum*um(%.1fum)",area,r);
         else
            msg.sprintf("面積(半徑): %.4fmm*mm(%.3fmm)",area/(1000.0*1000.0),r/1000.0);

         // 2016 10 16 - chc 加入訊息 : AddMeasureMessage, mmMeasure
         //lbMeasure->Items->Add(msg);
         AddMeasureMessage(msg);

      }

      // 2016 12 9 - chc 點圓心長度
      int x,y;
      double tx,ty,resolution,len,dx,dy;
      int sx,sy;
      AnsiString msg;
      x = cx;
      y = cy;
      resolution = GetLensPrecision();
      tx = edCounterX->Text.ToDouble();
      ty = edCounterY->Text.ToDouble();
      sx = shVertical->Left - imCCD->Left;
      sy = shHorizontal->Top - imCCD->Top;
      tx += ((x-sx)*resolution/X_RESOLUTION);
      ty += ((y-sy)*resolution/Y_RESOLUTION);

      if(rgCircleNo->ItemIndex == 0) {
         CircleCX1 = tx;
         CircleCY1 = ty;
      }
      else {
         CircleCX2 = tx;
         CircleCY2 = ty;
      }

      // 2016 10 16 - chc 加入訊息 : AddMeasureMessage, mmMeasure
      //lbMeasure->Items->Add(AnsiString("圓心點(X,Y): ") + FloatToStr(tx) + "," + FloatToStr(ty));
      if(pnlUnit->Caption == "um") {
         if(rgCircleNo->ItemIndex == 0)
            AddMeasureMessage(AnsiString("圓心點1(X,Y)um: ") + FloatToStr(tx) + "," + FloatToStr(ty));
         else
            AddMeasureMessage(AnsiString("圓心點2(X,Y)um: ") + FloatToStr(tx) + "," + FloatToStr(ty));
      }
      else {
         if(rgCircleNo->ItemIndex == 0)
            AddMeasureMessage(AnsiString("圓心點1(X,Y)mm: ") + FloatToStr(tx/1000.0) + "," + FloatToStr(ty/1000.0));
         else
            AddMeasureMessage(AnsiString("圓心點2(X,Y)mm: ") + FloatToStr(tx/1000.0) + "," + FloatToStr(ty/1000.0));
      }

      if(rgCircleNo->ItemIndex == 0) {
         dx = fabs(CirclePX1 - CircleCX1);
         dy = fabs(CirclePY1 - CircleCY1);

         // 取得Factor
         //GetFactor(&fx,&fy,CirclePX1,CirclePY1,CircleCX1,CircleCY1);

      }
      else {
         dx = fabs(CirclePX2 - CircleCX2);
         dy = fabs(CirclePY2 - CircleCY2);

         // 取得Factor
         //GetFactor(&fx,&fy,CirclePX2,CirclePY2,CircleCX2,CircleCY2);

      }

      dx *= X_RESOLUTION;
      dy *= Y_RESOLUTION;

      // 2016 12 16 - chc 校正
      dx *= fx;
      dy *= fy;

      // 2018 1 7 - chc 使用fx,fy
      dx = fx * X_RESOLUTION;
      dy = fy * Y_RESOLUTION;

      len = sqrt(dx*dx + dy*dy);
      if(pnlUnit->Caption == "um") {
         if(rgCircleNo->ItemIndex == 0)
            msg.sprintf("點圓心1長(圓心1-點)um: %.1f(dx,dy)%.1f,%.1f",len,dx,dy);
         else
            msg.sprintf("點圓心2長(圓心2-點)um: %.1f(dx,dy)%.1f,%.1f",len,dx,dy);
      }
      else {
         if(rgCircleNo->ItemIndex == 0)
            msg.sprintf("點圓心1長(圓心1-點)mm: %.3f(dx,dy)%.3f,%.3f",len/1000.0,dx/1000.0,dy/1000.0);
         else
            msg.sprintf("點圓心2長(圓心2-點)mm: %.3f(dx,dy)%.3f,%.3f",len/1000.0,dx/1000.0,dy/1000.0);
      }

      // 2016 10 16 - chc 加入訊息 : AddMeasureMessage, mmMeasure
      //lbMeasure->Items->Add(msg);
      AddMeasureMessage(msg);

      pnlLineLength->Visible = true;
      pnlLineLength->Caption = msg;

      // 取得Factor
      //GetFactor(&fx,&fy,CircleCX1,CircleCY1,CircleCX2,CircleCY2);

      // 2016 12 16 - chc 計算兩個圓距離
      dx = fabs(CircleCX2 - CircleCX1);
      dy = fabs(CircleCY2 - CircleCY1);
      dx *= X_RESOLUTION;
      dy *= Y_RESOLUTION;
      // 校正
      dx *= fx;
      dy *= fy;

      // 2018 1 7 - chc 使用fx,fy
      dx = fx * X_RESOLUTION;
      dy = fy * Y_RESOLUTION;

      len = sqrt(dx*dx + dy*dy);
      if(pnlUnit->Caption == "um")
         msg.sprintf("兩圓心距離um: %.1f(dx,dy)%.1f,%.1f",len,dx,dy);
      else
         msg.sprintf("兩圓心距離mm: %.3f(dx,dy)%.3f,%.3f",len/1000.0,dx/1000.0,dy/1000.0);
      AddMeasureMessage(msg);

      // 2016 12 15 - chc 點出圓心位置
      // (cx,cy)為Pixel座標, 要轉成Table座標
      double fcmdx,fcmdy;
      int cmdx,cmdy,ox,oy;

      if(rgCircleNo->ItemIndex == 0) {
         shCircleCenter1->Left = cx + imCCD->Left - shCircleCenter1->Width/2;
         shCircleCenter1->Top = cy + imCCD->Top - shCircleCenter1->Height/2;
         shCircleCenter1->Visible = true;
         pnlCircleCenter1->Top = shCircleCenter1->Top - pnlCircleCenter1->Height - 2;
         pnlCircleCenter1->Left = shCircleCenter1->Left + shCircleCenter1->Width + 2;
         pnlCircleCenter1->Visible = true;
      }
      else {
         shCircleCenter2->Left = cx + imCCD->Left - shCircleCenter2->Width/2;
         shCircleCenter2->Top = cy + imCCD->Top - shCircleCenter2->Height/2;
         shCircleCenter2->Visible = true;
         pnlCircleCenter2->Top = shCircleCenter2->Top - pnlCircleCenter2->Height - 2;
         pnlCircleCenter2->Left = shCircleCenter2->Left + shCircleCenter2->Width + 2;
         pnlCircleCenter2->Visible = true;
      }

      // Command
      /*
      _8154_get_position(X_AXIS, &fcmdx);
      _8154_get_position(Y_AXIS, &fcmdy);
      // Center
      if(rgRelativePosition->ItemIndex == 0) {
         ox = edAOIX->Text.ToInt();
         oy = edAOIY->Text.ToInt();
      }
      // Load/UnLoad
      else if(rgRelativePosition->ItemIndex == 0) {
         ox = edLoadX->Text.ToInt();
         oy = edLoadY->Text.ToInt();
      }
      // Origin
      else {
         ox = edOriginalX->Text.ToInt();
         oy = edOriginalY->Text.ToInt();
      }
      fcmdx -= ox;
      fcmdy -= oy;
      // 要計算Pixel位置
      resolution = GetLensPrecision();
      dx = cx - sx;
      dy = cy - sy;
      fcmdx += ((dx * resolution) / X_RESOLUTION);
      fcmdy += ((dy * resolution) / Y_RESOLUTION);
      cmdx = fcmdx;
      cmdy = fcmdy;

      if(rgCircleNo->ItemIndex == 0) {
         CircleCenterX1 = cmdx;
         CircleCenterY1 = cmdy;
      }
      else {
         CircleCenterX2 = cmdx;
         CircleCenterY2 = cmdy;
      }
      */

   }
   // 角度
   else if(MeasureMode == MEASURE_ANGLE) {
      double dx1,dy1,dx2,dy2,value1,degree1,value2,degree2,degree;
      dx1 = a - c;
      dy1 = b - d;
      dx2 = e - c;
      dy2 = f - d;

      // 2016 12 21 - chc Y要反向
      dy1 = 0 - dy1;
      dy2 = 0 - dy2;

      if(dy1 != 0)
         value1 = (double)(dy1 / dx1);
      else
         value1 = 0;
      // radian
      degree1 = atan(value1);
      // degree
      degree1 = (360 * degree1) / (2*M_PI);
      if(dy2 != 0)
         value2 = (double)(dy2 / dx2);
      else
         value2 = 0;
      // radian
      degree2 = atan(value2);
      // degree
      degree2 = (360 * degree2) / (2*M_PI);
      degree = degree1 - degree2;
      msg.sprintf("%.4f",degree);
      pnlAngle->Caption = msg;
      msg.sprintf("%.4f, %.4f",degree1,degree2);
      pnlAngle12->Caption = msg;

      // 2016 12 9 - chc Add Measure Item
      if(MeasureState == 1 && cbMeasure->Checked == true) {
         msg.sprintf("角度: %.4f度",degree);

         // 2016 10 16 - chc 加入訊息 : AddMeasureMessage, mmMeasure
         //lbMeasure->Items->Add(msg);
         AddMeasureMessage(msg);

      }

   }
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnCircleExitClick(TObject *Sender)
{

   shCircle->Visible = false;
   pnlCircle->Visible = false;
   shPoint1->Visible = false;
   shPoint2->Visible = false;
   shPoint3->Visible = false;

   // 取消說明
   pnlPoint1->Visible = false;
   pnlPoint2->Visible = false;
   pnlPoint3->Visible = false;
}
//---------------------------------------------------------------------------
void __fastcall TfrnMain::Panel23Click(TObject *Sender)
{
static int cnt = 0;
TColor color;
AnsiString fname;
int no = 0;

   if((cnt % 2) == 0)
      color = clGreen;
   else
      color = clWhite;

   if(cnt == 0) {
      int width,height;
      // 要先指定大小, 否則會受限於imWaferMap->Width/Height
//      width = 2454;
//      height = 1887;
//      imWaferMap->Width = width;
//      imWaferMap->Height = height;
      //fname = "F:\\WindowsAP\\Olympus\\WLS3200\\Image\\0_-5.bmp";
      fname = "F:\\WindowsAP\\Olympus\\WLS3200\\Image\\10X_C.bmp";
      CCDInfoAry[no].Type = CCD_COLOR;
      if(CCDInfoAry[no].Type == CCD_BW) {
         CCDImageAry[no].Load(fname.c_str());
         width = CCDImageAry[no].GetWidth();
         height = CCDImageAry[no].GetHeight();
      }
      else {
         usb_ImageAry[no].Load(fname.c_str());
         width = usb_ImageAry[no].GetWidth();
         height = usb_ImageAry[no].GetHeight();
      }
      imWaferMap->Width = width;
      imWaferMap->Height = height;
      iImageWidth = width;
      iImageHeight = height;
      imWaferMap->Picture->LoadFromFile(fname);
   }

   //imGrid->Left = imCCD->Left;
   //imGrid->Top = imCCD->Top;
   //imGrid->Width = imCCD->Width;
   //imGrid->Height = imCCD->Height;

   //imGrid->Canvas->Pen->Color = color;
   //imGrid->Canvas->Pen->Style = psSolid;
   //imGrid->Canvas->Pen->Width = 5;
   //imGrid->Canvas->Pen->Mode = pmNot;   // pmCopy;
   //imGrid->Canvas->MoveTo(100,100);
   //imGrid->Canvas->LineTo(700,700);

   imCCD->Canvas->Pen->Color = color;
   imCCD->Canvas->Pen->Style = psSolid;
   imCCD->Canvas->Pen->Width = 5;
   imCCD->Canvas->Pen->Mode = pmNot;   // pmCopy;
   imCCD->Canvas->MoveTo(100,100);
   imCCD->Canvas->LineTo(700,700);
   cnt++;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::cbWaferMapClick(TObject *Sender)
{

   if(cbWaferMap->Checked == true) {
      sbWaferMap->Visible = cbWaferMap->Checked;
      if(Wafer.boolSet == true)
         tbZoom->Visible = cbWaferMap->Checked;
   }
   else {
      sbWaferMap->Visible = cbWaferMap->Checked;
      tbZoom->Visible = cbWaferMap->Checked;
   }
}
//---------------------------------------------------------------------------
void __fastcall TfrnMain::InitWaferMap()
{

   Wafer.boolSet = false;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::imWaferMapMouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   MapX = X;
   MapY = Y;

   if(MeasureState == 0 && cbMeasure->Checked == true) {
      pnlMeasureResult->Caption = "";
      MeasureState = 1;
      Mx1 = X;
      My1 = Y;
      //shMeasure->Visible = true;
      //shMeasure->Left = X + imCCD->Left;
      //shMeasure->Top = Y + imCCD->Top;
      //shMeasure->Width = 2;
      //shMeasure->Height = 2;
   }
   else if(MeasureState == 1 && cbMeasure->Checked == true) {
      MeasureState = 2;
      Mx2 = X;
      My2 = Y;
      MeasureState = 0;
      double wvalue,hvalue,lvalue,dx;
      AnsiString msg;
      int factor;
      factor = tbZoom->Position / 10;
      if(factor < 1)
         factor = 1;
      dx = GetLensPrecision() / factor;
      // Width
      wvalue = (abs(Mx2 - Mx1)+1) * dx;
      // Height
      hvalue = (abs(My2 - My1)+1) * dx;
      // Length
      lvalue = sqrt((Mx2-Mx1)*(Mx2-Mx1) + (My2-My1)*(My2-My1)) * dx;
      if(pnlUnit->Caption == "um")
         msg.sprintf("(um)W:%.2f  H:%.2f  L:%.2f  A:%.2f  a:%.2f",wvalue,hvalue,lvalue,wvalue*hvalue,((wvalue*hvalue)/4)*M_PI);
      else {
         wvalue /= MM_TO_UM;
         hvalue /= MM_TO_UM;
         lvalue /= MM_TO_UM;
         msg.sprintf("(mm)W:%.3f  H:%.3f  L:%.3f  A:%.4f  a:%.4f",wvalue,hvalue,lvalue,wvalue*hvalue,((wvalue*hvalue)/4)*M_PI);
      }
      pnlMeasureResult->Caption = msg;
      AddMeasureMessage(AnsiString("長度: ") + pnlMeasureResult->Caption);
      //shMeasure->Visible = false;
      //shEllipse->Left = shMeasure->Left;
      //shEllipse->Top = shMeasure->Top;
      //shEllipse->Width = shMeasure->Width;
      //shEllipse->Height = shMeasure->Height;
      //shEllipse->Visible = true;

//pmBlack：表示用黑色繪圖；
//pmWhite：表示用白色繪圖；
//pmNot：畫筆繪製的點的顏色與原有的顏色相反；
//pmCopy：畫筆用Color屬性中定義的顏色繪圖。
//PmNotCopy：畫筆用Color屬性中定義的顏色的反轉色繪圖；
//PmMergePenNot：畫筆用Color屬性中定義的顏色與螢幕顏色的反轉色結合後繪圖；
//PmMaskNotPen：畫筆用螢幕顏色與Color屬性中定義的顏色結合後繪圖；
//PmMergeNotPen：畫筆用螢幕顏色與Color屬性中定義的顏色的反轉值結合後繪圖。
      if(factor > 1) 
         imWaferMap->Canvas->Pen->Color = clBlue;
      else
         imWaferMap->Canvas->Pen->Color = clLime;
      imWaferMap->Picture->Bitmap->PixelFormat = pf24bit;
      imWaferMap->Canvas->Pen->Style = psSolid;
      imWaferMap->Canvas->Pen->Width = 1;
      imWaferMap->Canvas->Pen->Mode = pmCopy;
      imWaferMap->Canvas->MoveTo(Mx1/factor,My1/factor);
      imWaferMap->Canvas->LineTo(Mx2/factor,My2/factor);

   }

}
//---------------------------------------------------------------------------
// 2022 7 16 - chc 偏移量
int COffsetX,COffsetY;
// 原點位置
int GridNoX;
int GridNoY;
int MinRow = -1;
int MinCol = -1;
int MaxRow = -1;
int MaxCol = -1;
// 指定點
int SelectRow = -1;
int SelectCol = -1;
// 中心Die座標
int CenterDieRow = -1;
int CenterDieCol = -1;
void __fastcall TfrnMain::imWaferMapMouseMove(TObject *Sender,
      TShiftState Shift, int X, int Y)
{
int gray,sx,sy;

   // 主畫面
   unsigned char r,g,b;
   TColor color;
   sx = 0;
   sy = 0;
   color = imWaferMap->Canvas->Pixels[X][Y];
   b = (color & 0xff0000) >> 16;
   g = (color & 0x00ff00) >> 8;
   r = color & 0x0000ff;
   // 顯示游標值
   pnlCCDR->Caption = r;
   pnlCCDG->Caption = g;
   pnlCCDB->Caption = b;
   pnlCCDX->Caption = X + sx;
   pnlCCDY->Caption = Y + sy;
   AnsiString str;
   str.sprintf("XY:(%d,%d)",X,Y);
   sbSystem->Panels->Items[3]->Text = str;
   str.sprintf("RGB:(%3d,%3d,%3d)",r,g,b);
   sbSystem->Panels->Items[4]->Text = str;
   if(Wafer.boolSet == true) {
      int col,row;

      // 2021 8 24 - chc 偏移量
      //col = (X - Wafer.X) / Wafer.Dx;
      //row = (Y - Wafer.Y) / Wafer.Dy;
      col = (X - COffsetX - Wafer.X) / Wafer.Dx;
      row = (Y - COffsetY - Wafer.Y) / Wafer.Dy;
      if(X < (COffsetX + Wafer.X))
         col = -1;
      if(Y < (COffsetY + Wafer.Y))
         row = -1;

      // 2021 9 27 - chc 原點位置: GridNoY
      // 下: 180
      if(rgWaferDegree->ItemIndex == 2) {
         row = GridNoY - row - 1;

         // 2021 12 15 - chc 最小Row,Col
         col -= MinCol;
         row -= (GridNoY - MinRow - 1);

      }

      pnlColum->Caption = IntToStr(col);
      pnlRow->Caption = IntToStr(row);
   }
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::sbWaferMapMouseWheel(TObject *Sender,
      TShiftState Shift, int WheelDelta, TPoint &MousePos, bool &Handled)
{

   return;
   sbWaferMap->VertScrollBar->Position -= 10;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::sbWaferMapMouseWheelDown(TObject *Sender,
      TShiftState Shift, TPoint &MousePos, bool &Handled)
{

   //sbWaferMap->VertScrollBar->Position += 10;
   int value;
   if(rgWheelDirection->ItemIndex == 0) {
      value = sbWaferMap->VertScrollBar->Position + 10;
      if(value > imWaferMap->Height - (iBoxHeight+0))
         sbWaferMap->VertScrollBar->Position = imWaferMap->Height - (iBoxHeight+0);
      else
         sbWaferMap->VertScrollBar->Position += 10;
   }
   else {
      value = sbWaferMap->HorzScrollBar->Position + 10;
      if(value > imWaferMap->Width - (iBoxWidth+0))
         sbWaferMap->HorzScrollBar->Position = imWaferMap->Height - (iBoxWidth+0);
      else
         sbWaferMap->HorzScrollBar->Position += 10;
   }
   AdjustCenterLine();
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::tbZoomMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{
AnsiString msg;

   return;
   ZoomImage();
   Sleep(100);
   AdjustCenterLine();
   int no;
   no = tbZoom->Position/10;
   if(no < 1)
      no = 1;
   msg.sprintf("%dX:%.4f",no,CCDPrecision/no);
   pnlFactor->Caption = msg;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::ZoomImage()
{
int bw,bh,dx,dy,factor,gridnox,gridnoy,width,height;
AnsiString fname,msg;
int iw,ih,w,h,cx,cy;

   //iw = 2454;
   //ih = 1887;
   iw = iImageWidth;
   ih = iImageHeight;

   int x,y;
   static int oldfactor = 1;
   static int newfactor = 1;
   newfactor = tbZoom->Position / 10;
   if(newfactor < 1)
      newfactor = 1;
   msg.sprintf("%dX:%.4f",newfactor,CCDPrecision/newfactor);
   pnlFactor->Caption = msg;
   y = sbWaferMap->VertScrollBar->Position;
   x = sbWaferMap->HorzScrollBar->Position;
   //if(newfactor != oldfactor) {
   //   sbWaferMap->VertScrollBar->Position = 0;
   //   sbWaferMap->HorzScrollBar->Position = 0;
   //}

   // bw,bh: imWaferMap的大小
   bw = sbWaferMap->Width;
   bh = sbWaferMap->Height;

   factor = tbZoom->Position / 10;
   if(factor < 1)
      factor = 1;
   gridnox = 10;
   gridnoy = 10;

   // dx,dy: Die的實際大小(有倍率)
   dx = (850*factor) / gridnox;
   dy = (850*factor) / gridnoy;

   // width,height: Mapper圖的實際大小(有倍率)
   width = gridnox * dx;
   height = gridnoy * dy;

   width = iw * factor;
   height = ih * factor;

   // 整個imWaferMap區域均可以畫
   imWaferMap->Width = width;
   imWaferMap->Height = height;
   //imWaferMap->Picture->Bitmap->Width = width;
   //imWaferMap->Picture->Bitmap->Height = height;
   //fname = "F:\\WindowsAP\\Olympus\\WLS3200\\Image\\0_-5.bmp";
   //imWaferMap->Picture->LoadFromFile(fname);

   // 維持中心點: 用中心點
   if(newfactor != oldfactor) {
      Sleep(50);
      cx = x + (sbWaferMap->Width-21) / 2;
      cy = y + (sbWaferMap->Height-21) / 2;
      x = cx*newfactor/oldfactor - (sbWaferMap->Width-21) / 2;
      y = cy*newfactor/oldfactor - (sbWaferMap->Height-21) / 2;

      sbWaferMap->VertScrollBar->Position = y;
      sbWaferMap->HorzScrollBar->Position = x;
      oldfactor = newfactor;
   }

}
//---------------------------------------------------------------------------
int ModeState = 0;
void __fastcall TfrnMain::rgModeChange(TObject *Sender, int ButtonIndex)
{

   rgMode->Enabled = false;
   btnModeRun->Enabled = true;
   if(rgMode->ItemIndex == 0)
      btnModeRun->Caption = "正常模式開始";
   else if(rgMode->ItemIndex == 1)
      btnModeRun->Caption = "量測模式開始";
   else if(rgMode->ItemIndex == 2)
      btnModeRun->Caption = "Wafer Map開始";
   else if(rgMode->ItemIndex == 3)
      btnModeRun->Caption = "Recipe Run開始";
   else if(rgMode->ItemIndex == 4)
      btnModeRun->Caption = "Demo Loop開始";
   ModeState = 1;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnModeRunClick(TObject *Sender)
{
int no,width,height;
AnsiString fname,msg;

   no = 0;
   if(ModeState == 1) {
      ModeState = 2;
      if(rgMode->ItemIndex == 0)
         btnModeRun->Caption = "正常模式結束";
      else if(rgMode->ItemIndex == 1)
         btnModeRun->Caption = "量測模式結束";
      else if(rgMode->ItemIndex == 2)
         btnModeRun->Caption = "Wafer Map結束";
      else if(rgMode->ItemIndex == 3)
         btnModeRun->Caption = "Recipe Run結束";
      else if(rgMode->ItemIndex == 4)
         btnModeRun->Caption = "Demo Loop結束";

      // Wafer Map
      if(rgMode->ItemIndex == 0) {
         sbWaferMap->Visible = false;
         pnlHorizontal->Visible = false;
         pnlVertical->Visible = false;
         btnLoadMeasureImage->Enabled = false;
      }
      // 量測: Grab/LoadImage, 進行量測
      else if(rgMode->ItemIndex == 1) {
         //fname = "F:\\WindowsAP\\Olympus\\WLS3200\\Image\\10X_C.bmp";
         //CCDInfoAry[no].Type = CCD_COLOR;
         sbWaferMap->Visible = true;
         pnlHorizontal->Visible = true;
         pnlVertical->Visible = true;
         btnLoadMeasureImage->Enabled = true;
         tbZoom->Position = 10;
         msg.sprintf("%dX:%.4f",1,CCDPrecision);
         pnlFactor->Caption = msg;
         cbWaferMap->Checked = true;
         //cbWaferMapClick(this);
         if(bool_CCD_StatusAry[no] == true) {
            sbWaferMap->VertScrollBar->Position = 0;
            sbWaferMap->HorzScrollBar->Position = 0;
            if(CCDInfoAry[no].Type == CCD_COLOR) {
               //usb_ImageAry[no].Load(fname.c_str());
               width = usb_ImageAry[no].GetWidth();
               height = usb_ImageAry[no].GetHeight();
               WriteSystemLog("Color CCD: " + IntToStr(width) + "," + IntToStr(height));
               imWaferMap->Width = width;
               imWaferMap->Height = height;
               iImageWidth = width;
               iImageHeight = height;
               usb_ImageAry[no].Draw(imWaferMap->Canvas->Handle);
            }
            else {
               //CCDImageAry[no].Load(fname.c_str());
               width = CCDImageAry[no].GetWidth();
               height = CCDImageAry[no].GetHeight();
               WriteSystemLog("Gray CCD: " + IntToStr(width) + "," + IntToStr(height));
               imWaferMap->Width = width;
               imWaferMap->Height = height;
               iImageWidth = width;
               iImageHeight = height;
               CCDImageAry[no].Draw(imWaferMap->Canvas->Handle);
            }
         }
      }
      // Wafer Map
      else if(rgMode->ItemIndex == 2) {
         sbWaferMap->Visible = true;
         pnlHorizontal->Visible = true;
         pnlVertical->Visible = true;
         btnLoadMeasureImage->Enabled = false;
      }
      // Recipe Run
      else if(rgMode->ItemIndex == 3) {
         sbWaferMap->Visible = false;
         pnlHorizontal->Visible = false;
         pnlVertical->Visible = false;
         btnLoadMeasureImage->Enabled = false;
      }
      // Demo Loop
      else if(rgMode->ItemIndex == 4) {
         sbWaferMap->Visible = false;
         pnlHorizontal->Visible = false;
         pnlVertical->Visible = false;
         btnLoadMeasureImage->Enabled = false;
      }

   }
   else if(ModeState == 2) {
      ModeState = 0;
      btnModeRun->Enabled = false;
      rgMode->Enabled = true;
      if(rgMode->ItemIndex == 0)
         btnModeRun->Caption = "正常模式開始";
      else if(rgMode->ItemIndex == 1) {
         btnModeRun->Caption = "量測模式開始";
         btnLoadMeasureImage->Enabled = false;
      }
      else if(rgMode->ItemIndex == 2)
         btnModeRun->Caption = "Wafer Map開始";
      else if(rgMode->ItemIndex == 3)
         btnModeRun->Caption = "Recipe Run開始";
      else if(rgMode->ItemIndex == 4)
         btnModeRun->Caption = "Demo Loop開始";
   }
}
//---------------------------------------------------------------------------
// 2022 7 18 - chc GigE CCD : scA1300-gc 由Thread呼叫
void __fastcall TfrnMain::GigaCapture1()
{
int no;
GENAPIC_RESULT res;                    // Return value of pylon methods.

   no = 0;
   // 加入取像時間顯示
   GetTimeTic(&BaslerCaptureStartTimeAry[no],&BaslerCaptureStartTickAry[no]);
   //lbGiga->Items->Add("Trigger CCD1...");
   res = PylonDeviceGrabSingleFrame(hDevGigaAry[no], 0, imgBufAry[no], CCDInfoAry[no].TotalSize, &grabResultAry[no], &bufferReadyAry[no], 1000);
   //lbGiga->Items->Add("Trigger CCD1: " + IntToStr(res) + "," + IntToStr(GENAPI_E_OK));

   if(GENAPI_E_OK == res && !bufferReadyAry[no]) {
      // Timeout occurred.
      AnsiString msg;
      static int count = 0;
      msg.sprintf("Frame1 %d: timeout\n", count+1);
      lbGiga->Items->Add(msg);
      pnlSystemMessage->Caption = msg;
   }

}
//---------------------------------------------------------------------------
// 2022 7 18 - chc GigE CCD : scA1300-gm 由Thread呼叫
void __fastcall TfrnMain::GigaCapture2()
{
int no;
GENAPIC_RESULT res;                    // Return value of pylon methods.

   no = 1;
   // 加入取像時間顯示
   GetTimeTic(&BaslerCaptureStartTimeAry[no],&BaslerCaptureStartTickAry[no]);
   //lbGiga->Items->Add("Trigger CCD...");
   res = PylonDeviceGrabSingleFrame(hDevGigaAry[no], 0, imgBufAry[no], CCDInfoAry[no].TotalSize, &grabResultAry[no], &bufferReadyAry[no], 1000);
   //lbGiga->Items->Add("Trigger CCD: " + IntToStr(res) + "," + IntToStr(GENAPI_E_OK));

   if(GENAPI_E_OK == res && !bufferReadyAry[no]) {
      // Timeout occurred.
      AnsiString msg;
      static int count = 0;
      msg.sprintf("Frame2 %d: timeout\n", count+1);
      lbGiga->Items->Add(msg);
      pnlSystemMessage->Caption = msg;
   }

}
//---------------------------------------------------------------------------
// 2022 7 18 - chc GigE CCD : scA1300-gm 由Thread呼叫
void __fastcall TfrnMain::GigaCapture3()
{
int no;
GENAPIC_RESULT res;                    // Return value of pylon methods.

   no = 2;
   // 加入取像時間顯示
   GetTimeTic(&BaslerCaptureStartTimeAry[no],&BaslerCaptureStartTickAry[no]);
   //lbGiga->Items->Add("Trigger CCD...");
   res = PylonDeviceGrabSingleFrame(hDevGigaAry[no], 0, imgBufAry[no], CCDInfoAry[no].TotalSize, &grabResultAry[no], &bufferReadyAry[no], 1000);
   //lbGiga->Items->Add("Trigger CCD: " + IntToStr(res) + "," + IntToStr(GENAPI_E_OK));

   if(GENAPI_E_OK == res && !bufferReadyAry[no]) {
      // Timeout occurred.
      AnsiString msg;
      static int count = 0;
      msg.sprintf("Frame3 %d: timeout\n", count+1);
      lbGiga->Items->Add(msg);
      pnlSystemMessage->Caption = msg;
   }

}
//---------------------------------------------------------------------------
// 2022 7 18 - chc 不同CCD對應不同的程式碼
void __fastcall TfrnMain::GigaBuffer3(int ccdtype)
{

   CaptureGigaFrame3(3,ccdtype);
}
//---------------------------------------------------------------------------
// 2022 7 18 - chc 不同CCD對應不同的程式碼
void __fastcall TfrnMain::GigaBuffer2(int ccdtype)
{

   CaptureGigaFrame2(2,ccdtype);
}
//---------------------------------------------------------------------------
// 2022 7 18 - chc 不同CCD對應不同的程式碼
void __fastcall TfrnMain::GigaBuffer1(int ccdtype)
{

   CaptureGigaFrame1(1,ccdtype);
}
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
static int Table_fv1[256] = { -180, -179, -177, -176, -174, -173, -172, -170, -169, -167, -166, -165, -163, -162, -160, -159, -158, -156, -155,
                              -153, -152, -151, -149, -148, -146, -145, -144, -142, -141, -139, -138, -137,  -135, -134, -132, -131, -130, -128,
                              -127, -125, -124, -123, -121, -120, -118, -117, -115, -114, -113, -111, -110, -108, -107, -106, -104, -103, -101,
                              -100, -99, -97, -96, -94, -93, -92, -90,  -89, -87, -86, -85, -83, -82, -80, -79, -78, -76, -75, -73, -72, -71,
                              -69, -68, -66, -65, -64,-62, -61, -59, -58, -57, -55, -54, -52, -51, -50, -48, -47, -45, -44, -43, -41, -40, -38,
                              -37,  -36, -34, -33, -31, -30, -29, -27, -26, -24,
                              -23, -22, -20, -19, -17, -16, -15, -13, -12, -10, -9, -8, -6, -5, -3, -2, 0, 1, 2, 4, 5, 7, 8, 9, 11, 12, 14, 15,
                              16, 18, 19, 21, 22, 23, 25, 26, 28, 29, 30, 32, 33, 35, 36, 37, 39, 40, 42, 43, 44, 46, 47, 49, 50, 51, 53, 54,
                              56, 57, 58, 60, 61, 63, 64, 65, 67, 68, 70, 71, 72, 74, 75, 77, 78, 79, 81, 82, 84, 85, 86, 88, 89, 91, 92, 93,
                              95, 96, 98, 99, 100, 102, 103, 105, 106, 107, 109, 110, 112, 113, 114, 116, 117, 119, 120, 122, 123, 124, 126,
                              127, 129, 130, 131, 133, 134, 136, 137, 138, 140, 141, 143, 144, 145, 147, 148,  150, 151, 152, 154, 155, 157,
                              158, 159, 161, 162, 164, 165, 166, 168, 169, 171, 172, 173, 175, 176, 178 };
static int Table_fv2[256] = { -92, -91, -91, -90, -89, -88, -88, -87, -86, -86, -85, -84, -83, -83, -82, -81, -81, -80, -79, -78, -78, -77,
                              -76, -76, -75, -74, -73, -73, -72, -71, -71, -70, -69, -68, -68, -67, -66, -66, -65, -64, -63, -63, -62, -61,
                              -61, -60, -59, -58, -58, -57, -56, -56, -55, -54, -53, -53, -52, -51, -51, -50, -49, -48, -48, -47, -46, -46,
                              -45, -44, -43, -43, -42, -41, -41, -40, -39, -38, -38, -37, -36, -36, -35, -34, -33, -33, -32, -31, -31, -30,
                              -29, -28, -28, -27, -26, -26, -25, -24, -23, -23, -22, -21, -21, -20, -19, -18, -18, -17, -16, -16, -15, -14,
                              -13, -13, -12, -11, -11, -10, -9, -8, -8, -7, -6, -6, -5, -4, -3,
                              -3, -2, -1, 0, 0, 1, 2, 2, 3, 4, 5, 5, 6, 7, 7, 8, 9, 10, 10, 11, 12, 12, 13, 14, 15, 15, 16, 17, 17, 18, 19,
                              20, 20, 21, 22, 22, 23, 24, 25, 25, 26, 27, 27, 28, 29, 30, 30, 31, 32, 32, 33, 34, 35, 35, 36, 37, 37, 38, 39,
                              40, 40, 41, 42, 42, 43, 44, 45, 45, 46, 47, 47, 48, 49, 50, 50, 51, 52, 52, 53, 54, 55, 55, 56, 57, 57, 58, 59,
                              60, 60, 61, 62, 62, 63, 64, 65, 65, 66, 67, 67, 68, 69, 70, 70, 71, 72, 72, 73, 74, 75, 75, 76, 77, 77, 78, 79,
                              80, 80, 81, 82, 82, 83, 84, 85, 85, 86, 87, 87, 88, 89, 90, 90 };
static int Table_fu1[256] = { -44, -44, -44, -43, -43, -43, -42, -42, -42, -41, -41, -41, -40, -40, -40, -39, -39, -39, -38, -38, -38, -37,
                              -37, -37, -36, -36, -36, -35, -35, -35, -34, -34, -33, -33, -33, -32, -32, -32, -31, -31, -31, -30, -30, -30,
                              -29, -29, -29, -28, -28, -28, -27, -27, -27, -26, -26, -26, -25, -25, -25, -24, -24, -24, -23, -23, -22, -22,
                              -22, -21, -21, -21, -20, -20, -20, -19, -19, -19, -18, -18, -18, -17, -17, -17, -16, -16, -16, -15, -15, -15,
                              -14, -14, -14, -13, -13, -13, -12, -12, -11, -11, -11, -10, -10, -10, -9, -9, -9, -8, -8, -8, -7, -7, -7, -6,
                              -6, -6, -5, -5, -5, -4, -4, -4, -3, -3, -3, -2, -2, -2, -1, -1, 0,
                              0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 11, 11, 11, 12,
                              12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 19, 20, 20, 20, 21, 21,
                              22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 27, 27, 27, 28, 28, 28, 29, 29, 29, 30, 30, 30, 31,
                              31, 31, 32, 32, 33, 33, 33, 34, 34, 34, 35, 35, 35, 36, 36, 36, 37, 37, 37, 38, 38, 38, 39, 39, 39, 40, 40, 40,
                              41, 41, 41, 42, 42, 42, 43, 43 };
static int Table_fu2[256] = { -227, -226, -224, -222, -220, -219, -217, -215, -213, -212, -210, -208, -206, -204, -203, -201, -199, -197, -196,
                              -194, -192, -190, -188, -187, -185, -183, -181, -180, -178, -176, -174, -173, -171, -169, -167, -165, -164, -162,
                              -160, -158, -157, -155, -153, -151, -149, -148, -146, -144, -142, -141, -139, -137, -135, -134, -132, -130, -128,
                              -126, -125, -123, -121, -119, -118, -116, -114, -112, -110, -109, -107, -105, -103, -102, -100, -98, -96, -94,
                              -93, -91, -89, -87, -86, -84, -82, -80, -79, -77, -75, -73, -71, -70, -68, -66, -64, -63, -61, -59, -57, -55,
                              -54, -52, -50, -48, -47, -45, -43, -41, -40, -38, -36,
                              -34, -32, -31, -29, -27, -25, -24, -22, -20, -18, -16, -15, -13, -11, -9, -8, -6, -4, -2, 0, 1, 3, 5, 7, 8, 10, 12,
                              14, 15, 17, 19, 21, 23, 24, 26, 28, 30, 31, 33, 35, 37, 39, 40, 42, 44, 46, 47, 49, 51, 53, 54, 56, 58, 60, 62, 63,
                              65, 67, 69, 70, 72, 74, 76, 78, 79, 81, 83, 85, 86, 88, 90, 92, 93, 95, 97, 99, 101, 102, 104, 106, 108, 109, 111,
                              113, 115, 117, 118, 120, 122, 124, 125, 127, 129, 131, 133, 134, 136, 138, 140, 141, 143, 145, 147, 148, 150, 152,
                              154, 156, 157, 159, 161, 163, 164, 166, 168, 170, 172, 173, 175, 177, 179, 180, 182, 184, 186, 187, 189, 191, 193,
                              195, 196, 198, 200, 202, 203, 205, 207, 209, 211, 212, 214, 216, 218, 219, 221, 223, 225 };

// 2022 7 18 - chc 新寫法, GigE CCD : 取得影像並顯示(BW/Color)
//   #define CCD_BW                0
//   #define CCD_COLOR             1
//   int BaslerCCDType[3];
// mode : 0 - 要呼叫 PylonDeviceGrabSingleFrame()
//        1 - 不要呼叫 PylonDeviceGrabSingleFrame()
void __fastcall TfrnMain::CaptureGigaFrame1(int no, int mode)
{
static int count = 0;
AnsiString msg;
int width,height,sx,sy,x,y,w,h;
static bool first = false;

   // Index
   pnlCCDStatus->Color = clSilver;
   no--;

   width = CCDInfoAry[no].Width;
   height = CCDInfoAry[no].Height;
   w = imCCD->Width;
   h = imCCD->Height;

   // 2016 5 26 - chc Lasr Cneter
   //sx = (width - w) / 2;
   //sy = (height - h) / 2;
   sx = LaserCenterX;
   sy = LaserCenterY;

   // 2016 10 30 - chc Check Range
   CheckRange(&sx,&sy);

   //lbGiga->Items->Add("CCD1進入取像...");
   // 在影像處理中
   boolInGigaBufferAry[no] = true;

   // Check to see if the image was grabbed successfully.
   if(grabResultAry[no].Status == Grabbed) {
      count++;
      unsigned char *pt,*pt1;
      int i;
      int pointer;
      // 1278*958 - 1294*964
      if(grabResultAry[no].SizeX != CCDInfoAry[no].Width || grabResultAry[no].SizeY != CCDInfoAry[no].Height) {
         lbGiga->Items->Add("Size1 Error!");
         pnlSystemMessage->Caption = "Size1 Error!";
         // 在影像處理中
         boolInGigaBufferAry[no] = false;
         pnlCCDStatus->Color = clRed;

         // 2015 9 8 - chc Log
         WriteSystemLog("CaptureGigaFrame1() RealSize Error!" + IntToStr(grabResultAry[no].SizeX) + "," + IntToStr(grabResultAry[no].SizeY));
         WriteSystemLog("CaptureGigaFrame1() SensorSize Error!" + IntToStr(CCDInfoAry[no].Width) + "," + IntToStr(CCDInfoAry[no].Height));

         return;
      }
      i = 0;
      // 記錄Basler存檔中...
      if(boolInGigaSaveAry[no] == true) {
         //lbGiga->Items->Add("存檔中, 不更新影像");
         pnlSystemMessage->Caption = "Saving1 Image...";
         boolInGigaBufferAry[no] = false;
         return;
      }
      pnlCCDStatus->Color = clLime;

      // Log
      //lbGiga->Items->Add("CCD1進入取像2...");

      // 全取: 要區分BW/C24
      // BW : CCDImageAry
      if(CCDInfoAry[no].Type == CCD_BW) {

         // Log
         //lbGiga->Items->Add("CCD1進入取像2BW...");

         i = 0;
         for(int row=0 ; row<grabResultAry[no].SizeY ; row++) {
            pt = (unsigned char *)CCDImageAry[no].GetImagePtr(0,row);
            memcpy(pt,&imgBufAry[no][i],grabResultAry[no].SizeX);
            i += grabResultAry[no].SizeX;
         }
         // 要顯示在主畫面 ###@@@
         GetImageXY(width,height,sx,sy,w,h,&x,&y);
         CCDImageROIAry[no].SetPlacement(x,y,w,h);
         CCDImageROIAry[no].Draw(imCCD->Canvas->Handle);
         // 若沒有Refresh就不會顯示
         imCCD->Refresh();
      }
      // Color : usb_ImageAry
      else {

         // Log
         //lbGiga->Items->Add("CCD1進入取像2Color... " + IntToStr(grabResultAry[no].SizeX) + "," + IntToStr(grabResultAry[no].SizeY));
         //lbGiga->Items->Add("CCD Size: " + IntToStr((int)grabResultAry[no].PayloadSize));

         // 2016 4 16 - chc 寫入檔案: YUV422
         /*
         FILE *fp;
         i = 0;
         static boolsave = false;
         if(boolsave == false) {
            if((fp = fopen("D:\\test.yuv","wb")) != NULL) {
               for(int row=0 ; row<grabResultAry[no].SizeY ; row++) {
                  fwrite((void *)&imgBufAry[no][i],1,grabResultAry[no].SizeX*2,fp);
                  i += (grabResultAry[no].SizeX * 2);
               }
               fclose(fp);
            }
            boolsave = true;
         }
         */
         //---------------------------------------------------------------------
         // YUV422 to RGB
         //i = 0;
         //for(int row=0 ; row<grabResultAry[no].SizeY ; row++) {
         //   pt = (unsigned char *)usb_ImageAry[no].GetImagePtr(0,row);
         //   memcpy(pt,&imgBufAry[no][i],grabResultAry[no].SizeX*2);
         //   i += (grabResultAry[no].SizeX * 2);
         //}
         unsigned char *yuvbuf,*pt;
         yuvbuf = &imgBufAry[no][0];
         // Y0,U0,Y1,V0 - Table
         int y0,u0,y1,v0,pdx,idx;
         int rdif,invgdif,bdif,w2,vr,vg,vb;
         w2 = width * 2;
         for(int i=0 ; i<height ; i++) {
            pt = (unsigned char *)usb_ImageAry[no].GetImagePtr(0,i);
            idx = i * w2;
            pdx = 0;
            // 4bytes => 2Pixel
            for(int j=0 ; j<w2 ; j+=4) {
               u0 = yuvbuf[idx++];
               y0 = yuvbuf[idx++];
               v0 = yuvbuf[idx++];
               y1 = yuvbuf[idx++];

               rdif = Table_fv1[v0];
               invgdif = Table_fu1[u0] + Table_fv2[v0];
               bdif = Table_fu2[u0];

               // p1
               vb = y0 + bdif;
               vg = y0 - invgdif;
               vr = y0 + rdif;
               // BGR
               if(vb < 0)
                  vb = 0;
               else if(vb > 255)
                  vb = 255;
               pt[pdx++] = vb;
               if(vg < 0)
                  vg = 0;
               else if(vg > 255)
                  vg = 255;
               pt[pdx++] = vg;
               if(vr < 0)
                  vr = 0;
               else if(vr > 255)
                  vr = 255;
               pt[pdx++] = vr;
               // p2
               vb = y1 + bdif;
               vg = y1 - invgdif;
               vr = y1 + rdif;
               // BGR
               if(vb < 0)
                  vb = 0;
               else if(vb > 255)
                  vb = 255;
               pt[pdx++] = vb;
               if(vg < 0)
                  vg = 0;
               else if(vg > 255)
                  vg = 255;
               pt[pdx++] = vg;
               if(vr < 0)
                  vr = 0;
               else if(vr > 255)
                  vr = 255;
               pt[pdx++] = vr;
            }
         }
         //---------------------------------------------------------------------

         //lbGiga->Items->Add("CCD1: Move影像ok");

         // 要顯示在主畫面
         GetImageXY(width,height,sx,sy,w,h,&x,&y);
         usb_ImageROIAry[no].SetPlacement(x,y,w,h);
         usb_ImageROIAry[no].Draw(imCCD->Canvas->Handle);
         // 若沒有Refresh就不會顯示
         imCCD->Refresh();

         //lbGiga->Items->Add("CCD1: 顯示影像ok");
      }

      // Basler Pylon GigE CCD
      boolBaslerImageLoadedAry[no] = true;
      BaslerCaptureNoAry[no]++;
      if((count % 5) == 0) {
         GetTimeTic(&BaslerStopTimeAry[no],&BaslerStopTickAry[no]);
         BaslerElapsedmsAry[no] = ((BaslerStopTimeAry[no]*1000+BaslerStopTickAry[no]) - (BaslerStartTimeAry[no]*1000+BaslerStartTickAry[no]));
         double ratio;
         AnsiString msg;

         // 2016 7 23 - chc Devide by zero
         if(BaslerElapsedmsAry[no] != 0) {

            ratio = ((double)BaslerCaptureNoAry[no] * 1000.0) / BaslerElapsedmsAry[no];
            msg.sprintf("%.1f",ratio);
            pnlCapturedNo->Caption = msg;
         }
      }
   }

   // 無法取像
   //else if(grabResult.Status == Failed) {
   else {

      // fprintf( stderr,  "Frame %d wasn't grabbed successfully.  Error code = 0x%08X\n",
      //    i+1, grabResult.ErrorCode );
      lbGiga->Items->Add("grabResult1 = Failed");
      pnlSystemMessage->Caption = "grabResult = Failed";

      // 訊息
      //AddAlignMessage("AutoAlign Capture - Fail!");
   }

   // 取像時間顯示
   GetTimeTic(&BaslerCaptureStopTimeAry[no],&BaslerCaptureStopTickAry[no]);
   BaslerCaptureElapsedmsAry[no] = ((BaslerCaptureStopTimeAry[no]*1000+BaslerCaptureStopTickAry[no]) -
                                    (BaslerCaptureStartTimeAry[no]*1000+BaslerCaptureStartTickAry[no]));
   pnlCaptureTime->Caption = IntToStr(BaslerCaptureElapsedmsAry[no]);

   // 未在影像處理中
   boolInGigaBufferAry[no] = false;
}
//---------------------------------------------------------------------------
// 2022 7 18 - chc GigE CCD : 取得影像並顯示(BW/Color)
//   #define CCD_BW                0
//   #define CCD_COLOR             1
//   int BaslerCCDType[3];
// mode : 0 - 要呼叫 PylonDeviceGrabSingleFrame()
//        1 - 不要呼叫 PylonDeviceGrabSingleFrame()
void __fastcall TfrnMain::CaptureGigaFrame2(int no, int mode)
{
static int count = 0;
AnsiString msg;
int width,height,sx,sy,x,y,w,h;
static bool first = false;

   // Index
   pnlCCDStatus->Color = clSilver;
   no--;

   width = CCDInfoAry[no].Width;
   height = CCDInfoAry[no].Height;
   w = imCCD->Width;
   h = imCCD->Height;

   // 2016 5 26 - chc Lasr Cneter
   //sx = (width - w) / 2;
   //sy = (height - h) / 2;
   sx = LaserCenterX;
   sy = LaserCenterY;

   // 2016 10 30 - chc Check Range
   CheckRange(&sx,&sy);

   //lbGiga->Items->Add("進入取像...");
   // 在影像處理中
   boolInGigaBufferAry[no] = true;

   // 2015 9 9 - chc 要加速
   if(first == false) {
      first = true;

      // Grab one single frame from stream channel 0. The
      // camera is set to single frame acquisition mode.
      // Wait up to 500 ms for the image to be grabbed.
      // Software Trigger
      if(mode == 0)
         res = PylonDeviceGrabSingleFrame(hDevGigaAry[no], 0,  imgBufAry[no], CCDInfoAry[no].TotalSize, &grabResultAry[no], &bufferReadyAry[no], 5000);

      // 取像時間顯示
      GetTimeTic(&BaslerCaptureStopTimeAry[no],&BaslerCaptureStopTickAry[no]);
      BaslerCaptureElapsedmsAry[no] = ((BaslerCaptureStopTimeAry[no]*1000+BaslerCaptureStopTickAry[no]) -
                                       (BaslerCaptureStartTimeAry[no]*1000+BaslerCaptureStartTickAry[no]));
      pnlCaptureTime->Caption = IntToStr(BaslerCaptureElapsedmsAry[no]);

      switch(res) {
         case GENAPI_E_FAIL:
            lbGiga->Items->Add(IntToStr(no+1) + "Captured-1");
            break;
         case GENAPI_E_INDEX_ERROR:
            lbGiga->Items->Add(IntToStr(no+1) + "Captured-2");
            break;
         case GENAPI_E_INSUFFICIENT_BUFFER:
            lbGiga->Items->Add(IntToStr(no+1) + "Captured-3");
            break;
         case GENAPI_E_INVALID_ARG:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-4");
            break;
         case GENAPI_E_INVALID_NODECALLBACKHANDLE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-5");
            break;
         case GENAPI_E_INVALID_NODEHANDLE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-6");
            break;
         case GENAPI_E_INVALID_NODEMAPHANDLE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-7");
            break;
         case GENAPI_E_LIMITS_EXCEEDED:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-8");
            break;
         case GENAPI_E_LOGICAL_ERROR:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-9");
            break;
         case GENAPI_E_NODE_NOT_FOUND:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-10");
            break;
         case GENAPI_E_OBJECT_ILLEGAL_STATE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-11");
            break;
         case GENAPI_E_OK:
            //lbGiga->Items->Add("IntToStr(no+1) + Captured-12");
            break;
         case GENAPI_E_PROPERTY_ERROR:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-13");
            break;
         case GENAPI_E_RESULT_RANGE_EXCEEDED:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-14");
            break;
         case GENAPI_E_TIMEOUT:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-15");
            break;
         case GENAPI_E_TYPE_ERROR:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-16");
            break;
         case PYLON_E_INVALID_CHUNKPARSERHANDLE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-17");
            break;
         case PYLON_E_INVALID_CONVERTERHANDLE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-18");
            break;
         case PYLON_E_INVALID_DEVICEHANDLE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-19");
            break;
         case PYLON_E_INVALID_DEVICEINFO_PROPERTY:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-20");
            break;
         case PYLON_E_INVALID_DEVICEINFOHANDLE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-21");
            break;
         case PYLON_E_INVALID_EVENTADAPTERHANDLE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-22");
            break;
         case PYLON_E_INVALID_EVENTGRABBERHANDLE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured23");
            break;
         case PYLON_E_INVALID_STREAMGRABBERHANDLE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-24");
            break;
         case PYLON_E_INVALID_WAITOBJECTHANDLE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-25");
            break;
         case PYLON_E_INVALID_WAITOBJECTSHANDLE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-26");
            break;
      }

      if(GENAPI_E_OK == res && !bufferReadyAry[no]) {
         // Timeout occurred.
         msg.sprintf("Frame2 %d: timeout\n", count+1);
         lbGiga->Items->Add(msg);
         pnlSystemMessage->Caption = msg;
      }
      //CHECK(res);
   }

   // chc
   //grabResultAry[no].Status = Grabbed;

   // Check to see if the image was grabbed successfully.
   if(grabResultAry[no].Status == Grabbed) {
      count++;
      unsigned char *pt,*pt1;
      int i;
      int pointer;
      if(grabResultAry[no].SizeX != CCDInfoAry[no].Width || grabResultAry[no].SizeY != CCDInfoAry[no].Height) {
         lbGiga->Items->Add("Size Error!");
         pnlSystemMessage->Caption = "Size2 Error!";
         // 在影像處理中
         boolInGigaBufferAry[no] = false;
         pnlCCDStatus->Color = clRed;

         // 2015 9 8 - chc Log
         WriteSystemLog("CaptureGigaFrame2() Size Error!" + IntToStr(grabResultAry[no].SizeX) + "," + IntToStr(grabResultAry[no].SizeY));
         WriteSystemLog("CaptureGigaFrame2() Size Error!" + IntToStr(CCDInfoAry[no].Width) + "," + IntToStr(CCDInfoAry[no].Height));

         return;
      }
      i = 0;
      // 記錄Basler存檔中...
      if(boolInGigaSaveAry[no] == true) {
         lbGiga->Items->Add("In Saving2... Stop Refeshing Image");
         pnlSystemMessage->Caption = "In Saving... Stop Refeshing Image";
         boolInGigaBufferAry[no] = false;
         return;
      }
      pnlCCDStatus->Color = clLime;

      // 全取: 要區分BW/C24
      // BW : CCDImageAry
      if(CCDInfoAry[no].Type == CCD_BW) {
         i = 0;
         for(int row=0 ; row<grabResultAry[no].SizeY ; row++) {
            pt = (unsigned char *)CCDImageAry[no].GetImagePtr(0,row);
            memcpy(pt,&imgBufAry[no][i],grabResultAry[no].SizeX);
            i += grabResultAry[no].SizeX;
         }
         // 要顯示在主畫面 ###@@@
         GetImageXY(width,height,sx,sy,w,h,&x,&y);
         CCDImageROIAry[no].SetPlacement(x,y,w,h);
         CCDImageROIAry[no].Draw(imCCD->Canvas->Handle);
         // 若沒有Refresh就不會顯示
         imCCD->Refresh();
      }
      // Color : usb_ImageAry
      else {
         i = 0;
         for(int row=0 ; row<grabResultAry[no].SizeY ; row++) {
            pt = (unsigned char *)usb_ImageAry[no].GetImagePtr(0,row);
            memcpy(pt,&imgBufAry[no][i],grabResultAry[no].SizeX*3);
            i += (grabResultAry[no].SizeX * 3);
         }
         // 要顯示在主畫面 ###@@@
         GetImageXY(width,height,sx,sy,w,h,&x,&y);
         usb_ImageROIAry[no].SetPlacement(x,y,w,h);
         usb_ImageROIAry[no].Draw(imCCD->Canvas->Handle);
         // 若沒有Refresh就不會顯示
         imCCD->Refresh();
      }

      // Basler Pylon GigE CCD
      boolBaslerImageLoadedAry[no] = true;
      BaslerCaptureNoAry[no]++;
      if((count % 5) == 0) {
         GetTimeTic(&BaslerStopTimeAry[no],&BaslerStopTickAry[no]);
         BaslerElapsedmsAry[no] = ((BaslerStopTimeAry[no]*1000+BaslerStopTickAry[no]) - (BaslerStartTimeAry[no]*1000+BaslerStartTickAry[no]));
         double ratio;
         AnsiString msg;

         // 2016 7 23 - chc Devide by zero
         if(BaslerElapsedmsAry[no] != 0) {

            ratio = ((double)BaslerCaptureNoAry[no] * 1000.0) / BaslerElapsedmsAry[no];
            msg.sprintf("%.1f",ratio);
            pnlCapturedNo->Caption = msg;
         }
      }
   }

   // 無法取像
   //else if(grabResult.Status == Failed) {
   else {

      // fprintf( stderr,  "Frame %d wasn't grabbed successfully.  Error code = 0x%08X\n",
      //    i+1, grabResult.ErrorCode );
      lbGiga->Items->Add("grabResult2 = Failed");
      pnlSystemMessage->Caption = "grabResult = Failed";

      // 訊息
      //AddAlignMessage("AutoAlign Capture - Fail!");
   }

   // 2015 9 9 - chc 再Trigger一次
   if(first == true) {
      if(mode == 0)
         res = PylonDeviceGrabSingleFrame(hDevGigaAry[no], 0,  imgBufAry[no], CCDInfoAry[no].TotalSize, &grabResultAry[no], &bufferReadyAry[no], 5000);
      // 取像時間顯示
      GetTimeTic(&BaslerCaptureStopTimeAry[no],&BaslerCaptureStopTickAry[no]);
      BaslerCaptureElapsedmsAry[no] = ((BaslerCaptureStopTimeAry[no]*1000+BaslerCaptureStopTickAry[no]) -
                                       (BaslerCaptureStartTimeAry[no]*1000+BaslerCaptureStartTickAry[no]));
      pnlCaptureTime->Caption = IntToStr(BaslerCaptureElapsedmsAry[no]);
      // Timeout?
      if(GENAPI_E_OK == res && !bufferReadyAry[no]) {
         // Timeout occurred.
         msg.sprintf("Frame2a %d: timeout\n", count+1);
         lbGiga->Items->Add(msg);
         pnlSystemMessage->Caption = msg;
      }
   }

   // 未在影像處理中
   boolInGigaBufferAry[no] = false;
}
//---------------------------------------------------------------------------
// 2022 7 18 - chc GigE CCD : 取得影像並顯示(BW/Color)
//   #define CCD_BW                0
//   #define CCD_COLOR             1
//   int BaslerCCDType[3];
// mode : 0 - 要呼叫 PylonDeviceGrabSingleFrame()
//        1 - 不要呼叫 PylonDeviceGrabSingleFrame()
void __fastcall TfrnMain::CaptureGigaFrame3(int no, int mode)
{
static int count = 0;
AnsiString msg;
int width,height,sx,sy,x,y,w,h;
static bool first = false;

   // Index
   pnlCCDStatus->Color = clSilver;
   no--;

   width = CCDInfoAry[no].Width;
   height = CCDInfoAry[no].Height;
   w = imCCD->Width;
   h = imCCD->Height;

   // 2016 5 26 - chc Lasr Cneter
   //sx = (width - w) / 2;
   //sy = (height - h) / 2;
   sx = LaserCenterX;
   sy = LaserCenterY;

   // 2016 10 30 - chc Check Range
   CheckRange(&sx,&sy);

   //lbGiga->Items->Add("進入取像...");
   // 在影像處理中
   boolInGigaBufferAry[no] = true;

   // 2015 9 9 - chc 要加速
   if(first == false) {
      first = true;

      // Grab one single frame from stream channel 0. The
      // camera is set to single frame acquisition mode.
      // Wait up to 500 ms for the image to be grabbed.
      // Software Trigger
      if(mode == 0)
         res = PylonDeviceGrabSingleFrame(hDevGigaAry[no], 0,  imgBufAry[no], CCDInfoAry[no].TotalSize, &grabResultAry[no], &bufferReadyAry[no], 5000);

      // 取像時間顯示
      GetTimeTic(&BaslerCaptureStopTimeAry[no],&BaslerCaptureStopTickAry[no]);
      BaslerCaptureElapsedmsAry[no] = ((BaslerCaptureStopTimeAry[no]*1000+BaslerCaptureStopTickAry[no]) -
                                       (BaslerCaptureStartTimeAry[no]*1000+BaslerCaptureStartTickAry[no]));
      pnlCaptureTime->Caption = IntToStr(BaslerCaptureElapsedmsAry[no]);

      switch(res) {
         case GENAPI_E_FAIL:
            lbGiga->Items->Add(IntToStr(no+1) + "Captured-1");
            break;
         case GENAPI_E_INDEX_ERROR:
            lbGiga->Items->Add(IntToStr(no+1) + "Captured-2");
            break;
         case GENAPI_E_INSUFFICIENT_BUFFER:
            lbGiga->Items->Add(IntToStr(no+1) + "Captured-3");
            break;
         case GENAPI_E_INVALID_ARG:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-4");
            break;
         case GENAPI_E_INVALID_NODECALLBACKHANDLE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-5");
            break;
         case GENAPI_E_INVALID_NODEHANDLE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-6");
            break;
         case GENAPI_E_INVALID_NODEMAPHANDLE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-7");
            break;
         case GENAPI_E_LIMITS_EXCEEDED:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-8");
            break;
         case GENAPI_E_LOGICAL_ERROR:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-9");
            break;
         case GENAPI_E_NODE_NOT_FOUND:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-10");
            break;
         case GENAPI_E_OBJECT_ILLEGAL_STATE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-11");
            break;
         case GENAPI_E_OK:
            //lbGiga->Items->Add("IntToStr(no+1) + Captured-12");
            break;
         case GENAPI_E_PROPERTY_ERROR:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-13");
            break;
         case GENAPI_E_RESULT_RANGE_EXCEEDED:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-14");
            break;
         case GENAPI_E_TIMEOUT:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-15");
            break;
         case GENAPI_E_TYPE_ERROR:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-16");
            break;
         case PYLON_E_INVALID_CHUNKPARSERHANDLE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-17");
            break;
         case PYLON_E_INVALID_CONVERTERHANDLE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-18");
            break;
         case PYLON_E_INVALID_DEVICEHANDLE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-19");
            break;
         case PYLON_E_INVALID_DEVICEINFO_PROPERTY:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-20");
            break;
         case PYLON_E_INVALID_DEVICEINFOHANDLE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-21");
            break;
         case PYLON_E_INVALID_EVENTADAPTERHANDLE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-22");
            break;
         case PYLON_E_INVALID_EVENTGRABBERHANDLE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured23");
            break;
         case PYLON_E_INVALID_STREAMGRABBERHANDLE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-24");
            break;
         case PYLON_E_INVALID_WAITOBJECTHANDLE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-25");
            break;
         case PYLON_E_INVALID_WAITOBJECTSHANDLE:
            lbGiga->Items->Add("IntToStr(no+1) + Captured-26");
            break;
      }

      if(GENAPI_E_OK == res && !bufferReadyAry[no]) {
         // Timeout occurred.
         msg.sprintf("Frame3 %d: timeout\n", count+1);
         lbGiga->Items->Add(msg);
         pnlSystemMessage->Caption = msg;
      }
      //CHECK(res);
   }

   // chc
   //grabResultAry[no].Status = Grabbed;

   // Check to see if the image was grabbed successfully.
   if(grabResultAry[no].Status == Grabbed) {
      count++;
      unsigned char *pt,*pt1;
      int i;
      int pointer;
      if(grabResultAry[no].SizeX != CCDInfoAry[no].Width || grabResultAry[no].SizeY != CCDInfoAry[no].Height) {
         lbGiga->Items->Add("Size3 Error!");
         pnlSystemMessage->Caption = "Size Error!";
         // 在影像處理中
         boolInGigaBufferAry[no] = false;
         pnlCCDStatus->Color = clRed;

         // 2015 9 8 - chc Log
         WriteSystemLog("CaptureGigaFrame3() Size Error!" + IntToStr(grabResultAry[no].SizeX) + "," + IntToStr(grabResultAry[no].SizeY));
         WriteSystemLog("CaptureGigaFrame3() Size Error!" + IntToStr(CCDInfoAry[no].Width) + "," + IntToStr(CCDInfoAry[no].Height));

         return;
      }
      i = 0;
      // 記錄Basler存檔中...
      if(boolInGigaSaveAry[no] == true) {
         lbGiga->Items->Add("In Saving3... Stop Refeshing Image");
         pnlSystemMessage->Caption = "In Saving... Stop Refeshing Image";
         boolInGigaBufferAry[no] = false;
         return;
      }
      pnlCCDStatus->Color = clLime;

      // 全取: 要區分BW/C24
      // BW : CCDImageAry
      if(CCDInfoAry[no].Type == CCD_BW) {
         i = 0;
         for(int row=0 ; row<grabResultAry[no].SizeY ; row++) {
            pt = (unsigned char *)CCDImageAry[no].GetImagePtr(0,row);
            memcpy(pt,&imgBufAry[no][i],grabResultAry[no].SizeX);
            i += grabResultAry[no].SizeX;
         }
         // 要顯示在主畫面 ###@@@
         GetImageXY(width,height,sx,sy,w,h,&x,&y);
         CCDImageROIAry[no].SetPlacement(x,y,w,h);
         CCDImageROIAry[no].Draw(imCCD->Canvas->Handle);
         // 若沒有Refresh就不會顯示
         imCCD->Refresh();
      }
      // Color : usb_ImageAry
      else {
         i = 0;
         for(int row=0 ; row<grabResultAry[no].SizeY ; row++) {
            pt = (unsigned char *)usb_ImageAry[no].GetImagePtr(0,row);
            memcpy(pt,&imgBufAry[no][i],grabResultAry[no].SizeX*3);
            i += (grabResultAry[no].SizeX * 3);
         }
         // 要顯示在主畫面 ###@@@
         GetImageXY(width,height,sx,sy,w,h,&x,&y);
         usb_ImageROIAry[no].SetPlacement(x,y,w,h);
         usb_ImageROIAry[no].Draw(imCCD->Canvas->Handle);
         // 若沒有Refresh就不會顯示
         imCCD->Refresh();
      }

      // Basler Pylon GigE CCD
      boolBaslerImageLoadedAry[no] = true;
      BaslerCaptureNoAry[no]++;
      if((count % 5) == 0) {
         GetTimeTic(&BaslerStopTimeAry[no],&BaslerStopTickAry[no]);
         BaslerElapsedmsAry[no] = ((BaslerStopTimeAry[no]*1000+BaslerStopTickAry[no]) - (BaslerStartTimeAry[no]*1000+BaslerStartTickAry[no]));
         double ratio;
         AnsiString msg;

         // 2016 7 23 - chc Devide by zero
         if(BaslerElapsedmsAry[no] != 0) {

            ratio = ((double)BaslerCaptureNoAry[no] * 1000.0) / BaslerElapsedmsAry[no];
            msg.sprintf("%.1f",ratio);
            pnlCapturedNo->Caption = msg;
         }
      }
   }

   // 無法取像
   //else if(grabResult.Status == Failed) {
   else {

      // fprintf( stderr,  "Frame %d wasn't grabbed successfully.  Error code = 0x%08X\n",
      //    i+1, grabResult.ErrorCode );
      lbGiga->Items->Add("grabResult3 = Failed");
      pnlSystemMessage->Caption = "grabResult = Failed";

      // 訊息
      //AddAlignMessage("AutoAlign Capture - Fail!");
   }

   // 2015 9 9 - chc 再Trigger一次
   if(first == true) {
      if(mode == 0)
         res = PylonDeviceGrabSingleFrame(hDevGigaAry[no], 0,  imgBufAry[no], CCDInfoAry[no].TotalSize, &grabResultAry[no], &bufferReadyAry[no], 5000);
      // 取像時間顯示
      GetTimeTic(&BaslerCaptureStopTimeAry[no],&BaslerCaptureStopTickAry[no]);
      BaslerCaptureElapsedmsAry[no] = ((BaslerCaptureStopTimeAry[no]*1000+BaslerCaptureStopTickAry[no]) -
                                       (BaslerCaptureStartTimeAry[no]*1000+BaslerCaptureStartTickAry[no]));
      pnlCaptureTime->Caption = IntToStr(BaslerCaptureElapsedmsAry[no]);
      // Timeout?
      if(GENAPI_E_OK == res && !bufferReadyAry[no]) {
         // Timeout occurred.
         msg.sprintf("Frame3a %d: timeout\n", count+1);
         lbGiga->Items->Add(msg);
         pnlSystemMessage->Caption = msg;
      }
   }

   // 未在影像處理中
   boolInGigaBufferAry[no] = false;
}
//---------------------------------------------------------------------------
//int iBoxWidth,iBoxHeight; => 扣除ScrollBar之寬高
//int iImageWidth,iImageHeight; => 實際圖檔之寬高
void __fastcall TfrnMain::AdjustCenterLine()
{

//   return;
   pnlColum->Caption = IntToStr(shMapVertical->Top);
   pnlColumSelect->Caption = IntToStr(shMapVertical->Left);
   pnlRow->Caption = IntToStr(sbWaferMap->VertScrollBar->Position);
   pnlRowSelect->Caption = IntToStr(sbWaferMap->HorzScrollBar->Position);
return;
   shMapVertical->Top = 0;
//   if(sbWaferMap->VertScrollBar->Position + iBoxHeight > imWaferMap->Height) {
//      shMapVertical->Top = imWaferMap->Height - iBoxHeight;
//      sbWaferMap->VertScrollBar->Position = imWaferMap->Height - iBoxHeight;
//   }
//   else
//      shMapVertical->Top = sbWaferMap->VertScrollBar->Position;
   shMapVertical->Left = iBoxWidth/2;
   shMapHorizontal->Top = iBoxHeight/2;
   shMapHorizontal->Left = 0;
   return;
   shMapVertical->Top = sbWaferMap->VertScrollBar->Position;
   shMapVertical->Left = sbWaferMap->HorzScrollBar->Position + iBoxWidth/2;
   shMapHorizontal->Top = sbWaferMap->VertScrollBar->Position + iBoxHeight/2;
   shMapHorizontal->Left = sbWaferMap->HorzScrollBar->Position;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::sbWaferMapMouseWheelUp(TObject *Sender,
      TShiftState Shift, TPoint &MousePos, bool &Handled)
{

   //sbWaferMap->VertScrollBar->Position -= 10;
   int value;
   if(rgWheelDirection->ItemIndex == 0) {
      value = sbWaferMap->VertScrollBar->Position - 10;
      if(value < 0)
         sbWaferMap->VertScrollBar->Position = 0;
      else
         sbWaferMap->VertScrollBar->Position -= 10;
   }
   else {
      value = sbWaferMap->HorzScrollBar->Position - 10;
      if(value < 0)
         sbWaferMap->HorzScrollBar->Position = 0;
      else
         sbWaferMap->HorzScrollBar->Position -= 10;
   }
   AdjustCenterLine();
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::sbWaferMapMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{
int no;

   no = 1;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::imWaferMapMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{
int no;

   no = 1;

   
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::tbZoomChange(TObject *Sender)
{

   ZoomImage();
}
//---------------------------------------------------------------------------
// 量測用Iamge
void __fastcall TfrnMain::btnLoadMeasureImageClick(TObject *Sender)
{
int no,width,height;
AnsiString msg;

   // 固定為0
   no = 0;

   opCCDImage->InitialDir = ImageDirectory;
   if(opCCDImage->Execute()) {
      sbWaferMap->VertScrollBar->Position = 0;
      sbWaferMap->HorzScrollBar->Position = 0;
      tbZoom->Position = 10;
      msg.sprintf("%dX:%.4f",1,CCDPrecision);
      pnlFactor->Caption = msg;
      if(CCDInfoAry[no].Type == CCD_BW) {
         CCDImageAry[no].Load(opCCDImage->FileName.c_str());
         width = CCDImageAry[no].GetWidth();
         height = CCDImageAry[no].GetHeight();
         WriteSystemLog("Load Gray Image: " + IntToStr(width) + "," + IntToStr(height) + "," + opCCDImage->FileName);
         imWaferMap->Width = width;
         imWaferMap->Height = height;
         iImageWidth = width;
         iImageHeight = height;
         //CCDImageROIAry[no].Draw(imWaferMap->Canvas->Handle);
         imWaferMap->Picture->LoadFromFile(opCCDImage->FileName);
      }
      else {
         usb_ImageAry[no].Load(opCCDImage->FileName.c_str());
         width = usb_ImageAry[no].GetWidth();
         height = usb_ImageAry[no].GetHeight();
         WriteSystemLog("Load Color Image: " + IntToStr(width) + "," + IntToStr(height) + "," + opCCDImage->FileName);
         imWaferMap->Width = width;
         imWaferMap->Height = height;
         iImageWidth = width;
         iImageHeight = height;
         //usb_ImageROIAry[no].Draw(imWaferMap->Canvas->Handle);
         imWaferMap->Picture->LoadFromFile(opCCDImage->FileName);
      }
      // 若沒有Refresh就不會顯示
      imWaferMap->Refresh();
      boolCCDImageLoadedAry[no] = true;
      pnlSystemMessage->Caption = "Image Loaded.";
   }

}
//---------------------------------------------------------------------------
// MapX, MapY
void __fastcall TfrnMain::imWaferMapDblClick(TObject *Sender)
{
int x,y,cx,cy;

   cx = MapX;
   cy = MapY;
   x = cx - (sbWaferMap->Width-21) / 2;
   y = cy - (sbWaferMap->Height-21) / 2;
   if(x < 0)
      x = 0;
   if(x > imWaferMap->Width - (sbWaferMap->Width-21))
      x = imWaferMap->Width - (sbWaferMap->Width-21);
   if(y < 0)
      y = 0;
   if(y > imWaferMap->Height - (sbWaferMap->Height-21))
      x = imWaferMap->Height - (sbWaferMap->Height-21);
   sbWaferMap->VertScrollBar->Position = y;
   sbWaferMap->HorzScrollBar->Position = x;
}
//---------------------------------------------------------------------------
// boolBXFMStatus = false;
void __fastcall TfrnMain::BXFMButton()
{

   btnBXFMCMD->Enabled = boolBXFMStatus;
   btnBXFMEnable->Enabled = boolBXFMStatus;
   rgBXFMLens->Enabled = boolBXFMStatus;
   rgBXFMCube->Enabled = boolBXFMStatus;
   rgBXFMLMP->Enabled = boolBXFMStatus;
   tbBXFMLMP->Enabled = boolBXFMStatus;
   rgBXFMLMPSwitch->Enabled = boolBXFMStatus;
   btnBXFMGetLMP->Enabled = boolBXFMStatus;
   tbBXFMAS->Enabled = boolBXFMStatus;
   btnBXFMSave->Enabled = boolBXFMStatus;
   frmInspection->rgAS->Enabled = boolBXFMStatus;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::combBXFMComportChange(TObject *Sender)
{

   InitBXFMCom();
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::combBXFMBaudrateChange(TObject *Sender)
{

   InitBXFMCom();
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnBXFMConnectClick(TObject *Sender)
{

   try {
      ybBXFM->SettingsDialog(this,true);
      if(boolBXFMStatus == false)
         ybBXFM->Active = true;
      boolBXFMStatus = true;
      BXFMButton();
   }
   catch(Exception &e) {
      ShowMessage("ybBXFM: " + e.Message);
      boolBXFMStatus = false;
      BXFMButton();
      pnlSystemMessage->Caption = "COM Port(BXFM) 啟動失敗!";
      WriteSystemLog(pnlSystemMessage->Caption);
   }
   UpdateBXFMStatus();
}
//---------------------------------------------------------------------------
// 2022 7 23 - chc BXFM Active
void __fastcall TfrnMain::UpdateBXFMStatus()
{

   if(boolBXFMStatus == true) {
      pnlBXFMStatus->Color = clLime;
      pnlBXFMReady->Color = clLime;
   }
   else {
      pnlBXFMStatus->Color = clRed;
      pnlBXFMReady->Color = clRed;
   }
}
//---------------------------------------------------------------------------
// 2022 7 23 - chc Init BXFM ComPort
// COM1
void __fastcall TfrnMain::InitBXFMCom()
{

   // 由參數決定COM Port
   pnlSystemMessage->Caption = "啟動BXFM Com Port...";
   try {
      pnlBXFMStatus->Color = clSilver;
      ybBXFM->Active = false;
      Sleep(200);
      if(combBXFMBaudrate->Text == "115200")
         ybBXFM->Baud = ybBXFM->br115200;
      else if(combBXFMBaudrate->Text == "57600")
         ybBXFM->Baud = ybBXFM->br57600;
      else if(combBXFMBaudrate->Text == "38400")
         ybBXFM->Baud = ybBXFM->br38400;
      else if(combBXFMBaudrate->Text == "19200") {
         ybBXFM->Baud = ybBXFM->br19200;
         WriteSystemLog("BXFM: 19200");
      }
      else if(combBXFMBaudrate->Text == "9600")
         ybBXFM->Baud = ybBXFM->br9600;
      // 由參數決定COM Port
      ybBXFM->PortNo = combBXFMComport->ItemIndex+1;
      WriteSystemLog("BXFM: COM" + IntToStr(ybBXFM->PortNo));

      // Parity, DataBit, StopBit
      //ybBXFM->Parity = ybBXFM->ptEvenParity;
      //ybBXFM->ByteSize = 7;
      //ybBXFM->StopBits = ybBXFM->sbOneStopBit;
      //ybBXFM->FlowControl = ybBXFM->fcNone;
      //WriteSystemLog("BXFM: 7E1None");

      // Parity
      //if(cbNoParity->Checked == true)
      //   ybBXFM->Parity = ybLens->ptNoParity;
      //else
      //   ybBXFM->Parity = ybLens->ptEvenParity;

      ybBXFM->Active = true;
      pnlBXFMStatus->Color = clLime;
      boolBXFMStatus = true;
      BXFMButton();
   }
   catch(Exception &e) {
      pnlSystemMessage->Caption = "ybBXFM: " + e.Message;
      sbSystem->Panels->Items[1]->Text = "ybBXFM: " + e.Message;
      pnlBXFMStatus->Color = clRed;
      boolBXFMStatus = false;
      BXFMButton();
   }
   UpdateBXFMStatus();
   pnlSystemMessage->Caption = "啟動BXFM Com Port.";

}
//---------------------------------------------------------------------------
// ASCII mode
// BXFM
//	1LOG IN(Remote)
//	1LOG OUT(Local)
//	1LMPSW ON/OFF(開或關)
//	1OB 1/2/3/4/5(Lens)
//	1LMPSEL DIA(Transmitted)/EPI(Reflected)
//	1LMP 1~120
//	1LMPSTS?
//	1CUBE 1(BF)/2(DF)
//	1EAS 0~3113
//
AnsiString BXFMCmd;
void __fastcall TfrnMain::btnBXFMCMDClick(TObject *Sender)
{
unsigned char command[50],buf[50];
AnsiString msg;
int len,pos;

   if(boolBXFMStatus == false) {
      pnlBXFMMessage->Caption = "未連線!";
      WriteSystemLog("btnBXFMCMDClick: BXFM尚未連線!");
      return;
   }

   // BXFM
   //sprintf(command,"1%s%c",edBXFMCmd->Text,0x0a);
   sprintf(command,"1%s\r\n",edBXFMCmd->Text);

   len = strlen(command);
   pos = edBXFMCmd->Text.Pos("?");
   if(pos > 0)
      BXFMCmd = edBXFMCmd->Text.SubString(1,pos-1);
   else {
      pos = edBXFMCmd->Text.Pos(" ");
      if(pos > 0)
         BXFMCmd = edBXFMCmd->Text.SubString(1,pos-1);
      else
         BXFMCmd = "";
   }

   WriteSystemLog("btnBXFMCMDClick: run...");
   ybBXFM->Write(command,len);
   pnlBXFMOperation->Caption = "Busy";
   pnlBXFM->Enabled = false;
   btnBXFMEnable->Visible = true;

   sprintf(command,"2%s",edBXFMCmd->Text);
   msg.sprintf("CMD: %s",command);
   pnlSystemMessage->Caption = msg;
   WriteSystemLog(msg);

   AddBXFMSendMessage(edBXFMCmd->Text);
   pnlBXFMMessage->Caption = msg;
   WriteSystemLog("btnBXFMCMDClick: edBXFMCmd= " + edBXFMCmd->Text);
}
//---------------------------------------------------------------------------
// BXFM Send
void __fastcall TfrnMain::AddBXFMSendMessage(AnsiString msg)
{
AnsiString putmsg;

   //putmsg = Now().FormatString("hh':'nn':'ss'-> '") + msg;
   //mmBXFMMsg->Lines->Insert(0,putmsg);
   //if(mmBXFMMsg->Lines->Count > 400) {
   //   for(int i=370 ; i<mmBXFMMsg->Lines->Count ; i++)
   //      mmBXFMMsg->Lines->Delete(i);
   //}

   // 2022 9 6 - chc 固定要清除, 否則速度會變慢!
   if(mmBXFMMsg->Lines->Count > 400) {
      for(int i=320 ; i<mmBXFMMsg->Lines->Count ; i++)
         mmBXFMMsg->Lines->Delete(i);
   }

   //putmsg = ">" + msg;
   //mmBXFMMsg->Lines->Insert(0,putmsg);
   putmsg = Now().FormatString("nn':'ss':'zzz'-> '") + msg;
   mmBXFMMsg->Lines->Insert(0,putmsg);
}
//---------------------------------------------------------------------------
//	1LOG IN(Remote)
//	1LOG OUT(Local)
void __fastcall TfrnMain::rgBXFMControlChange(TObject *Sender,
      int ButtonIndex)
{

   pnlBXFMControl->Color = clSilver;
   // Local
   if(rgBXFMControl->ItemIndex == 0)
      edBXFMCmd->Text = "LOG OUT";
   // Remote
   else
      edBXFMCmd->Text = "LOG IN";
   btnBXFMCMDClick(this);
}
//---------------------------------------------------------------------------
//	1OB 1/2/3/4/5(Lens)
void __fastcall TfrnMain::rgBXFMLensChange(TObject *Sender,
      int ButtonIndex)
{
int no;

   pnlBXFMLens->Color = clSilver;
   no = rgBXFMLens->ItemIndex + 1;
   edBXFMCmd->Text = "OB " + IntToStr(no);
   btnBXFMCMDClick(this);

   // 2022 8 14 - chc 也要做AMOV: AF用
   Sleep(500);
   btnA2MSetClick(this);

   // MOV
   // 2022 8 15 - chc 也到各Lens的Pos
   int z,lensno;
   pnlA2MSet->Color = clSilver;
   lensno = no - 1;
   if(lensno == 0) {
      z = edA2MLens1Z->Text.ToInt();
   }
   else if(lensno == 1) {
      z = edA2MLens2Z->Text.ToInt();
   }
   else if(lensno == 2) {
      z = edA2MLens3Z->Text.ToInt();
   }
   else if(lensno == 3) {
      z = edA2MLens4Z->Text.ToInt();
   }
   else if(lensno == 4) {
      z = edA2MLens5Z->Text.ToInt();
   }
   // 取得POS, 再MOV到指定position
   int cnt,max,pos,offset;
   AnsiString scmd;
   btnA2MPosClick(this);
   cnt = 0;
   max = 20;
   while(1) {
      if(pnlA2MPos->Caption != "")
         break;
      WaitTime(100);
      cnt++;
      if(cnt > max) {
         WriteSystemLog("POS取得失敗!");
         return;
      }
   }

   // 2022 9 6 - chc 處理APos/Pos "X"問題
   try {
      if(pnlA2MPos->Caption == "X")
         pos = 0;
      else
         pos = pnlA2MPos->Caption.ToInt();
   }
   catch(Exception &e) {
      WriteSystemLog("Pos - Error");
      sbSystem->Panels->Items[1]->Text = "Pos - Error";
      pos = 0;
   }

   offset = z - pos;
   if(offset != 0) {
      if(offset > 0) {
         scmd.sprintf("MOV N,%d",offset);
      }
      else {
         scmd.sprintf("MOV F,%d",abs(offset));
      }
      edA2MCmd->Text = scmd;
      btnA2MCMDClick(this);
   }
   Sleep(500);

}
//---------------------------------------------------------------------------
//	1CUBE 1(BF)/2(DF)
void __fastcall TfrnMain::rgBXFMCubeChange(TObject *Sender,
      int ButtonIndex)
{

   pnlBXFMCube->Color = clSilver;
   // Bright
   if(rgBXFMCube->ItemIndex == 0)
      edBXFMCmd->Text = "CUBE 1";
   // Remote
   else
      edBXFMCmd->Text = "CUBE 2";
   btnBXFMCMDClick(this);
}
//---------------------------------------------------------------------------
//	1LMPSEL DIA(Transmitted)/EPI(Reflected)
void __fastcall TfrnMain::rgBXFMLMPChange(TObject *Sender, int ButtonIndex)
{

   pnlBXFMLMP->Color = clSilver;
   // Transmitted
   if(rgBXFMLMP->ItemIndex == 0)
      edBXFMCmd->Text = "LMPSEL DIA";
   // Refelected
   else
      edBXFMCmd->Text = "LMPSEL EPI";
   btnBXFMCMDClick(this);
}
//---------------------------------------------------------------------------
//	1LMP 1~120
void __fastcall TfrnMain::tbBXFMLMPChange(TObject *Sender)
{
int no;

   return;
   // 2022 7 25 - chc 已進入formshow
   if(boolFormshow == false)
      return;

   pnlBXFMLampSet->Color = clSilver;
   no = tbBXFMLMP->Position;
   pnlBXFMLMPValue->Caption = IntToStr(no);
   edBXFMCmd->Text = "LMP " + IntToStr(no);
   btnBXFMCMDClick(this);
}
//---------------------------------------------------------------------------
//	1LMPSW ON/OFF(開或關)
void __fastcall TfrnMain::rgBXFMLMPSwitchChange(TObject *Sender,
      int ButtonIndex)
{

   pnlBXFMLMPSwitch->Color = clSilver;
   // On
   if(rgBXFMLMPSwitch->ItemIndex == 0)
      edBXFMCmd->Text = "LMPSW ON";
   // Off
   else
      edBXFMCmd->Text = "LMPSW OFF";
   btnBXFMCMDClick(this);
}
//---------------------------------------------------------------------------
//	1LMPSTS?
// OK or X
void __fastcall TfrnMain::btnBXFMGetLMPStatusClick(TObject *Sender)
{

   edBXFMCmd->Text = "LMPSTS?";
   btnBXFMCMDClick(this);
}
//---------------------------------------------------------------------------
//	1EAS 0~3113
void __fastcall TfrnMain::tbBXFMASChange(TObject *Sender)
{
int no;

   return;
   if(boolFormshow == false)
      return;

   pnlBXFMAS->Color = clSilver;
   no = tbBXFMAS->Position;
   edBXFMCmd->Text = "EAS " + IntToStr(no);
   btnBXFMCMDClick(this);
}
//---------------------------------------------------------------------------
AnsiString ReplyStrBXFM = "";
unsigned char BXFMBuffer[500];
void __fastcall TfrnMain::ybBXFMCommNotify(TObject *Sender, int NotifyType)
{
char Buf[8192+1];
AnsiString msg,msg1,serrorcode,svalue;
int len,pos,n;
bool boolstas = false;
bool boolclearerrorcode = false;

   // 先不管
   //if(NotifyType == EV_RXCHAR) {

      n = ybBXFM->Read(Buf,8192);
      if(n > 0) {
         Buf[n] = 0;

         // 即時顯示: 否則有亂碼
         //msg.sprintf("[org]%s",Buf);
         //AddBXFMRecvMessage(msg);
         //WriteSystemLog(msg);
         //msg = "[X]";
         //for(int i=0 ; i<n ; i++) {
         //   msg1.sprintf("%2X ",Buf[i]);
         //   msg = msg + msg1;
         //}
         //WriteSystemLog(msg);

         for(int i=0 ; i<n ; i++) {
            // End Code
            if(Buf[i] == 0x0d)
               continue;
            if(Buf[i] == 0x0a) {
               // Display: "<2INITORG +"
               if(ReplyStrBXFM.SubString(2,1) == "2")
                  AddA2MRecvMessage(ReplyStrBXFM);
               else if(ReplyStrBXFM.SubString(2,1) == "4")
                  AddDICRecvMessage(ReplyStrBXFM);
               else
                  AddBXFMRecvMessage(ReplyStrBXFM);
               WriteSystemLog("BXFM: Recv = " + ReplyStrBXFM);
               // Error Code: LOG !,1101
               if(ReplyStrBXFM.Pos("!,") > 0) {
                  pos = ReplyStrBXFM.Pos("!,");
                  len = ReplyStrBXFM.Length();
                  // LOG !,1234
                  // 1234567890
                  if((len-pos-1) >= 0) {
                     serrorcode = ReplyStrBXFM.SubString(pos+2,(len-pos-1));
                     pnlBXFMErrorCode->Caption = serrorcode;
                  }
               }

               // LOG設定成功
               if(ReplyStrBXFM.Pos("LOG +") > 0) {
                  boolclearerrorcode = true;
                  if(ReplyStrBXFM.SubString(2,1) == "2")
                     pnlA2MControl->Color = clLime;
                  else if(ReplyStrBXFM.SubString(2,1) == "4")
                     pnlDICControl->Color = clLime;
                  else
                     pnlBXFMControl->Color = clLime;
               }
               // LOG設定失敗
               else if(ReplyStrBXFM.Pos("LOG !") > 0) {
                  boolclearerrorcode = true;
                  if(ReplyStrBXFM.SubString(2,1) == "2")
                     pnlA2MControl->Color = clRed;
                  else if(ReplyStrBXFM.SubString(2,1) == "4")
                     pnlDICControl->Color = clRed;
                  else
                     pnlBXFMControl->Color = clRed;
               }

               // DIC設定成功
               if(ReplyStrBXFM.Pos("DIC +") > 0) {
                  boolclearerrorcode = true;
                  if(ReplyStrBXFM.SubString(2,1) == "4")
                     pnlDICSet->Color = clLime;
               }
               // LOG設定失敗
               else if(ReplyStrBXFM.Pos("DIC !") > 0) {
                  boolclearerrorcode = true;
                  if(ReplyStrBXFM.SubString(2,1) == "4")
                     pnlDICSet->Color = clRed;
               }

               // OB設定成功
               if(ReplyStrBXFM.Pos("OB +") > 0) {
                  boolclearerrorcode = true;
                  pnlBXFMLens->Color = clLime;
                  pnlLensSwitchResult->Color = pnlBXFMLens->Color;
               }
               // OB設定失敗
               else if(ReplyStrBXFM.Pos("OB !") > 0) {
                  boolclearerrorcode = true;
                  pnlBXFMLens->Color = clRed;
                  pnlLensSwitchResult->Color = pnlBXFMLens->Color;
               }

               // LMPSW設定成功
               if(ReplyStrBXFM.Pos("LMPSW +") > 0) {
                  boolclearerrorcode = true;
                  pnlBXFMLMPSwitch->Color = clLime;
               }
               // LMPSW設定失敗
               else if(ReplyStrBXFM.Pos("LMPSW !") > 0) {
                  boolclearerrorcode = true;
                  pnlBXFMLMPSwitch->Color = clRed;
               }

               // LMPSEL設定成功
               if(ReplyStrBXFM.Pos("LMPSEL +") > 0) {
                  boolclearerrorcode = true;
                  pnlBXFMLMP->Color = clLime;
               }
               // LMPSEL設定失敗
               else if(ReplyStrBXFM.Pos("LMPSEL !") > 0) {
                  boolclearerrorcode = true;
                  pnlBXFMLMP->Color = clRed;
               }

               // CUBE設定成功
               if(ReplyStrBXFM.Pos("CUBE +") > 0) {
                  boolclearerrorcode = true;
                  pnlBXFMCube->Color = clLime;
               }
               // CUBE設定失敗
               else if(ReplyStrBXFM.Pos("CUBE !") > 0) {
                  boolclearerrorcode = true;
                  pnlBXFMCube->Color = clRed;
               }

               // EAS設定成功
               if(ReplyStrBXFM.Pos("EAS +") > 0) {
                  boolclearerrorcode = true;
                  pnlBXFMAS->Color = clLime;
               }
               // EAS設定失敗
               else if(ReplyStrBXFM.Pos("EAS !") > 0) {
                  boolclearerrorcode = true;
                  pnlBXFMAS->Color = clRed;
               }

               // Filter Wheel1設定成功
               if(ReplyStrBXFM.Pos("FW1 +") > 0) {
                  boolclearerrorcode = true;
                  pnlBXFMFilter1->Color = clLime;
               }
               // Filter Wheel1設定失敗
               else if(ReplyStrBXFM.Pos("FW1 !") > 0) {
                  boolclearerrorcode = true;
                  pnlBXFMFilter1->Color = clRed;
               }
               // Filter Wheel2設定成功
               if(ReplyStrBXFM.Pos("FW2 +") > 0) {
                  boolclearerrorcode = true;
                  pnlBXFMFilter2->Color = clLime;
               }
               // Filter Wheel2設定失敗
               else if(ReplyStrBXFM.Pos("FW2 !") > 0) {
                  boolclearerrorcode = true;
                  pnlBXFMFilter2->Color = clRed;
               }

               // LMPSTS => X or OK
               if(ReplyStrBXFM.Pos("LMPSTS ") > 0) {
                  boolclearerrorcode = true;
                  if(ReplyStrBXFM.Pos("LMPSTS OK") > 0) {
                     pnlBXFMLampStatus->Color = clLime;
                  }
                  else if(ReplyStrBXFM.Pos("LMPSTS X") > 0) {
                     pnlBXFMLampStatus->Color = clRed;
                  }
               }

               // LMP + / LMP ! / LMP Value
               // LMP設定成功
               if(ReplyStrBXFM.Pos("LMP +") > 0) {
                  boolclearerrorcode = true;
                  pnlBXFMLampSet->Color = clLime;
               }
               // LMP設定失敗
               else if(ReplyStrBXFM.Pos("LMP !") > 0) {
                  boolclearerrorcode = true;
                  pnlBXFMLampSet->Color = clRed;
               }
               // 取值
               else if(ReplyStrBXFM.Pos("LMP ") > 0) {
                  boolclearerrorcode = true;
                  pos = ReplyStrBXFM.Pos("LMP ");
                  len = ReplyStrBXFM.Length();
                  // LMP 123
                  // 1234567890
                  if((len-pos-3) >= 0) {
                     svalue = ReplyStrBXFM.SubString(pos+4,(len-pos-3));
                     pnlBXFMLMPValue->Caption = svalue;
                     tbBXFMLMP->Position = svalue.ToInt();
                  }
               }

               // A2M
               // 2022 8 9 - chc AF
               if(ReplyStrBXFM.Pos("AF +") > 0) {
                  boolclearerrorcode = true;
                  pnlA2MAF->Color = clLime;
               }
               if(ReplyStrBXFM.Pos("AF !") > 0) {
                  boolclearerrorcode = true;
                  pnlA2MAF->Color = clRed;
               }
               // 2022 8 9 - chc AF Far
               if(ReplyStrBXFM.Pos("AFFLMT +") > 0) {
                  boolclearerrorcode = true;
                  pnlA2MAFFarSet->Color = clLime;
               }
               if(ReplyStrBXFM.Pos("AFFLMT !") > 0) {
                  boolclearerrorcode = true;
                  pnlA2MAFFarSet->Color = clRed;
               }
               // 2022 8 9 - chc AF Near
               if(ReplyStrBXFM.Pos("AFNLMT +") > 0) {
                  boolclearerrorcode = true;
                  pnlA2MAFNearSet->Color = clLime;
               }
               if(ReplyStrBXFM.Pos("AFNLMT !") > 0) {
                  boolclearerrorcode = true;
                  pnlA2MAFNearSet->Color = clRed;
               }
               // 2022 8 9 - chc Z Far
               if(ReplyStrBXFM.Pos("FARLMT +") > 0) {
                  boolclearerrorcode = true;
                  pnlA2MZFarSet->Color = clLime;
               }
               if(ReplyStrBXFM.Pos("FARLMT !") > 0) {
                  boolclearerrorcode = true;
                  pnlA2MZFarSet->Color = clRed;
               }
               // 2022 8 9 - chc Z Near
               if(ReplyStrBXFM.Pos("NEARLMT +") > 0) {
                  boolclearerrorcode = true;
                  pnlA2MZNearSet->Color = clLime;
               }
               if(ReplyStrBXFM.Pos("NEARLMT !") > 0) {
                  boolclearerrorcode = true;
                  pnlA2MZNearSet->Color = clRed;
               }
               // AFTBL
               if(ReplyStrBXFM.Pos("AFTBL +") > 0) {
                  boolclearerrorcode = true;
                  pnlA2MAFTBL->Color = clLime;
               }
               if(ReplyStrBXFM.Pos("AFTBL !") > 0) {
                  boolclearerrorcode = true;
                  pnlA2MAFTBL->Color = clRed;
               }
               // AFSTS: FOCUS, SRCH, TRACE, WAIT, OFF
               if(ReplyStrBXFM.Pos("AFSTS ") > 0) {
                  boolclearerrorcode = true;
                  pos = ReplyStrBXFM.Pos("AFSTS ");
                  len = ReplyStrBXFM.Length();
                  // AFSTS FOCUS
                  // 12345678901
                  // 11 - 1 - 5 = 5
                  if((len-pos-5) >= 0) {
                     svalue = ReplyStrBXFM.SubString(pos+6,(len-pos-5));
                     pnlA2MAFStatus->Caption = svalue;
                  }
               }
               // INITORG
               if(ReplyStrBXFM.Pos("INITORG +") > 0) {
                  boolclearerrorcode = true;
                  pnlA2MORG->Color = clLime;
               }
               if(ReplyStrBXFM.Pos("INITORG !") > 0) {
                  boolclearerrorcode = true;
                  pnlA2MORG->Color = clRed;
               }
               // INITRET
               if(ReplyStrBXFM.Pos("INITRET +") > 0) {
                  boolclearerrorcode = true;
                  pnlA2MRET->Color = clLime;
               }
               if(ReplyStrBXFM.Pos("INITRET !") > 0) {
                  boolclearerrorcode = true;
                  pnlA2MRET->Color = clRed;
               }
               // MOV
               if(ReplyStrBXFM.Pos("MOV +") > 0) {
                  boolclearerrorcode = true;
                  pnlA2MZMove->Color = clLime;
               }
               if(ReplyStrBXFM.Pos("MOV !") > 0) {
                  boolclearerrorcode = true;
                  pnlA2MZMove->Color = clRed;
               }
               // APOS: 取值
               if(ReplyStrBXFM.Pos("APOS ") > 0) {
                  boolclearerrorcode = true;
                  pos = ReplyStrBXFM.Pos("APOS ");
                  len = ReplyStrBXFM.Length();
                  // LMP 123
                  // 1234567890
                  if((len-pos-3) >= 0) {
                     svalue = ReplyStrBXFM.SubString(pos+4,(len-pos-3));
                     pnlA2MAPos->Caption = svalue;
                  }
               }
               // POS: 取值
               else if(ReplyStrBXFM.Pos("POS ") > 0) {
                  boolclearerrorcode = true;
                  pos = ReplyStrBXFM.Pos("POS ");
                  len = ReplyStrBXFM.Length();
                  // LMP 123
                  // 1234567890
                  if((len-pos-3) >= 0) {
                     svalue = ReplyStrBXFM.SubString(pos+4,(len-pos-3));
                     pnlA2MPos->Caption = svalue;
                  }
               }

               // 2020 5 20 - chc Clear Error Code & Msg
               if(boolclearerrorcode == true) {
                  // Error code
                  pnlBXFMErrorCode->Caption = "";
               }

               // Clear
               ReplyStrBXFM = "";

            }
            else {
               if(ReplyStrBXFM == "")
                  ReplyStrBXFM += "<";
               ReplyStrBXFM += Buf[i];
            }
         }
         pnlBXFMOperation->Caption = "Ready";
         pnlBXFM->Enabled = true;
      }

   // 先不管
   //}

   if(pnlBXFM->Enabled == true) {
      btnBXFMEnable->Visible = false;
      //if(boolstas == true) {
      //   WriteSystemLog("BXFM: 是xxxx, 執行GetLMP...");
      //   btnBXFMGetLMPClick(this);
      //}
   }

}
//---------------------------------------------------------------------------
// mmBXFMMsg Recv
void __fastcall TfrnMain::AddBXFMRecvMessage(AnsiString msg)
{
AnsiString putmsg;

   //putmsg = Now().FormatString("hh':'nn':'ss'-> '") + msg;
   //mmBXFMMsg->Lines->Insert(0,putmsg);
   //if(mmBXFMMsg->Lines->Count > 400) {
   //   for(int i=370 ; i<mmBXFMMsg->Lines->Count ; i++)
   //      mmBXFMMsg->Lines->Delete(i);
   //}

   // 2022 9 6 - chc 固定要清除, 否則速度會變慢!
   if(mmBXFMMsg->Lines->Count > 400) {
      for(int i=320 ; i<mmBXFMMsg->Lines->Count ; i++)
         mmBXFMMsg->Lines->Delete(i);
   }

   //putmsg = "<" + msg;
   //putmsg = msg;
   //mmBXFMMsg->Lines->Insert(0,putmsg);
   putmsg = Now().FormatString("nn':'ss':'zzz' < '") + msg;
   mmBXFMMsg->Lines->Insert(0,putmsg);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::pnlBXFMErrorCodeClick(TObject *Sender)
{

   pnlBXFMErrorCode->Caption = "";
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnBXFMGetLMPClick(TObject *Sender)
{

   edBXFMCmd->Text = "LMP?";
   btnBXFMCMDClick(this);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::rgBXFMFilter2Change(TObject *Sender,
      int ButtonIndex)
{
int no;

   pnlBXFMFilter2->Color = clSilver;
   no = rgBXFMFilter2->ItemIndex + 1;
   edBXFMCmd->Text = "FW2 " + IntToStr(no);
   btnBXFMCMDClick(this);
}
//---------------------------------------------------------------------------
// BXFM.ini
// LMP/CUBE/EAS/OB/Filter/Control/AS/Switch
void __fastcall TfrnMain::btnBXFMSaveClick(TObject *Sender)
{
TIniFile *pSystemFile;
AnsiString str,fname;
int ivalue;

   pnlSystemMessage->Caption = "BXFM參數更新中...";
   pnlBXFMMessage->Caption = pnlSystemMessage->Caption;
   // ini檔名與目錄
   fname = SystemDirectory + "\\BXFM.ini";
   pSystemFile = new TIniFile(fname);

   // BXFM
   // control
   ivalue = rgBXFMControl->ItemIndex;
   pSystemFile->WriteInteger("BXFM" ,"Control"                                  ,ivalue);
   // OB
   ivalue = rgBXFMLens->ItemIndex;
   pSystemFile->WriteInteger("BXFM" ,"OB"                                       ,ivalue);
   // CUBE
   ivalue = rgBXFMCube->ItemIndex;
   pSystemFile->WriteInteger("BXFM" ,"CUBE"                                     ,ivalue);
   // EAS
   ivalue = rgBXFMLMP->ItemIndex;
   pSystemFile->WriteInteger("BXFM" ,"EAS"                                      ,ivalue);
   // Filter
   ivalue = rgBXFMFilter1->ItemIndex;
   pSystemFile->WriteInteger("BXFM" ,"Filter Wheel1"                            ,ivalue);
   ivalue = rgBXFMFilter2->ItemIndex;
   pSystemFile->WriteInteger("BXFM" ,"Filter Wheel2"                            ,ivalue);
   // LMP
   ivalue = tbBXFMLMP->Position;
   pSystemFile->WriteInteger("BXFM" ,"LMP"                                      ,ivalue);
   // AS
   ivalue = tbBXFMAS->Position;
   pSystemFile->WriteInteger("BXFM" ,"AS"                                       ,ivalue);
   // Switch
   ivalue = rgBXFMLMPSwitch->ItemIndex;
   pSystemFile->WriteInteger("BXFM" ,"Switch"                                   ,ivalue);

   delete pSystemFile;
   pnlSystemMessage->Caption = "BXFM參數更新完成.";
   pnlBXFMMessage->Caption = pnlSystemMessage->Caption;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnBXFMEnableClick(TObject *Sender)
{

   pnlBXFM->Enabled = true;
   btnBXFMEnable->Visible = false;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::tbBXFMLMPMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{
int no;

   // 2022 7 25 - chc 已進入formshow
   if(boolFormshow == false)
      return;

   pnlBXFMLampSet->Color = clSilver;
   no = tbBXFMLMP->Position;
   pnlBXFMLMPValue->Caption = IntToStr(no);
   edBXFMCmd->Text = "LMP " + IntToStr(no);
   btnBXFMCMDClick(this);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::tbBXFMASMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{
int no;

   if(boolFormshow == false)
      return;

   pnlBXFMAS->Color = clSilver;
   no = tbBXFMAS->Position;
   edBXFMCmd->Text = "EAS " + IntToStr(no);
   btnBXFMCMDClick(this);
}
//---------------------------------------------------------------------------
// BXFM.ini
// LMP/CUBE/EAS/OB/Filter/Control/AS/Switch
// 2022 8 23 - chc Load BXFM/A2M Parameter: 但不執行
//void __fastcall TfrnMain::ReadBXFMParameter()
void __fastcall TfrnMain::ReadBXFMParameter(int mode)
{
TIniFile *pSystemFile;
AnsiString str,fname;
int ivalue;

   pnlSystemMessage->Caption = "BXFM參數讀取中...";
   WriteSystemLog(pnlSystemMessage->Caption);
   pnlBXFMMessage->Caption = pnlSystemMessage->Caption;
   // ini檔名與目錄
   fname = SystemDirectory + "\\BXFM.ini";
   pSystemFile = new TIniFile(fname);

   // BXFM
   // control
   ivalue = pSystemFile->ReadInteger("BXFM" ,"Control"                          ,BXFM_CONTROL_REMOTE);
   rgBXFMControl->ItemIndex = ivalue;
   if(mode == 1)
      rgBXFMControlChange(this,1);
   rgA2MControl->ItemIndex = ivalue;
   if(mode == 1)
      rgA2MControlChange(this,1);
   // Switch
   ivalue = pSystemFile->ReadInteger("BXFM" ,"Switch"                           ,BXFM_LMP_SWITCH_ON);
   rgBXFMLMPSwitch->ItemIndex = ivalue;
   if(mode == 1)
      rgBXFMLMPSwitchChange(this,1);
   // OB
   ivalue = pSystemFile->ReadInteger("BXFM" ,"OB"                               ,1);
   rgBXFMLens->ItemIndex = ivalue;
   frmInspection->rgBXFMLens->ItemIndex = ivalue;
   frmMaintenance->rgBXFMLens->ItemIndex = ivalue;
   //rgBXFMLensChange(this,1);
   if(mode == 1)
      SelectLens(ivalue+1);
   // CUBE
   ivalue = pSystemFile->ReadInteger("BXFM" ,"CUBE"                             ,BXFM_CUBE_BF);
   rgBXFMCube->ItemIndex = ivalue;
   if(mode == 1)
      rgBXFMCubeChange(this,1);
   // EAS
   ivalue = pSystemFile->ReadInteger("BXFM" ,"EAS"                              ,BXFM_LMP_EPI);
   rgBXFMLMP->ItemIndex = ivalue;
   if(mode == 1)
      rgBXFMLMPChange(this,1);
   // Filter
   ivalue = pSystemFile->ReadInteger("BXFM" ,"Filter Wheel1"                     ,0);
   rgBXFMFilter1->ItemIndex = ivalue;
   if(mode == 1)
      rgBXFMFilter1Change(this,1);
   ivalue = pSystemFile->ReadInteger("BXFM" ,"Filter Wheel2"                     ,0);
   rgBXFMFilter2->ItemIndex = ivalue;
   if(mode == 1)
      rgBXFMFilter2Change(this,1);
   // LMP
   ivalue = pSystemFile->ReadInteger("BXFM" ,"LMP"                              ,10);
   tbBXFMLMP->Position = ivalue;
   if(mode == 1)
      SetBXFMLMP();
   // AS
   ivalue = pSystemFile->ReadInteger("BXFM" ,"AS"                               ,3113);
   tbBXFMAS->Position = ivalue;
   frmInspection->pnlASValue->Caption = IntToStr(ivalue);
   if(mode == 1)
      SetBXFMAS();

   delete pSystemFile;
   pnlSystemMessage->Caption = "BXFM參數讀取完成.";
   WriteSystemLog(pnlSystemMessage->Caption);
   pnlBXFMMessage->Caption = pnlSystemMessage->Caption;
}
//---------------------------------------------------------------------------
// 2022 7 25 - chc 也做BXFM的設定
// Control/LMP/OB/CUBE/LMPSelect/Switch/AS/Filter Wheel
void __fastcall TfrnMain::SetBXFMValue()
{
int cnt,no;

   if(boolBXFMStatus == false) {
      pnlSystemMessage->Caption = "BXFM通訊失敗!";
      pnlBXFMMessage->Caption = pnlSystemMessage->Caption;
      WriteSystemLog(pnlSystemMessage->Caption);
      return;
   }

   // Control
   pnlBXFMControl->Color = clSilver;
   // Local
   if(rgBXFMControl->ItemIndex == 0)
      edBXFMCmd->Text = "LOG OUT";
   // Remote
   else
      edBXFMCmd->Text = "LOG IN";
   btnBXFMCMDClick(this);
   cnt = 0;
   // 2000ms
   while(1) {
      if(pnlBXFMControl->Color != clSilver)
         break;
      Sleep(10);
      Application->ProcessMessages();
      cnt++;
      if(cnt > 200) {
         pnlSystemMessage->Caption = "BXFM通訊(LOG)Timeout!";
         pnlBXFMMessage->Caption = pnlSystemMessage->Caption;
         WriteSystemLog(pnlSystemMessage->Caption);
         //break;
         return;
      }
   }

   Sleep(300);
   // OB
   pnlBXFMLens->Color = clSilver;
   no = rgBXFMLens->ItemIndex + 1;
   edBXFMCmd->Text = "OB " + IntToStr(no);
   btnBXFMCMDClick(this);
   cnt = 0;
   // 2000ms
   while(1) {
      if(pnlBXFMLens->Color != clSilver)
         break;
      Sleep(10);
      Application->ProcessMessages();
      cnt++;
      if(cnt > 200) {
         pnlSystemMessage->Caption = "BXFM通訊(OB)Timeout!";
         pnlBXFMMessage->Caption = pnlSystemMessage->Caption;
         WriteSystemLog(pnlSystemMessage->Caption);
         //break;
         return;
      }
   }

   Sleep(300);
   // Switch
   pnlBXFMLMPSwitch->Color = clSilver;
   // On
   if(rgBXFMLMPSwitch->ItemIndex == 0)
      edBXFMCmd->Text = "LMPSW ON";
   // Off
   else
      edBXFMCmd->Text = "LMPSW OFF";
   btnBXFMCMDClick(this);
   cnt = 0;
   // 2000ms
   while(1) {
      if(pnlBXFMLMPSwitch->Color != clSilver)
         break;
      Sleep(10);
      Application->ProcessMessages();
      cnt++;
      if(cnt > 200) {
         pnlSystemMessage->Caption = "BXFM通訊(LMP Switch)Timeout!";
         pnlBXFMMessage->Caption = pnlSystemMessage->Caption;
         WriteSystemLog(pnlSystemMessage->Caption);
         //break;
         return;
      }
   }

   Sleep(300);
   // CUBE
   pnlBXFMCube->Color = clSilver;
   // Bright
   if(rgBXFMCube->ItemIndex == 0)
      edBXFMCmd->Text = "CUBE 1";
   // Remote
   else
      edBXFMCmd->Text = "CUBE 2";
   btnBXFMCMDClick(this);
   cnt = 0;
   // 2000ms
   while(1) {
      if(pnlBXFMCube->Color != clSilver)
         break;
      Sleep(10);
      Application->ProcessMessages();
      cnt++;
      if(cnt > 200) {
         pnlSystemMessage->Caption = "BXFM通訊(CUBE)Timeout!";
         pnlBXFMMessage->Caption = pnlSystemMessage->Caption;
         WriteSystemLog(pnlSystemMessage->Caption);
         //break;
         return;
      }
   }

   Sleep(300);
   // LMPSEL
   pnlBXFMLMP->Color = clSilver;
   // Transmitted
   if(rgBXFMLMP->ItemIndex == 0)
      edBXFMCmd->Text = "LMPSEL DIA";
   // Refelected
   else
      edBXFMCmd->Text = "LMPSEL EPI";
   btnBXFMCMDClick(this);
   cnt = 0;
   // 2000ms
   while(1) {
      if(pnlBXFMLMP->Color != clSilver)
         break;
      Sleep(10);
      Application->ProcessMessages();
      cnt++;
      if(cnt > 200) {
         pnlSystemMessage->Caption = "BXFM通訊(LMPSEL)Timeout!";
         pnlBXFMMessage->Caption = pnlSystemMessage->Caption;
         WriteSystemLog(pnlSystemMessage->Caption);
         //break;
         return;
      }
   }

   Sleep(300);
   // LMP
   pnlBXFMLampSet->Color = clSilver;
   no = tbBXFMLMP->Position;
   pnlBXFMLMPValue->Caption = IntToStr(no);
   edBXFMCmd->Text = "LMP " + IntToStr(no);
   btnBXFMCMDClick(this);
   cnt = 0;
   // 2000ms
   while(1) {
      if(pnlBXFMLampSet->Color != clSilver)
         break;
      Sleep(10);
      Application->ProcessMessages();
      cnt++;
      if(cnt > 200) {
         pnlSystemMessage->Caption = "BXFM通訊(LMP)Timeout!";
         pnlBXFMMessage->Caption = pnlSystemMessage->Caption;
         WriteSystemLog(pnlSystemMessage->Caption);
         //break;
         return;
      }
   }

   Sleep(300);
   // EAS
   pnlBXFMAS->Color = clSilver;
   no = tbBXFMAS->Position;
   edBXFMCmd->Text = "EAS " + IntToStr(no);
   btnBXFMCMDClick(this);
   cnt = 0;
   // 2000ms
   while(1) {
      if(pnlBXFMAS->Color != clSilver)
         break;
      Sleep(10);
      Application->ProcessMessages();
      cnt++;
      if(cnt > 200) {
         pnlSystemMessage->Caption = "BXFM通訊(EAS)Timeout!";
         pnlBXFMMessage->Caption = pnlSystemMessage->Caption;
         WriteSystemLog(pnlSystemMessage->Caption);
         //break;
         return;
      }
   }

   Sleep(300);
   // Filter Wheel1
   pnlBXFMFilter1->Color = clSilver;
   no = rgBXFMFilter1->ItemIndex + 1;
   edBXFMCmd->Text = "FW1 " + IntToStr(no);
   btnBXFMCMDClick(this);
   cnt = 0;
   // 2000ms
   while(1) {
      if(pnlBXFMFilter1->Color != clSilver)
         break;
      Sleep(10);
      Application->ProcessMessages();
      cnt++;
      if(cnt > 200) {
         pnlSystemMessage->Caption = "BXFM通訊(FW1)Timeout!";
         pnlBXFMMessage->Caption = pnlSystemMessage->Caption;
         WriteSystemLog(pnlSystemMessage->Caption);
         //break;
         return;
      }
   }

   Sleep(300);
   // Filter Wheel2
   pnlBXFMFilter2->Color = clSilver;
   no = rgBXFMFilter2->ItemIndex + 1;
   edBXFMCmd->Text = "FW2 " + IntToStr(no);
   btnBXFMCMDClick(this);
   cnt = 0;
   // 2000ms
   while(1) {
      if(pnlBXFMFilter2->Color != clSilver)
         break;
      Sleep(10);
      Application->ProcessMessages();
      cnt++;
      if(cnt > 200) {
         pnlSystemMessage->Caption = "BXFM通訊(FW2)Timeout!";
         pnlBXFMMessage->Caption = pnlSystemMessage->Caption;
         WriteSystemLog(pnlSystemMessage->Caption);
         //break;
         return;
      }
   }

}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::Panel27Click(TObject *Sender)
{

   return;
   // 改變ItemIndex並不會觸發OnChangeEvent
   if(rgBXFMControl->ItemIndex == 0)
      rgBXFMControl->ItemIndex = 1;
   else
      rgBXFMControl->ItemIndex = 0;

   // 改變Position會呼叫Change   
   tbBXFMAS->Position = 2000;
   frmInspection->pnlASValue->Caption = "2000";
   tbBXFMLMP->Position = 97;

}
//---------------------------------------------------------------------------


void __fastcall TfrnMain::btnQRCodeReadClick(TObject *Sender)
{
int no;
char buf[100];

   btnQRCodeRead->Enabled = false;

   edSocket->Text = "READ";
   btnSendClick(this);

   btnQRCodeRead->Enabled = true;
}
//---------------------------------------------------------------------------
// Chuck開真空
void __fastcall TfrnMain::ChuckVacuum(bool mode)
{

   // 2023 1 11 - chc Tazmo
   if(RobotMode != ROBOT_MODE_TAZMO) {
      cbBit0->Checked = mode;
      WriteDO(IO1_ID);
      // 在取放片作業時不用等
      if(boolInLoad == true || boolInUnLoad == true)
         return;
      WaitTime(1000);
   }

   if(mode == true) {
      // 12"
      if(rgCST->ItemIndex == LOADPORT_1) {
         cbBit0->Checked = false;
         cbBit1->Checked = true;
      }
      // 8"
      else {
         cbBit0->Checked = true;
         cbBit1->Checked = false;
      }
   }
   else {
      cbBit0->Checked = false;
      cbBit1->Checked = false;
   }
   WriteDO(IO1_ID);

   // 2022 8 22 - chc 在取放片作業時不用等
   if(boolInLoad == true || boolInUnLoad == true)
      return;

   WaitTime(1000);
}
//---------------------------------------------------------------------------
//   #define LOCATION_LP1               0
//   #define LOCATION_LP2               1
//   #define LOCATION_ALIGNER1          2
//   #define LOCATION_ALIGNER2          3
//   #define LOCATION_CHUCK             4
//   #define LOCATION_MACRO             5
// 2022 7 27 - chc 檢查W
// mode 0 - Get, 1 - Put
bool __fastcall TfrnMain::GoRobotWAxis(int mode)
{
int stageno,pos;

   stageno = rgWaferLocation->ItemIndex;
   // Robot: LP1/Aligner/Chuck/LP2/Macro
   // WAxis: LP1/LP2/Aligner/Chuck/Macro
   switch(stageno) {
      // LP1
      case LOCATION_LP1:
         btnToWPosition1Click(this);
         break;
      // LP2
      case LOCATION_LP2:
         btnToWPosition2Click(this);
         break;
      // Aligner1
      case LOCATION_ALIGNER1:
         btnToWPosition3Click(this);
         break;
      // Aligner2
      case LOCATION_ALIGNER2:
         btnToWPosition3Click(this);
         break;
      // Chuck
      case LOCATION_CHUCK:
         btnToWPosition4Click(this);
         break;
      // Macro
      case LOCATION_MACRO:
         btnToWPosition5Click(this);
         break;
   }
   if(pnlToWStatus->Color == clLime) {
      return true;
   }
   // Alarm
   Beep(500);
   return false;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnResetClick(TObject *Sender)
{

   pnlAlarmMessage->Caption = "";
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnQRCodeLogClick(TObject *Sender)
{

   btnQRCodeLog->Enabled = false;

   pnlQRCodeLog->Color = clSilver;
   pnlSocketConnect->Color = clSilver;
   csQRCode1->Active = false;
   csQRCode1->Port = 23;
   csQRCode1->Active = true;
   // 23, admin, SO1(連線), SO0(斷線)
   int cnt = 0;
   while(1) {
      Sleep(100);
      if(pnlSocketConnect->Color == clLime) {
         SendSocket("admin");
         Sleep(100);
         SendSocket("");
         Sleep(100);
         SendSocket("SO1");
         Sleep(100);
         pnlQRCodeLog->Color = clLime;
         // 斷線重連
         csQRCode1->Active = false;
         csQRCode1->Port = QRCodePort1;
         csQRCode1->Active = true;
         Sleep(100);
      }
      cnt++;
      if(cnt > 20) {
         pnlQRCodeLog->Color = clRed;
         WriteSystemLog("QRCode Port 23(Log)設定失敗!");
         // 斷線重連
         csQRCode1->Active = false;
         csQRCode1->Port = QRCodePort1;
         csQRCode1->Active = true;
         break;
      }
   }

   btnQRCodeLog->Enabled = true;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::cbPauseClick(TObject *Sender)
{

   cbDemoStep->Checked = cbPause->Checked;
}
//---------------------------------------------------------------------------
// BSFM	1LMP 1~120
void __fastcall TfrnMain::SetBXFMLMP()
{
int no;

   if(boolFormshow == false)
      return;

   pnlBXFMLampSet->Color = clSilver;
   no = tbBXFMLMP->Position;
   pnlBXFMLMPValue->Caption = IntToStr(no);
   edBXFMCmd->Text = "LMP " + IntToStr(no);
   btnBXFMCMDClick(this);
}
//---------------------------------------------------------------------------
// BXFM	1EAS 0~3113
void __fastcall TfrnMain::SetBXFMAS()
{
int no;

   if(boolFormshow == false)
      return;

   pnlBXFMAS->Color = clSilver;
   no = tbBXFMAS->Position;
   edBXFMCmd->Text = "EAS " + IntToStr(no);
   btnBXFMCMDClick(this);
}
//---------------------------------------------------------------------------
// 2022 8 7 - chc Select Lens
void __fastcall TfrnMain::btnLens1Click(TObject *Sender)
{

   SelectLens(1);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnLens2Click(TObject *Sender)
{

   SelectLens(2);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnLens3Click(TObject *Sender)
{

   SelectLens(3);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnLens4Click(TObject *Sender)
{

   SelectLens(4);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnLens5Click(TObject *Sender)
{

   SelectLens(5);
}
//---------------------------------------------------------------------------
void __fastcall TfrnMain::SelectLens(int no)
{
TLMDButton *button;

   // btnLens1
   button = (TLMDButton *)(frnMain->FindComponent("btnLens" + IntToStr(no)));
   pnlSelectedLens->Left = button->Left - 5;
   pnlLensLeft->Top = pnlSelectedLens->Top;
   pnlLensRight->Top = pnlSelectedLens->Top;
   pnlLensLeft->Left = pnlSelectedLens->Left;
   pnlLensRight->Left = pnlSelectedLens->Left + pnlSelectedLens->Width - pnlLensRight->Width;

   pnlLensSwitchResult->Color = clSilver;
   if(boolBXFMStatus == false) {
      pnlLensSwitchResult->Color = clRed;
      return;
   }
   rgBXFMLens->ItemIndex = no - 1;
   frmInspection->rgBXFMLens->ItemIndex = no - 1;
   frmMaintenance->rgBXFMLens->ItemIndex = no - 1;
   rgBXFMLensChange(this,1);
}
//---------------------------------------------------------------------------


void __fastcall TfrnMain::btnA2MORGClick(TObject *Sender)
{

   WriteSystemLog("進行A2M的ORG...");

   pnlA2MRET->Color = clSilver;
   edA2MCmd->Text = "INITRET OFF";
   btnA2MCMDClick(this);

   Sleep(1000);

   pnlA2MORG->Color = clSilver;
   edA2MCmd->Text = "INITORG";
   btnA2MCMDClick(this);

   WriteSystemLog("進行A2M的ORG.");

}
//---------------------------------------------------------------------------
// Select Table & AF
// Table: BF: 22... DF:32...
void __fastcall TfrnMain::btnA2MAFClick(TObject *Sender)
{
int mode,tableno;
AnsiString scmd;
int max = 40;

   pnlA2MAF->Color = clSilver;
   mode = rgA2MAFMode->ItemIndex;
   if(mode == 0)
      scmd = "REAL";
   else if(mode == 1)
      scmd = "SHOT";
   else {
      scmd = "OFF";
      max = 10;
   }
   // BF
   if(rgBXFMCube->ItemIndex == 0)
      tableno = 22;
   // DF
   else
      tableno = 32;
   tableno += rgBXFMLens->ItemIndex;

   // AFTBL
   pnlA2MAFTBL->Color = clSilver;
   edA2MCmd->Text = "AFTBL " + IntToStr(tableno);
   btnA2MCMDClick(this);

   Sleep(100);

   // AF
   pnlA2MAFStatus->Caption = "";
   pnlA2MAFStatus->Color = (TColor)0x008B8B8B;
   pnlA2MAF->Color = clSilver;
   edA2MCmd->Text = "AF " + scmd;
   btnA2MCMDClick(this);

   // Timeout : 20sec
   int cnt = 0;
   // AFSTS: FOCUS, SRCH, TRACE, WAIT, OFF
   while(1) {
      if(pnlA2MAF->Color != clSilver)
         break;
      DelayTime(500);
      cnt++;
      if(cnt > max) {
         pnlA2MAFStatus->Color = clRed;
         pnlA2MAFStatus->Caption = "T.Out";
         pnlA2MAF->Color = clRed;
         WriteSystemLog("A2M AF Timeout!");
         break;
      }
      // AFSTS?
      edA2MCmd->Text = "AFSTS?";
      btnA2MCMDClick(this);
      if(mode == 2) {
         if(pnlA2MAFStatus->Caption == "TRACE") {
            pnlA2MAF->Color = clLime;
            break;
         }
      }
      else {
         if(pnlA2MAFStatus->Caption == "OFF") {
            pnlA2MAF->Color = clLime;
            break;
         }
      }
   }

}
//---------------------------------------------------------------------------
// A, AF
void __fastcall TfrnMain::btnA2MSetClick(TObject *Sender)
{
int z,af,lensno;

   pnlA2MSet->Color = clSilver;
   lensno = rgBXFMLens->ItemIndex;
   if(lensno == 0) {
      z = edA2MLens1Z->Text.ToInt();
      af = edA2MLens1AF->Text.ToInt();
   }
   else if(lensno == 1) {
      z = edA2MLens2Z->Text.ToInt();
      af = edA2MLens2AF->Text.ToInt();
   }
   else if(lensno == 2) {
      z = edA2MLens3Z->Text.ToInt();
      af = edA2MLens3AF->Text.ToInt();
   }
   else if(lensno == 3) {
      z = edA2MLens4Z->Text.ToInt();
      af = edA2MLens4AF->Text.ToInt();
   }
   else if(lensno == 4) {
      z = edA2MLens5Z->Text.ToInt();
      af = edA2MLens5AF->Text.ToInt();
   }
   // 取得APOS, 再AMOV到指定position
   int cnt,max,apos,offset;
   AnsiString scmd;
   btnA2MAPosClick(this);
   cnt = 0;
   max = 20;
   while(1) {
      if(pnlA2MAPos->Caption != "")
         break;
      WaitTime(100);
      cnt++;
      if(cnt > max) {
         pnlA2MSet->Color = clRed;
         WriteSystemLog("APOS取得失敗!");
         return;
      }
   }

   // 2022 9 6 - chc 處理"X"問題
   try {
      if(pnlA2MAPos->Caption == "X")
         apos = 0;
      else
         apos = pnlA2MAPos->Caption.ToInt();
   }
   catch(Exception &e) {
      WriteSystemLog("APos - Error");
      sbSystem->Panels->Items[1]->Text = "APos - Error";
      apos = 0;
   }

   offset = af - apos;
   if(offset != 0) {
      if(offset > 0) {
         scmd.sprintf("AMOV N,%d",offset);
      }
      else {
         scmd.sprintf("AMOV F,%d",abs(offset));
      }
      edA2MCmd->Text = scmd;
      btnA2MCMDClick(this);
   }
}
//---------------------------------------------------------------------------
// AFFLMT, AFNLMT
void __fastcall TfrnMain::btnA2MAFNearFarSetClick(TObject *Sender)
{
int nearv,farv;

   nearv = edA2MAFNear->Text.ToInt();
   farv = edA2MAFFar->Text.ToInt();

   pnlA2MAFFarSet->Color = clSilver;
   edA2MCmd->Text = "AFFLMT " + IntToStr(farv);
   btnA2MCMDClick(this);
   Sleep(500);
   pnlA2MAFNearSet->Color = clSilver;
   edA2MCmd->Text = "AFNLMT " + IntToStr(nearv);
   btnA2MCMDClick(this);
}
//---------------------------------------------------------------------------
AnsiString A2MCmd;
void __fastcall TfrnMain::btnA2MCMDClick(TObject *Sender)
{
unsigned char command[50],buf[50];
AnsiString msg;
int len,pos;

   if(boolBXFMStatus == false) {
      pnlA2MMessage->Caption = "未連線!";
      WriteSystemLog("btnA2MCMDClick: A2M尚未連線!");
      return;
   }

   // A2M
   sprintf(command,"2%s\r\n",edA2MCmd->Text);

   len = strlen(command);
   pos = edA2MCmd->Text.Pos("?");
   if(pos > 0)
      A2MCmd = edA2MCmd->Text.SubString(1,pos-1);
   else {
      pos = edA2MCmd->Text.Pos(" ");
      if(pos > 0)
         A2MCmd = edA2MCmd->Text.SubString(1,pos-1);
      else
         A2MCmd = "";
   }

   WriteSystemLog("btnA2MCMDClick: run...");
   ybBXFM->Write(command,len);
   pnlBXFMOperation->Caption = "Busy";
   pnlBXFM->Enabled = false;
   btnBXFMEnable->Visible = true;

   sprintf(command,"2%s",edA2MCmd->Text);
   msg.sprintf("CMD: %s",command);
   pnlSystemMessage->Caption = msg;
   WriteSystemLog(msg);

   AddA2MSendMessage(edA2MCmd->Text);
   pnlA2MMessage->Caption = msg;
   WriteSystemLog("btnA2MCMDClick: edA2MMCmd= " + edA2MCmd->Text);
}
//---------------------------------------------------------------------------
// A2M Send
void __fastcall TfrnMain::AddA2MSendMessage(AnsiString msg)
{
AnsiString putmsg;

   //putmsg = Now().FormatString("hh':'nn':'ss'-> '") + msg;
   //mmA2MMsg->Lines->Insert(0,putmsg);
   //if(mmA2MMsg->Lines->Count > 400) {
   //   for(int i=370 ; i<mmA2MMsg->Lines->Count ; i++)
   //      mmA2MMsg->Lines->Delete(i);
   //}

   // 2022 9 6 - chc 固定要清除, 否則速度會變慢!
   if(mmA2MMsg->Lines->Count > 400) {
      for(int i=320 ; i<mmA2MMsg->Lines->Count ; i++)
         mmA2MMsg->Lines->Delete(i);
   }

   //putmsg = ">" + msg;
   //mmA2MMsg->Lines->Insert(0,putmsg);
   putmsg = Now().FormatString("nn':'ss':'zzz' > '") + msg;
   mmA2MMsg->Lines->Insert(0,putmsg);
}
//---------------------------------------------------------------------------
// mmA2MMsg Recv
void __fastcall TfrnMain::AddA2MRecvMessage(AnsiString msg)
{
AnsiString putmsg;

   //putmsg = Now().FormatString("hh':'nn':'ss'-> '") + msg;
   //mmA2MMsg->Lines->Insert(0,putmsg);
   //if(mmA2MMsg->Lines->Count > 400) {
   //   for(int i=370 ; i<mmA2MMsg->Lines->Count ; i++)
   //      mmA2MMsg->Lines->Delete(i);
   //}

   // 2022 9 6 - chc 固定要清除, 否則速度會變慢! 370改成320
   if(mmA2MMsg->Lines->Count > 400) {
      for(int i=320 ; i<mmA2MMsg->Lines->Count ; i++)
         mmA2MMsg->Lines->Delete(i);
   }

   //putmsg = "<" + msg;
   //putmsg = msg;
   //mmA2MMsg->Lines->Insert(0,putmsg);
   putmsg = Now().FormatString("nn':'ss':'zzz' < '") + msg;
   mmA2MMsg->Lines->Insert(0,putmsg);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::rgA2MControlChange(TObject *Sender,
      int ButtonIndex)
{

   pnlA2MControl->Color = clSilver;
   // Local
   if(rgA2MControl->ItemIndex == 0)
      edA2MCmd->Text = "LOG OUT";
   // Remote
   else
      edA2MCmd->Text = "LOG IN";
   btnA2MCMDClick(this);
}
//---------------------------------------------------------------------------
// 2022 9 5 - chc 雙片作業
//bool boolInLoopTest = false;
bool boolGetNextWafer = false;
bool boolChuckMeasure = false;
bool boolChuckMeasureResult = false;
bool boolMacroDemo = false;
bool boolMacroDemoResult = false;

// 2022 8 12 - chc 記錄Aligner Step
int AlignerStep = 0;
int WaferGetStep = 0;

// 2022 8 9 - chc 取片
void __fastcall TfrnMain::btnLoadWaferClick(TObject *Sender)
{
int no,timeout;
TPanel *panel,*panel1,*panela;
long StartTime,StopTime,Elapsedms;
short StartTick,StopTick;
int cnt = 0;
int workno,nextno;

   // 記錄目前是否在做取退片? boolInLoadWafer, boolInUnLoadWafer
   // 2022 8 14 - chc 是boolInLoad才對
   //boolInLoadWafer = true;
   boolInLoad = true;

   // 2022 9 5 - chc 雙片作業(LoopTest)
   bool boolmacrofirst = false;
   if(cbDoubleWafer->Checked == true && boolInLoopTest == true) {
      if(StageInformation[STAGE_MACRO].boolWithWafer == true) {
         no = StageInformation[STAGE_MACRO].SlotNo;
         rgWaferNo->ItemIndex = 25 - no;
         // 確認Macro Demo是否完成?
         if(boolMacroDemo == false) {
            pnlOperationMessage->Caption = "取片失敗: Macro Demo未進行!";
            WriteSystemLog(pnlOperationMessage->Caption);

            // 2022 9 14a - chc 等5Sec
            WriteSystemLog("再等Macro Demo 5Sec...");
            for(int i=0 ; i<50 ; i++) {
               Sleep(100);
               Application->ProcessMessages();
               if(boolMacroDemo == true) {
                  WriteSystemLog("Macro Demo Done.");
                  goto mdone;
               }
            }
            WriteSystemLog("再等Macro Demo 5Sec Fail!");

            goto error;
         }
mdone:
         boolmacrofirst = true;
         goto start;
         // Macro取片
         // Aligner放片
         // Aligner取片
         // Chuck放片
         // Chuck 5 點量測(Timer)
      }
   }

   // 2022 8 15 - chc 先詢問取片
   //
   no = 25 - rgWaferNo->ItemIndex;
   if(btnLoopTestStop->Visible == false) {
      if(Application->MessageBox(("準備由Cassette取第" + IntToStr(no) + "片?      ").c_str(), "取片作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         pnlLoadWafer->Color = clPurple;
         goto error;
      }
   }
   //
start:
   WriteSystemLog("取片作業開始");

   pnlOperationTime->Caption = "0";
   GetTimeTic(&OPStartTime,&OPStartTick);

   // 取片: 不可用Start - Run
   btnStartRun->Enabled = false;
   // Message
   pnlOperationMessage->Caption = "取片...";
   WriteSystemLog(pnlOperationMessage->Caption);

   // for test
   if(boolForTest == true) {
      // Load後的第一片?
      if(boolFirstAfterLoad == true)
         SetFristWafer();
      no = 25 - rgWaferNo->ItemIndex;
      // Foup?
      if(rgFoupSource->ItemIndex == LOADPORT_2) {
         panel = (TPanel*)(FindComponent("pnlTray2_" + IntToStr(no)));
         panel1 = (TPanel*)(FindComponent("pnlTray2_" + IntToStr(no) + "Select"));
      }
      else {
         panel = (TPanel*)(FindComponent("pnlTray" + IntToStr(no)));
         panel1 = (TPanel*)(FindComponent("pnlTray" + IntToStr(no) + "Select"));
      }
      panela = (TPanel*)(frmRecipe->FindComponent("pnlTray" + IntToStr(no)));
      // 要看Select
      if(panel->Color != clLime || panel1->Color != clLime) {
         pnlLoadWafer->Color = clRed;
         pnlOperationMessage->Caption = "取片失敗: 指定位置無Wafer!";
         WriteSystemLog(pnlOperationMessage->Caption);
         // Alarm
         if(boolCSTWithoutWafer == false) {
            boolCSTWithoutWafer = true;
            //SetSECSAlarm(41001,1,0,"CST Without Wafer");
         }
         // 記錄目前是否在做取退片? boolInLoadWafer, boolInUnLoadWafer
         // 2022 8 14 - chc 是boolInLoad才對
         //boolInLoadWafer = false;
         boolInLoad = false;

         return;
      }
      // Alarm
      if(boolCSTWithoutWafer == true) {
         boolCSTWithoutWafer = false;
         //SetSECSAlarm(41001,0,0,"CST Without Wafer");
      }
      panel->Color = clOlive;
      panel1->Color = clOlive;
      panela->Color = clOlive;
      btnUnloadWafer->Enabled = true;
      // 記錄為Load後的第一片
      boolFirstAfterLoad = false;
      // 記錄目前是否在做取退片? boolInLoadWafer, boolInUnloadWafer
      // 2022 8 14 - chc 是boolInLoad才對
      //boolInLoadWafer = false;
      boolInLoad = false;

      return;
   }

   // 關閉UI
   pcSystem->Enabled = false;
   // 2021 8 24 - chc 啟動Start
   tsOperation->Enabled = false;

   // 記錄Load button狀態
   bool boolloadbutton,boolload2button;
   boolloadbutton = btnCassetteLoad->Enabled;
   boolload2button = btnCassette2Load->Enabled;
   btnCassetteLoad->Enabled = false;
   btnCassette2Load->Enabled = false;
   frmRecipe->btnCassetteLoad->Enabled = false;
   frmRecipe->btnCassette2Load->Enabled = false;

   // 2022 9 6 - chc 雙片作業
   if(boolmacrofirst == true)
      goto macroget;

   // Mapping Error
   if((rgFoupSource->ItemIndex == LOADPORT_1 && boolMappingStatus == false) || (rgFoupSource->ItemIndex == LOADPORT_2 && boolMappingStatus2 == false)) {
      pnlLoadWafer->Color = clRed;
      pnlOperationMessage->Caption = "無法取片: Cassette Mapping Error!";
      WriteSystemLog(pnlOperationMessage->Caption);
      // Alarm
      if(boolWaferNotSpecified == false) {
         boolWaferNotSpecified = true;
         //SetSECSAlarm(41006,1,0,"Wafer not Specified");
      }
      goto error;
   }

   // Alarm
   if(boolWaferNotSpecified == true) {
      boolWaferNotSpecified = false;
      //SetSECSAlarm(41006,0,0,"Wafer not Specified");
   }

   // 記錄取片中
   boolInLoad = true;
   // 先Disable: pcRobot & Cassette選項
   pcRobot->Enabled = false;
   pnlCassetteStatus->Enabled = false;
   pnlCassette2Status->Enabled = false;

   // 2022 12 26 - chc Tazmo: set CST
   if(RobotMode == ROBOT_MODE_TAZMO) {
      rgCST->ItemIndex = rgFoupSource->ItemIndex;
   }

   // 記錄為Load後的第一片
   if(boolFirstAfterLoad == true) {
      SetFristWafer();
   }
   pnlLoadWafer->Color = clSilver;

   // 先不管Macro: 無Sensor可測試, 要靠Vacuum但可能無讀值!
   // 1. 確認LoadPort是否已Load?
   // 2. 確認LoadPort是否已Mapping?
   // 3. 確認Aligner是否Ready? 且無片?
   // 4. 確認Robot是否Ready?
   // 5. 確認Chuck是否無片? 且在Home位置?
   // 6. 確認指定Tray是否有片?
   // 7. 執行Cassette取片, 更新Cassette狀態
   // 8. 執行Macro放片
   // 9. Macro Demo: 流程要修改
   // 10. 執行Macro取片
   // 11. 執行Aligner放片
   // 12. 執行Aligner Alignment(設定角度)
   // 13. 執行Aligner取片
   // 14. 執行Chuck放片
   // 15. 確認Chuck有Wafer
   // 16. *到3個位置

   //===========================================================================
   // Hirata
   // 1. 確認LoadPort是否已Load?
   pnlOperationMessage->Caption = "檢查Cassette...";
   WriteSystemLog(pnlOperationMessage->Caption);
   if(rgFoupSource->ItemIndex == LOADPORT_1) {
      if(pnlLoadPortLoad->Color != clLime) {
         pnlLoadWafer->Color = clRed;
         pnlOperationMessage->Caption = "取片失敗: Foup1尚未Load!";
         WriteSystemLog(pnlOperationMessage->Caption);
         goto error;
      }
   }
   else {
      if(pnlLoadPort2Load->Color != clLime) {
         pnlLoadWafer->Color = clRed;
         pnlOperationMessage->Caption = "取片失敗: CFoup2尚未Load!";
         WriteSystemLog(pnlOperationMessage->Caption);
         goto error;
      }
   }
   WriteSystemLog("取片: Foup Ok");
   // 2. 確認LoadPort是否已Mapping?
   pnlOperationMessage->Caption = "檢查Mapping...";
   WriteSystemLog(pnlOperationMessage->Caption);
   if(rgFoupSource->ItemIndex == LOADPORT_1) {
      if(boolMapping == false) {
         pnlLoadWafer->Color = clRed;
         pnlOperationMessage->Caption = "取片失敗: Foup1尚未Mapping!";
         WriteSystemLog(pnlOperationMessage->Caption);
         goto error;
      }
   }
   else {
      if(boolMapping2 == false) {
         pnlLoadWafer->Color = clRed;
         pnlOperationMessage->Caption = "取片失敗: Foup2尚未Mapping!";
         WriteSystemLog(pnlOperationMessage->Caption);
         goto error;
      }
   }
   WriteSystemLog("取片: Mapping Ok");

   // 3. 確認Aligner是否Ready? 且無片?
   // 2022 8 10 - chc 交給Timer做
   /*
   pnlOperationMessage->Caption = "檢查Aligner...";
   WriteSystemLog(pnlOperationMessage->Caption);
   // 先做ORGN: 原在放片後才做
   pnlOperationMessage->Caption = "Aligner原點...";
   WriteSystemLog(pnlOperationMessage->Caption);
   timeout = 10000;
   boolAlignerORGN = false;
   btnAlignerORGNClick(this);
   WriteSystemLog("Wait... Aligner ORGN");
   GetTimeTic(&StartTime,&StartTick);
   while(1) {
      if(boolAlignerORGN == true && pnlAlignerORGN->Color == clLime)
         break;
      Sleep(50);
      Application->ProcessMessages();
      GetTimeTic(&StopTime,&StopTick);
      Elapsedms = ((StopTime*1000+StopTick) - (StartTime*1000+StartTick));
      if(Elapsedms > timeout) {
         pnlLoadWafer->Color = clRed;
         pnlOperationMessage->Caption = "取片失敗: Aligner歸Home異常!";
         WriteSystemLog(pnlOperationMessage->Caption);
         goto error;
      }
   }
   WriteSystemLog("取片: Aligner原點 Ok");
   Sleep(500);
   Application->ProcessMessages();

   // Aligner是否無片?
   btnAlignerStasClick(this);
   cnt = 0;
   timeout = 20;
   // 等
   while(1) {
      if(pnlAligner->Enabled == true)
         break;
      Sleep(100);
      Application->ProcessMessages();
      cnt++;
      if(cnt > timeout) {
         pnlLoadWafer->Color = clRed;
         pnlOperationMessage->Caption = "取片失敗: Aligner通訊異常!";
         WriteSystemLog(pnlOperationMessage->Caption);
         goto error;
      }
   }
   WriteSystemLog("取片: Aligner Stat Ok");
   if(pnlAlignerS6->Caption != "011") {
      pnlLoadWafer->Color = clRed;
      pnlOperationMessage->Caption = "取片失敗: Aligner上有Wafer!";
      WriteSystemLog(pnlOperationMessage->Caption);
      goto error;
   }
   WriteSystemLog("取片[1]: Aligner無片 Ok");
   */
   boolDoAlignerORGN = false;
   WriteSystemLog("設定boolDoAlignerORGN = false");
   AlignerStep = 0;
   tmAlignerORGN->Interval = 800;
   tmAlignerORGN->Enabled = true;
   tmToLoadPosition->Enabled = true;
   WriteSystemLog("啟動AlignerORGN(800ms), ToLoad(50ms) 2個Timer");

   // 4. 確認Robot是否Ready?
   pnlOperationMessage->Caption = "檢查Robot...";
   WriteSystemLog(pnlOperationMessage->Caption);
   if(pnlRobotOriginal->Color != clLime) {
      pnlLoadWafer->Color = clRed;
      pnlOperationMessage->Caption = "取片失敗: Robot尚未歸Home!";
      WriteSystemLog(pnlOperationMessage->Caption);
      goto error;
   }
   // Robot是否有片?
   btnRobotWithWaferClick(this);

   // 2022 9 22 - chc 等待完成 2000ms: pnlRobotWithWafer->Color
   /*
   // 等
   cnt = 0;

   // 2022 9 12 - chc 延長到4秒
   //timeout = 20;
   timeout = 40;

   while(1) {
      if(pnlRobot->Enabled == true)
         break;
      Sleep(100);
      Application->ProcessMessages();
      cnt++;
      if(cnt > timeout) {
         pnlLoadWafer->Color = clRed;
         pnlOperationMessage->Caption = "取片失敗: Robot通訊異常!";
         WriteSystemLog(pnlOperationMessage->Caption);
         goto error;
      }
   }
   if(pnlRobotWithWafer->Color == clLime) {
   */
   if(pnlRobotWithWafer->Color == clLime || pnlRobotWithWafer->Color == clRed) {

      pnlLoadWafer->Color = clRed;
      pnlOperationMessage->Caption = "取片失敗: Robot上有Wafer!";
      WriteSystemLog(pnlOperationMessage->Caption);
      goto error;
   }
   WriteSystemLog("取片: Robot無片 Ok");
   // 5. 確認Chuck是否無片? 且在Home位置(Get前會自動到入料點)?
   // => 無法判斷!!!!
   pnlOperationMessage->Caption = "檢查Chuck...";
   WriteSystemLog(pnlOperationMessage->Caption);

   // 2022 12 22 - chc Chuck Wafer? Tazmo
   if(RobotMode == ROBOT_MODE_TAZMO) {
      btnChuckWithWaferClick(this);
      if(pnlChuckWithWafer->Color == clLime) {
         pnlLoadWafer->Color = clRed;
         pnlOperationMessage->Caption = "取片失敗: Chuck上有Wafer!";
         WriteSystemLog(pnlOperationMessage->Caption);
         goto error;
      }
   }

   // 6. 確認指定Tray是否有片?
   // pnlTray1
   pnlOperationMessage->Caption = "Cassette取片...";
   WriteSystemLog(pnlOperationMessage->Caption);
   no = 25 - rgWaferNo->ItemIndex;
   if(rgFoupSource->ItemIndex == LOADPORT_1) {
      panel = (TPanel*)(FindComponent("pnlTray" + IntToStr(no)));
      panel1 = (TPanel*)(FindComponent("pnlTray" + IntToStr(no) + "Select"));
   }
   else {
      panel = (TPanel*)(FindComponent("pnlTray2_" + IntToStr(no)));
      panel1 = (TPanel*)(FindComponent("pnlTray2_" + IntToStr(no) + "Select"));
   }
   panela = (TPanel*)(frmRecipe->FindComponent("pnlTray" + IntToStr(no)));
   // 要看Select
   if(panel->Color != clLime || panel1->Color != clLime) {
      pnlLoadWafer->Color = clRed;
      pnlOperationMessage->Caption = "取片失敗: 指定位置無Wafer!";
      WriteSystemLog(pnlOperationMessage->Caption);
      goto error;
   }
   WriteSystemLog("取片: Foup有片 Ok");

   // Load...
   pnlStartMessage->Caption = "取第" + IntToStr(no) + "片作業中...";
   pnlStartMessage->Visible = true;
   pnlStartMessage->Refresh();

   // 2022 8 15 - chc 先詢問取片
   /*
   // 7. 執行Cassette取片, 更新Cassette狀態
   // 一定要問
   //if(cbPause->Checked == true) {
      // 在LoopTest中則不做
      if(btnLoopTestStop->Visible == false) {
         if(Application->MessageBox(("準備由Cassette取第" + IntToStr(no) + "片?      ").c_str(), "取片作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
            pnlLoadWafer->Color = clPurple;
            goto error;
         }
      // 在LoopTest中則不做
      }
   // 一定要問
   //}
   */

   // LoadPort: LP1/Aligner/Chuck/LP2/Macro
   if(rgFoupSource->ItemIndex == LOADPORT_1)
      rgWaferLocation->ItemIndex = LOCATION_LP1;
   else
      rgWaferLocation->ItemIndex = LOCATION_LP2;

   // 2022 12 22 - chc Tazmo: 先到Aligner
   if(RobotMode == ROBOT_MODE_TAZMO) {
      rgCST->ItemIndex = rgWaferLocation->ItemIndex;
   }

   combRobotTrayNo->ItemIndex = no - 1;
   combRobotTrayNo->Text = IntToStr(no);
   btnRobotGetClick(this);
   if(pnlRobotGet->Color != clLime) {
      pnlLoadWafer->Color = clRed;
      pnlOperationMessage->Caption = "取片失敗: Cassette取片異常!";
      WriteSystemLog(pnlOperationMessage->Caption);
      goto error;
   }
   // Wafer已取走
   panel->Color = clOlive;
   // 要看Select
   panel1->Color = clOlive;
   panela->Color = clOlive;

   // 2022 12 22 - chc Tazmo: 先到Aligner
   if(RobotMode == ROBOT_MODE_TAZMO) {
      goto ToAligner;
   }
ToMacro:

   // Macro Operation設定
   if(RobotMode != ROBOT_MODE_TAZMO) {
      frmInspection->SetMainFun(false);
      frmInspection->SetTopFun(false);
      frmInspection->btnMacroInnerPosition->Enabled = true;
   }

   // 8. 執行Macro放片
   if(cbPause->Checked == true) {
      if(Application->MessageBox("準備將Wafer放到Macro?      ", "取片作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         pnlLoadWafer->Color = clPurple;
         goto error;
      }
   }

   pnlOperationMessage->Caption = "Macro放片...";
   WriteSystemLog(pnlOperationMessage->Caption);
   rgWaferLocation->ItemIndex = LOCATION_MACRO;
   combRobotTrayNo->ItemIndex = no - 1;
   combRobotTrayNo->Text = IntToStr(no);
   btnRobotPutClick(this);
   if(pnlRobotPut->Color != clLime) {
      pnlLoadWafer->Color = clRed;
      pnlOperationMessage->Caption = "取片失敗: Macro放片異常!";
      WriteSystemLog(pnlOperationMessage->Caption);
      goto error;
   }
   // 9. Macro Demo: 流程要修改
   if(cbPause->Checked == true && boolInInspecting == false) {
      if(Application->MessageBox("準備做Macro Demo?      ", "取片作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         pnlLoadWafer->Color = clPurple;
         goto error;
      }
   }
   pnlOperationMessage->Caption = "Macro放片.";
   // 開啟檢測視窗
   if(frmInspection->Visible != true) {
      WaferGetStep = 1;
      // 不可以用ShowModal()會不動
      //frmInspection->ShowModal();
      frnMain->Enabled = false;
      frmInspection->pcInspection->ActivePage = frmInspection->tsMacroInspection;
      frmInspection->Show();
   }
   frmInspection->pcInspection->ActivePage = frmInspection->tsMacroInspection;
   frmInspection->btnMacroDone->Enabled = false;
   frnMain->Enabled = true;
   if(boolInInspecting == true)
      frmRecipe->pnlMessage->Caption = "Slot " + IntToStr(no) + "Macro Inspecting...";

   // 2022 12 22 - chc Tazmo
   if(RobotMode == ROBOT_MODE_TAZMO) {
      frmInspection->gbMacroResult->Caption = "Macro Result(Top)";
   }   

   // 2022 12 13 - chc Wait Judge
   iWaitJudge = 0;

   if(boolInInspecting == false) {
      WriteSystemLog("btnMacroDemoClick...");
      btnMacroDemoClick(this);
      WriteSystemLog("btnMacroDemoClick.");

      // 開啟檢測視窗
      //if(frmInspection->Visible == true) {
      //   frmInspection->Close();
      //}
      if(pnlMacroDemo->Color != clLime) {
         pnlLoadWafer->Color = clRed;
         pnlOperationMessage->Caption = "取片失敗: Macro Demo異常!";
         WriteSystemLog(pnlOperationMessage->Caption);
         goto error;
      }
   }

   // 2022 12 13 - chc Wait Judge : 3-Done
   rgJoystickMode->ItemIndex = 1;                                               // Macro
   pnlMainOperation->Caption = "Wait Macro Judge...";
   WriteSystemLog(pnlMainOperation->Caption);

   // 2022 12 27 - chc 要做
   //if(boolInInspecting == true) {
      cnt = 0;
      while(1) {
         if(iWaitJudge != 0) {
            if(iWaitJudge == 1)
               pnlMainOperation->Caption = "Macro Judge: Pass";
            else if(iWaitJudge == 2)
               pnlMainOperation->Caption = "Macro Judge: Reject";
            else if(iWaitJudge == 3)
               pnlMainOperation->Caption = "Macro Judge: Done";
            pnlMainOperation->Refresh();
            if(iWaitJudge == 3)
               break;
         }
         Sleep(100);
         Application->ProcessMessages();
         cnt++;
         if(cnt > 8) {
            cnt = 0;
            if(frmInspection->pnlMacroJudge->Color == 0x00A7A7A7) {
               frmInspection->pnlMacroJudge->Color = clGray;
            }
            else {
               frmInspection->pnlMacroJudge->Color = (TColor)0x00A7A7A7;
            }
            frmInspection->pnlMacroJudge->Refresh();
         }
      }
   //}
   rgJoystickMode->ItemIndex = 0;                                               // Table
   WriteSystemLog(pnlMainOperation->Caption);

macroget:
   // 10. 執行Macro取片
   if(cbPause->Checked == true) {
      if(Application->MessageBox("準備將Wafer由Macro取出?      ", "取片作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         pnlLoadWafer->Color = clPurple;
         goto error;
      }
   }
   pnlOperationMessage->Caption = "Macro取片...";
   WriteSystemLog(pnlOperationMessage->Caption);
   rgWaferLocation->ItemIndex = LOCATION_MACRO;
   combRobotTrayNo->ItemIndex = no - 1;
   combRobotTrayNo->Text = IntToStr(no);
   btnRobotGetClick(this);
   if(pnlRobotGet->Color != clLime) {
      pnlLoadWafer->Color = clRed;
      pnlOperationMessage->Caption = "取片失敗: Macro取片異常!";
      WriteSystemLog(pnlOperationMessage->Caption);
      goto error;
   }

   // 2022 12 22 - chc Tazmo: 到Chuck
   if(RobotMode == ROBOT_MODE_TAZMO) {
      goto ToChuck;
   }
ToAligner:

   // 11. 執行Aligner放片
   if(cbPause->Checked == true) {
      if(Application->MessageBox("準備將Wafer放到Aligner?      ", "取片作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         pnlLoadWafer->Color = clPurple;
         goto error;
      }

      // 2022 8 22 - chc 若有暫停, 則要稍等Aligner ORGN完成
      if(tmAlignerORGN->Enabled == true || boolDoAlignerORGN == false || AlignerStep != 3) {
         if(tmAlignerORGN->Enabled == true)
            WriteSystemLog("Macro取片後, Aligner尚未Ready: tmAlignerORGN->Enabled = true");
         if(boolDoAlignerORGN == false)
            WriteSystemLog("Macro取片後, Aligner尚未Ready: boolDoAlignerORGN = false");
         if(AlignerStep != 3)
            WriteSystemLog("Macro取片後, Aligner尚未Ready: AlignerStep != 3");
         WriteSystemLog("Aligner尚未Ready, 稍候2000ms...");
         WaitTime(2000);
         WriteSystemLog("Aligner尚未Ready, 稍候.");
      }

   }

   // 2022/08/23 16:05:38:689-Macro取片後, Aligner尚未Ready: boolDoAlignerORGN = false
   // 2022/08/23 16:05:38:690-Macro取片後, Aligner尚未Ready: AlignerStep != 3

   // 先檢查Aligner
   if(tmAlignerORGN->Enabled == true || boolDoAlignerORGN == false || AlignerStep != 3) {

      // 2022 8 23 - chc Log
      if(tmAlignerORGN->Enabled == true)
         WriteSystemLog("Macro取片後, Aligner尚未Ready: tmAlignerORGN->Enabled = true");
      if(boolDoAlignerORGN == false)
         WriteSystemLog("Macro取片後, Aligner尚未Ready: boolDoAlignerORGN = false");
      if(AlignerStep != 3)
         WriteSystemLog("Macro取片後, Aligner尚未Ready: AlignerStep != 3");

      pnlLoadWafer->Color = clRed;
      pnlOperationMessage->Caption = "取片失敗: Aligner原點異常!";
      WriteSystemLog(pnlOperationMessage->Caption);
      goto error;
   }
   WriteSystemLog("取片[2]: Aligner無片 Ok");

   pnlOperationMessage->Caption = "Aligner放片...";
   WriteSystemLog(pnlOperationMessage->Caption);

   // 2022 12 22 - chc Tazmo: 先到Aligner
   if(RobotMode == ROBOT_MODE_TAZMO) {
      if(rgCST->ItemIndex == LOADPORT_1)
         rgWaferLocation->ItemIndex = LOCATION_ALIGNER1;
      else
         rgWaferLocation->ItemIndex = LOCATION_ALIGNER2;
   }
   else

      rgWaferLocation->ItemIndex = LOCATION_ALIGNER1;
   combRobotTrayNo->ItemIndex = no - 1;
   combRobotTrayNo->Text = IntToStr(no);
   btnRobotPutClick(this);
   if(pnlRobotPut->Color != clLime) {
      pnlLoadWafer->Color = clRed;
      pnlOperationMessage->Caption = "取片失敗: Aligner放片異常!";
      WriteSystemLog(pnlOperationMessage->Caption);
      goto error;
   }
   if(cbAlignerAlignment->Checked == true) {
      // 12. 執行Aligner Alignment
      // ORGN: pnlAlignerORGN
      if(cbPause->Checked == true) {
         if(Application->MessageBox("準備進行Wafer轉正?      ", "取片作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
            pnlLoadWafer->Color = clPurple;
            goto error;
         }
      }
      // Alignment: pnlAlignerAlignment->Color = clLime;
      // 會設定角度
      AlignmentDegreeMode = ALIGNMENT_DEGREE_LOAD;

      // 2022 12 27 - chc Tazmo: Aligner 1/2
      if(RobotMode == ROBOT_MODE_TAZMO) {
         if(rgCST->ItemIndex == LOADPORT_1)
            btnAlignerAlignmentClick(this);
         else
            btnAligner2AlignmentClick(this);
      }
      else

         btnAlignerAlignmentClick(this);
      WriteSystemLog("Wait... Aligner Alignment");
      GetTimeTic(&StartTime,&StartTick);

      // 2022 9 12a - chc 改成20sec
      //timeout = 10000;
      timeout = 20000;

      while(1) {

         // 2022 12 27 - chc Chuck Wafer? Tazmo
         if(RobotMode == ROBOT_MODE_TAZMO) {
            if(rgCST->ItemIndex == LOADPORT_1) {
               if(pnlAlignerAlignment->Color == clLime)
                  break;
            }
            else {
               if(pnlAligner2Alignment->Color == clLime)
                  break;
            }
         }
         else {

            if(pnlAlignerAlignment->Color == clLime)
               break;
         }
         Sleep(1);
         Application->ProcessMessages();
         GetTimeTic(&StopTime,&StopTick);
         Elapsedms = ((StopTime*1000+StopTick) - (StartTime*1000+StartTick));
         if(Elapsedms > timeout) {
            pnlLoadWafer->Color = clRed;
            pnlOperationMessage->Caption = "取片失敗: Aligner轉正異常!";
            WriteSystemLog(pnlOperationMessage->Caption);
            goto error;
         }
      }

      // 2022 12 27 - chc Chuck Wafer? Tazmo
      if(RobotMode == ROBOT_MODE_TAZMO) {
         WriteSystemLog("Tazmo-Aligner ALG, Auto Lift Up");
      }
      else {

         // Vacuum Off: pnlAlignerVacuumOff
         btnAlignerVacuumOffClick(this);
         WriteSystemLog("Wait... Aligner Vacuum Off");
         GetTimeTic(&StartTime,&StartTick);
         timeout = 5000;
         while(1) {
            if(pnlAlignerVacuumOff->Color == clLime)
               break;
            Sleep(1);
            Application->ProcessMessages();
            GetTimeTic(&StopTime,&StopTick);
            Elapsedms = ((StopTime*1000+StopTick) - (StartTime*1000+StartTick));
            if(Elapsedms > timeout) {
               pnlLoadWafer->Color = clRed;
               pnlOperationMessage->Caption = "取片失敗: Aligner關真空異常!";
               WriteSystemLog(pnlOperationMessage->Caption);
               goto error;
            }
         }
      }
   }

   // 13. 執行Aligner取片
   if(cbPause->Checked == true) {
      if(Application->MessageBox("準備由Aligner取片?      ", "取片作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         pnlLoadWafer->Color = clPurple;
         goto error;
      }
   }
   pnlOperationMessage->Caption = "Aligner取片...";
   WriteSystemLog(pnlOperationMessage->Caption);
   rgWaferLocation->ItemIndex = LOCATION_ALIGNER1;
   combRobotTrayNo->ItemIndex = no - 1;
   combRobotTrayNo->Text = IntToStr(no);
   btnRobotGetClick(this);
   if(pnlRobotGet->Color != clLime) {
      pnlLoadWafer->Color = clRed;
      pnlOperationMessage->Caption = "取片失敗: Aligner取片異常!";
      WriteSystemLog(pnlOperationMessage->Caption);
      goto error;
   }

   // 2022 12 22 - chc Tazmo: 到Macro
   if(RobotMode == ROBOT_MODE_TAZMO) {
      // Do Macro?
      if(boolInInspecting == true) {
         frmInspection->pnlMacroTopResult->Caption = "NA";
         frmInspection->pnlMacroBackResult->Caption = "NA";
         // No
         if(boolDoMacroTop == false && boolDoMacroBackCenter == false) {
            frmInspection->pnlMacroTopResult->Caption = "Pass";
            frmInspection->pnlMacroBackResult->Caption = "Pass";
            goto ToChuck;
         }
         else {
            if(boolDoMacroTop == true) {
               if(boolDoMacroBackCenter == false)
                  frmInspection->pnlMacroBackResult->Caption = "Pass";
               rgSide->ItemIndex = WAFER_TOP;
               goto ToMacro;
            }
            frmInspection->pnlMacroTopResult->Caption = "Pass";
            rgSide->ItemIndex = WAFER_BACK;
            goto ToMacro;
         }
      }
      else {
         rgSide->ItemIndex = WAFER_TOP;
         goto ToMacro;
      }
   }
ToChuck:
   // 14. 執行Chuck放片
   if(cbPause->Checked == true) {
      if(Application->MessageBox("準備將Wafer放到Chuck?      ", "取片作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         pnlLoadWafer->Color = clPurple;
         goto error;
      }
   }
   pnlOperationMessage->Caption = "Chuck放片...";
   WriteSystemLog(pnlOperationMessage->Caption);
   rgWaferLocation->ItemIndex = LOCATION_CHUCK;
   combRobotTrayNo->ItemIndex = no - 1;
   combRobotTrayNo->Text = IntToStr(no);
   btnRobotPutClick(this);
   if(pnlRobotPut->Color != clLime) {
      pnlLoadWafer->Color = clRed;
      pnlOperationMessage->Caption = "取片失敗: Chuck放片異常!";
      WriteSystemLog(pnlOperationMessage->Caption);
      goto error;
   }

   // 15. 確認Chuck有Wafer
   // => 無法判定!!!!

   // Completed
   pnlLoadWafer->Color = clLime;
   pnlOperationMessage->Caption = "取片完成.";
   WriteSystemLog(pnlOperationMessage->Caption);

   // 2022 8 17 - chc 取消EFEM-Mapping圖
   bool boolefem;
   boolefem = cbEFEM->Checked;
   if(cbEFEM->Checked == true) {
      cbEFEM->Checked = false;
      cbEFEMClick(this);
   }

   // 2022 9 5 - chc 雙片作業(LoopTest)
   if(cbDoubleWafer->Checked == true && boolInLoopTest == true) {
      // 有下一片?
      workno = no;
      nextno = GetNextNo(workno);
      if(nextno == -1) {
         pnlOperationMessage->Caption = "[雙片作業]Foup指定下一位置無Wafer! " + IntToStr(workno);
      }
      else {
         WriteSystemLog("雙片作業: 取下一片" + IntToStr(nextno));
         boolGetNextWafer = true;
         boolChuckMeasure = false;
         boolChuckMeasureResult = false;
         // 設定Timer做Chuck 5 點移動
         WriteSystemLog("雙片作業: 同步做Chuck 5點量測...");
         DoChuckMeasure();
         //---------------------------------------------------------------------
         // 由CST取下一片: no = 25 - rgWaferNo->ItemIndex;
         rgWaferNo->ItemIndex = 25 - nextno;
         no = 25 - rgWaferNo->ItemIndex;
         // 6. 確認指定Tray是否有片?
         // pnlTray1
         pnlOperationMessage->Caption = "Cassette取片...";
         WriteSystemLog(pnlOperationMessage->Caption);
         if(rgFoupSource->ItemIndex == LOADPORT_1) {
            panel = (TPanel*)(FindComponent("pnlTray" + IntToStr(no)));
            panel1 = (TPanel*)(FindComponent("pnlTray" + IntToStr(no) + "Select"));
         }
         else {
            panel = (TPanel*)(FindComponent("pnlTray2_" + IntToStr(no)));
            panel1 = (TPanel*)(FindComponent("pnlTray2_" + IntToStr(no) + "Select"));
         }
         panela = (TPanel*)(frmRecipe->FindComponent("pnlTray" + IntToStr(no)));
         // 要看Select
         if(panel->Color != clLime || panel1->Color != clLime) {
            pnlLoadWafer->Color = clRed;
            pnlOperationMessage->Caption = "取片失敗: 指定位置無Wafer!";
            WriteSystemLog(pnlOperationMessage->Caption);
            goto error;
         }
         WriteSystemLog("取片: Foup有片 Ok");
         // 先詢問取片: 執行Cassette取片, 更新Cassette狀態
         if(cbPause->Checked == true) {
            // 在LoopTest中則不做
            //if(btnLoopTestStop->Visible == false) {
               if(Application->MessageBox(("準備由Cassette取第" + IntToStr(no) + "片?      ").c_str(), "取片作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
                  pnlLoadWafer->Color = clPurple;
                  goto error;
               }
            //}
         }
         // LoadPort: LP1/Aligner/Chuck/LP2/Macro
         if(rgFoupSource->ItemIndex == LOADPORT_1)
            rgWaferLocation->ItemIndex = LOCATION_LP1;
         else
            rgWaferLocation->ItemIndex = LOCATION_LP2;
         combRobotTrayNo->ItemIndex = no - 1;
         combRobotTrayNo->Text = IntToStr(no);
         btnRobotGetClick(this);
         if(pnlRobotGet->Color != clLime) {
            pnlLoadWafer->Color = clRed;
            pnlOperationMessage->Caption = "取片失敗: Cassette取片異常!";
            WriteSystemLog(pnlOperationMessage->Caption);
            goto error;
         }
         // Wafer已取走
         panel->Color = clOlive;
         // 要看Select
         panel1->Color = clOlive;
         panela->Color = clOlive;
         // 8. 執行Macro放片
         if(cbPause->Checked == true) {
            if(Application->MessageBox("準備將Wafer放到Macro?      ", "取片作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
               pnlLoadWafer->Color = clPurple;
               goto error;
            }
         }
         pnlOperationMessage->Caption = "Macro放片...";
         WriteSystemLog(pnlOperationMessage->Caption);
         rgWaferLocation->ItemIndex = LOCATION_MACRO;
         combRobotTrayNo->ItemIndex = no - 1;
         combRobotTrayNo->Text = IntToStr(no);
         btnRobotPutClick(this);
         if(pnlRobotPut->Color != clLime) {
            pnlLoadWafer->Color = clRed;
            pnlOperationMessage->Caption = "取片失敗: Macro放片異常!";
            WriteSystemLog(pnlOperationMessage->Caption);
            goto error;
         }
         // 9. Macro Demo: 流程要修改
         if(cbPause->Checked == true) {
            if(Application->MessageBox("準備做Macro Demo?      ", "取片作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
               pnlLoadWafer->Color = clPurple;
               goto error;
            }
         }
         pnlOperationMessage->Caption = "Macro放片.";
         // 使用Timer來做Macro Demo
         boolMacroDemoResult = false;
         boolMacroDemo = false;
         WriteSystemLog("tmMacroDemoTimer: 設定.");
         tmMacroDemo->Enabled = true;
         //---------------------------------------------------------------------
         // 檢查Chuck Measure結果 & 是否執行過?
         if(boolChuckMeasure == false || boolChuckMeasureResult == false) {
            if(boolChuckMeasure == false) {
               if(tmChuckMeasure->Enabled == true)
                  tmChuckMeasure->Enabled = false;
            }
            goto error1;
         }
      }
   }
   else {
      WriteSystemLog("非雙片作業: 做Chuck 5點量測");

      // 2022 12 13 - chc Wait Judge
      iWaitJudge = 0;
      // 開啟檢測視窗
      if(frmInspection->Visible != true) {
         frnMain->Enabled = false;
         frmInspection->pcInspection->ActivePage = frmInspection->tsMicroInspection;
         frmInspection->Show();
      }
      frmInspection->pcInspection->ActivePage = frmInspection->tsMicroInspection;
      frnMain->Enabled = true;

      if(boolInInspecting == true)
         frmRecipe->pnlMessage->Caption = "Slot " + IntToStr(no) + "Micro Inspecting...";

      // Do Micro?
      if(boolInInspecting == true) {
         if(boolDoMicro == false) {
            frmInspection->MicroResult = JUDGE_PASS;
            goto ToNoMicro;
         }
      }

      // 2022 9 12 - chc 分離全部做或分段做
      //if(ChuckMeasure() == false)
      //if(boolInInspecting == false) {
         if(ChuckMeasure(1) == false)

         goto error1;
      //}

      // 2022 12 13 - chc Wait Judge
      pnlMainOperation->Caption = "Wait Micro Judge...";
      if(boolInInspecting == true) {
         int cnt = 0;
         while(1) {
            if(iWaitJudge != 0) {
               if(iWaitJudge == 1)
                  pnlMainOperation->Caption = "Micro Judge: Pass";
               else
                  pnlMainOperation->Caption = "Micro Judge: Reject";
               pnlMainOperation->Refresh();
               break;
            }
            Sleep(100);
            Application->ProcessMessages();
            cnt++;
            if(cnt > 8) {
               cnt = 0;
               if(frmInspection->pnlMicroJudge->Color == 0x00A7A7A7) {
                  frmInspection->pnlMicroJudge->Color = clGray;
               }
               else {
                  frmInspection->pnlMicroJudge->Color = (TColor)0x00A7A7A7;
               }
               frmInspection->pnlMicroJudge->Refresh();
            }
         }
      }

   }

ToNoMicro:

   // 2022 9 5 - chc 改成Function
   /*
   // 5點移動
   MeasurePointNo = -1;
   if(cbChuckDemo->Checked == true) {
      // 開啟檢測視窗
      if(frmInspection->Visible != true) {
         WaferGetStep = 2;
         // 不可以用ShowModal()會不動
         //frmInspection->ShowModal();
         frnMain->Enabled = false;
         frmInspection->Show();
      }
      MeasurePointNo = 1;
      int delaytime;
      delaytime = edDemoPointTime->Text.ToInt();
      WriteSystemLog("To Pos1...");
      btnPos1GoClick(this);
      WriteSystemLog("To Pos1.");
      if(pnlToUserPosition->Color != clLime) {
         pnlLoadWafer->Color = clRed;
         pnlOperationMessage->Caption = "取片失敗: Chuck第1點移動失敗!";
         WriteSystemLog(pnlOperationMessage->Caption);
         goto error1;
      }
      WaitTime(delaytime);
      MeasurePointNo = 2;
      WriteSystemLog("To Pos2...");
      btnPos2GoClick(this);
      WriteSystemLog("To Pos2.");
      if(pnlToUserPosition->Color != clLime) {
         pnlLoadWafer->Color = clRed;
         pnlOperationMessage->Caption = "取片失敗: Chuck第2點移動失敗!";
         WriteSystemLog(pnlOperationMessage->Caption);
         goto error1;
      }
      WaitTime(delaytime);
      MeasurePointNo = 3;
      WriteSystemLog("To Pos3...");
      btnPos3GoClick(this);
      WriteSystemLog("To Pos3.");
      if(pnlToUserPosition->Color != clLime) {
         pnlLoadWafer->Color = clRed;
         pnlOperationMessage->Caption = "取片失敗: Chuck第3點移動失敗!";
         WriteSystemLog(pnlOperationMessage->Caption);
         goto error1;
      }
      WaitTime(delaytime);
      MeasurePointNo = 4;
      WriteSystemLog("To Pos4...");
      btnPos4GoClick(this);
      WriteSystemLog("To Pos4.");
      if(pnlToUserPosition->Color != clLime) {
         pnlLoadWafer->Color = clRed;
         pnlOperationMessage->Caption = "取片失敗: Chuck第4點移動失敗!";
         WriteSystemLog(pnlOperationMessage->Caption);
         goto error1;
      }
      WaitTime(delaytime);
      MeasurePointNo = 5;
      WriteSystemLog("To Pos5...");
      btnPos5GoClick(this);
      WriteSystemLog("To Pos5.");
      if(pnlToUserPosition->Color != clLime) {
         pnlLoadWafer->Color = clRed;
         pnlOperationMessage->Caption = "取片失敗: Chuck第5點移動失敗!";
         WriteSystemLog(pnlOperationMessage->Caption);
         goto error1;
      }
   }
   MeasurePointNo = -1;
   */

   btnUnloadWafer->Enabled = true;
   btnLoadWafer->Enabled = false;

   // 記錄為Load後的第一片
   if(boolFirstAfterLoad == true) {
      boolFirstAfterLoad = false;
   }
   pnlOperationMessage->Caption = "";

   // 設定Limit
   btnSetLimit->Visible = true;
   pnlSetLimit->Visible = true;
   pnlUnitName->Visible = true;
   pnlSetLimit->Caption = "20000.0";
   pnlSetLimit->Color = 0x00FFAAAA;

error1:
   // 關閉檢測視窗
   frnMain->Enabled = true;
   //if(frmInspection->Visible == true) {
   //   frmInspection->Close();
   //}
   MeasurePointNo = -1;
   // 2022 8 17 - chc 取消EFEM-Mapping圖
   if(boolefem == true) {
      cbEFEM->Checked = true;
      cbEFEMClick(this);
   }

error:
   // 記錄取片中
   boolInLoad = false;

   // Enable: pcRobot
   pcSystem->Enabled = true;
   pcRobot->Enabled = true;
   pnlCassetteStatus->Enabled = true;
   pnlCassette2Status->Enabled = true;
   // 取片...
   pnlStartMessage->Visible = false;

   AnsiString tstr;
   GetTimeTic(&OPStopTime,&OPStopTick);
   OPElapsedms = ((OPStopTime*1000+OPStopTick) - (OPStartTime*1000+OPStartTick));
   tstr.sprintf("%.2f秒",(double)OPElapsedms / 1000);

   WriteSystemLog("取片作業完成: " + tstr);
   return;

}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnA2MZNearFarSetClick(TObject *Sender)
{
int nearv,farv;

   nearv = edA2MZNear->Text.ToInt();
   farv = edA2MZFar->Text.ToInt();

   pnlA2MZFarSet->Color = clSilver;
   edA2MCmd->Text = "FARLMT " + IntToStr(farv);
   btnA2MCMDClick(this);
   Sleep(500);
   pnlA2MZNearSet->Color = clSilver;
   edA2MCmd->Text = "NEARLMT " + IntToStr(nearv);
   btnA2MCMDClick(this);
}
//---------------------------------------------------------------------------
// A2M AF
void __fastcall TfrnMain::btnA2MAutoFocusClick(TObject *Sender)
{

   pnlA2MAutoFocus->Color = clSilver;
   btnA2MAFClick(this);
   pnlA2MAutoFocus->Color = pnlA2MAF->Color;
}
//---------------------------------------------------------------------------
// 2022 8 10 - chc 設定第一片
int TotalWafer = 0;
void __fastcall TfrnMain::SetFristWafer()
{
TPanel *panel;
bool first = true;

   WriteSystemLog("SetFristWafer: Enter...");
   for(int i=0 ; i<25 ; i++) {
      if(rgFoupSource->ItemIndex == LOADPORT_2)
         panel = (TPanel*)(FindComponent("pnlTray2_" + IntToStr(i+1) + "Select"));
      else
         panel = (TPanel*)(FindComponent("pnlTray" + IntToStr(i+1) + "Select"));
      if(panel->Color == clLime) {
         // 第一片位置
         // 小到大
         if(rgLoadOrder->ItemIndex == 0) {
            if(first == true) {
               first = false;
               rgWaferNo->ItemIndex = 24 - i;
               break;
            }
         }
         // 大到小
         else {
            rgWaferNo->ItemIndex = 24 - i;
         }
      }
   }

   // 計算總數量
   int tno = 0;
   for(int i=0 ; i<25 ; i++) {
      if(rgFoupSource->ItemIndex == LOADPORT_2)
         panel = (TPanel*)(FindComponent("pnlTray2_" + IntToStr(i+1) + "Select"));
      else
         panel = (TPanel*)(FindComponent("pnlTray" + IntToStr(i+1) + "Select"));
      if(panel->Color == clLime) {
         tno++;
      }
   }
   WriteSystemLog("SetFristWafer: 總片數= " + IntToStr(tno));
   TotalWafer = tno;
   //pbWafer->MaxValue = tno;
   pbWafer->Position = 0;
   frmMaintenance->pbWafer->Position = pbWafer->Position;

}
//---------------------------------------------------------------------------
// 2022 9 15 - chc 退last片
bool boolLastAbort = false;

bool boolLoopStop = false;
// Hirata EFEM 退片
void __fastcall TfrnMain::btnUnloadWaferClick(TObject *Sender)
{
int no,timeout;
TPanel *panel,*panel1,*panela;
long StartTime,StopTime,Elapsedms;
short StartTick,StopTick;
int cnt = 0;

   // 記錄退片中
   boolInUnLoad = true;
   pnlOperationTime->Caption = "0";

   // 2022 9 15 - chc 退last片
   if(boolLoopStop == true && boolLastAbort == true && StageInformation[STAGE_CHUCK].boolWithWafer == false && StageInformation[STAGE_MACRO].boolWithWafer == true)
      goto exitmacro;

   // 2022 9 12 - chc 確認Chuck是否已有片?
   if(StageInformation[STAGE_CHUCK].boolWithWafer == false) {
      pnlOperationMessage->Caption = "退片作業: Chuck無片!";
      WriteSystemLog(pnlOperationMessage->Caption);
      //SetRedLamp(true);
      Beep(500);
      pnlUnloadWafer->Color = clRed;
      goto error;
   }

   // 2022 12 22 - chc Chuck Wafer? Tazmo
   if(RobotMode == ROBOT_MODE_TAZMO) {
      btnChuckWithWaferClick(this);
      if(pnlChuckWithWafer->Color != clLime) {
         pnlOperationMessage->Caption = "退片作業: Chuck無片!";
         WriteSystemLog(pnlOperationMessage->Caption);
         //SetRedLamp(true);
         Beep(500);
         pnlUnloadWafer->Color = clRed;
         goto error;
      }
   }

// 2022 9 15 - chc 退last片
exitmacro:

   // 2022 8 15 - chc 先詢問退片
   //
   no = 25 - rgWaferNo->ItemIndex;

   // 2022 9 12 - chc Log
   pnlOperationMessage->Caption = "退片作業: 開始...";
   WriteSystemLog(pnlOperationMessage->Caption);

   // 2022 9 5 - chc 雙片作業(LoopTest)
   if(cbDoubleWafer->Checked == true && boolInLoopTest == true) {
      // 確認Chuck Demo是否完成? 還是取片時已檢查完?
      if(StageInformation[STAGE_CHUCK].boolWithWafer == true) {
         no = StageInformation[STAGE_CHUCK].SlotNo;
         rgWaferNo->ItemIndex = 25 - no;

         // 2022 9 12 - chc Log
         pnlOperationMessage->Caption = "退片作業: 雙片(Chuck有片)= " + IntToStr(no);
         WriteSystemLog(pnlOperationMessage->Caption);

      }

      // 2022 9 15 - chc 退last片
      else if(boolLoopStop == true && boolLastAbort == true && StageInformation[STAGE_MACRO].boolWithWafer == true) {
         no = StageInformation[STAGE_MACRO].SlotNo;
         rgWaferNo->ItemIndex = 25 - no;
         pnlOperationMessage->Caption = "退片作業: 雙片(Macro有片)= " + IntToStr(no);
         WriteSystemLog(pnlOperationMessage->Caption);
      }

      // 2022 9 12 - chc Log
      else {
         pnlOperationMessage->Caption = "退片作業: 雙片(Chuck無片)= " + IntToStr(no);
         WriteSystemLog(pnlOperationMessage->Caption);
         Beep(500);
         goto error;
      }

   }

   // 2022 9 12 - chc Log
   else {
      pnlOperationMessage->Caption = "退片作業: 單片= " + IntToStr(no);
      WriteSystemLog(pnlOperationMessage->Caption);
   }

   if(btnLoopTestStop->Visible == false) {

      // 2022 9 15 - chc 退last片
      if(boolLoopStop == true && boolLastAbort == true && StageInformation[STAGE_MACRO].boolWithWafer == true) {
         if(Application->MessageBox(("準備由Macro退第" + IntToStr(no) + "片?      ").c_str(), "退片作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
            pnlUnloadWafer->Color = clPurple;
            goto error;
         }
      }
      else {

         if(Application->MessageBox(("準備由Chuck退第" + IntToStr(no) + "片?      ").c_str(), "退片作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
            pnlUnloadWafer->Color = clPurple;
            goto error;
         }
      }
   }
   //

   GetTimeTic(&OPStartTime,&OPStartTick);

   WriteSystemLog("退片作業開始");

   // 先Disable: pcRobot
   pcSystem->Enabled = false;
   pnlCassetteStatus->Enabled = false;
   pnlCassette2Status->Enabled = false;
   pnlUnloadWafer->Color = clSilver;

   // 1. 確認LoadPort是否已Load?
   // 2. 確認LoadPort是否已Mapping?
   // 3. 確認Robot是否Ready? 且無片
   // 4. 確認Chuck是否有片? 且在Home位置?
   // 5. 確認指定Tray是否無片?
   // 6. Cheuck取片
   // 7. 執行Aligner放片
   // 8. 執行Aligner Alignment(設定角度)
   // 9. 執行Aligner取片
   // 10. 執行Cassette放片
   // 11. 更新Cassette狀態

   // 1. 確認LoadPort是否已Load?
   pnlOperationMessage->Caption = "檢查Cassette...";
   WriteSystemLog(pnlOperationMessage->Caption);
   if(rgFoupSource->ItemIndex == LOADPORT_1) {
      if(pnlLoadPortLoad->Color != clLime) {
         pnlUnloadWafer->Color = clRed;
         pnlOperationMessage->Caption = "退片失敗: Foup1尚未Load!";
         WriteSystemLog(pnlOperationMessage->Caption);
         goto error;
      }
   }
   else {
      if(pnlLoadPort2Load->Color != clLime) {
         pnlUnloadWafer->Color = clRed;
         pnlOperationMessage->Caption = "退片失敗: CFoup2尚未Load!";
         WriteSystemLog(pnlOperationMessage->Caption);
         goto error;
      }
   }
   // 2. 確認LoadPort是否已Mapping?
   pnlOperationMessage->Caption = "檢查Mapping...";
   WriteSystemLog(pnlOperationMessage->Caption);
   if(rgFoupSource->ItemIndex == LOADPORT_1) {
      if(boolMapping == false) {
         pnlUnloadWafer->Color = clRed;
         pnlOperationMessage->Caption = "退片失敗: Foup1尚未Mapping!";
         WriteSystemLog(pnlOperationMessage->Caption);
         goto error;
      }
   }
   else {
      if(boolMapping2 == false) {
         pnlUnloadWafer->Color = clRed;
         pnlOperationMessage->Caption = "退片失敗: Foup2尚未Mapping!";
         WriteSystemLog(pnlOperationMessage->Caption);
         goto error;
      }
   }
   // 要做Alignment
   if(cbUnloadNotch->Checked == true) {
      // (3). 確認Aligner是否Ready? 且無片?
      pnlOperationMessage->Caption = "檢查Aligner...";
      WriteSystemLog(pnlOperationMessage->Caption);
      // 先做ORGN
      pnlOperationMessage->Caption = "Aligner原點...";
      WriteSystemLog(pnlOperationMessage->Caption);
      timeout = 10000;
      boolAlignerORGN = false;

      // 2022 12 22 - chc Chuck Wafer? Tazmo
      if(RobotMode == ROBOT_MODE_TAZMO) {
         if(rgCST->ItemIndex == LOADPORT_1) {
            btnAlignerORGNClick(this);
            WriteSystemLog("Wait... Aligner ORGN(UnLoad)");
            GetTimeTic(&StartTime,&StartTick);
            while(1) {
               if(boolAlignerORGN == true && pnlAlignerORGN->Color == clLime)
                  break;
               Sleep(50);
               Application->ProcessMessages();
               GetTimeTic(&StopTime,&StopTick);
               Elapsedms = ((StopTime*1000+StopTick) - (StartTime*1000+StartTick));
               if(Elapsedms > timeout) {
                  pnlUnloadWafer->Color = clRed;
                  pnlOperationMessage->Caption = "退片失敗: Aligner歸Home異常!";
                  WriteSystemLog(pnlOperationMessage->Caption);
                  goto error;
               }
            }
         }
         else {
            btnAligner2ORGNClick(this);
            WriteSystemLog("Wait... Aligner2 ORGN(UnLoad)");
            GetTimeTic(&StartTime,&StartTick);
            while(1) {
               if(boolAlignerORGN == true && pnlAligner2ORGN->Color == clLime)
                  break;
               Sleep(50);
               Application->ProcessMessages();
               GetTimeTic(&StopTime,&StopTick);
               Elapsedms = ((StopTime*1000+StopTick) - (StartTime*1000+StartTick));
               if(Elapsedms > timeout) {
                  pnlUnloadWafer->Color = clRed;
                  pnlOperationMessage->Caption = "退片失敗: Aligner歸Home異常!";
                  WriteSystemLog(pnlOperationMessage->Caption);
                  goto error;
               }
            }
         }
      }
      else {

         btnAlignerORGNClick(this);
         WriteSystemLog("Wait... Aligner ORGN(UnLoad)");
         GetTimeTic(&StartTime,&StartTick);
         while(1) {
            if(boolAlignerORGN == true && pnlAlignerORGN->Color == clLime)
               break;
            Sleep(50);
            Application->ProcessMessages();
            GetTimeTic(&StopTime,&StopTick);
            Elapsedms = ((StopTime*1000+StopTick) - (StartTime*1000+StartTick));
            if(Elapsedms > timeout) {
               pnlUnloadWafer->Color = clRed;
               pnlOperationMessage->Caption = "退片失敗: Aligner歸Home異常!";
               WriteSystemLog(pnlOperationMessage->Caption);
               goto error;
            }
         }
      }
      WriteSystemLog("退片: Aligner原點 Ok");

      // 2022 8 11 - chc 改成等待
      //Sleep(500);
      //Application->ProcessMessages();
      cnt = 0;
      timeout = 50;
      while(1) {
         Sleep(100);
         Application->ProcessMessages();

         // 2022 12 22 - chc Chuck Wafer? Tazmo
         if(RobotMode == ROBOT_MODE_TAZMO) {
            if(rgCST->ItemIndex == LOADPORT_1) {
               if(pnlAligner->Enabled == true)
                  break;
            }
            else {
               if(pnlAligner2->Enabled == true)
                  break;
            }
         }
         else {

            if(pnlAligner->Enabled == true)
               break;
         }
         cnt++;
         if(cnt > timeout) {
            pnlUnloadWafer->Color = clRed;
            pnlOperationMessage->Caption = "退片失敗: 等Aligner STAS(5sec)作業Timeout!!";
            WriteSystemLog(pnlOperationMessage->Caption);
            goto error;
         }
      }

      // Aligner是否無片?
      btnAlignerStasClick(this);
      cnt = 0;
      timeout = 20;
      // 等
      while(1) {

         // 2022 12 22 - chc Chuck Wafer? Tazmo
         if(RobotMode == ROBOT_MODE_TAZMO) {
            if(rgCST->ItemIndex == LOADPORT_1) {
               if(pnlAligner->Enabled == true)
                  break;
            }
            else {
               if(pnlAligner2->Enabled == true)
                  break;
            }
         }
         else {

            if(pnlAligner->Enabled == true)
               break;
         }
         Sleep(100);
         Application->ProcessMessages();
         cnt++;
         if(cnt > timeout) {
            pnlUnloadWafer->Color = clRed;
            pnlOperationMessage->Caption = "退片失敗: Aligner通訊異常!";
            WriteSystemLog(pnlOperationMessage->Caption);
            goto error;
         }
      }
      // 2022 12 22 - chc Tazmo
      if(RobotMode == ROBOT_MODE_TAZMO) {
         if((rgCST->ItemIndex == LOADPORT_1 && pnlAlingerStatus->Caption != "100") ||
            (rgCST->ItemIndex == LOADPORT_2 && pnlAlinger2Status->Caption != "100")) {
            pnlUnloadWafer->Color = clRed;
            pnlOperationMessage->Caption = "退片失敗: Aligner上有Wafer!";
            WriteSystemLog(pnlOperationMessage->Caption);
            goto error;
         }
      }
      else {

         if(pnlAlignerS6->Caption != "011") {
            pnlUnloadWafer->Color = clRed;
            pnlOperationMessage->Caption = "退片失敗: Aligner上有Wafer!";
            WriteSystemLog(pnlOperationMessage->Caption);
            goto error;
         }
      }
   }

   // 3. 確認Robot是否Ready?
   pnlOperationMessage->Caption = "檢查Robot...";
   WriteSystemLog(pnlOperationMessage->Caption);
   if(pnlRobotOriginal->Color != clLime) {
      pnlUnloadWafer->Color = clRed;
      pnlOperationMessage->Caption = "退片失敗: Robot尚未歸Home!";
      WriteSystemLog(pnlOperationMessage->Caption);
      goto error;
   }
   // Robot是否有片?
   btnRobotWithWaferClick(this);

   // 2022 9 22 - chc 等待完成 2000ms: pnlRobotWithWafer->Color
   /*
   // 等
   cnt = 0;

   // 2022 9 12 - chc 延長到4秒
   //timeout = 20;
   timeout = 40;

   while(1) {
      if(pnlRobot->Enabled == true)
         break;
      Sleep(100);
      Application->ProcessMessages();
      cnt++;
      if(cnt > timeout) {
         pnlUnloadWafer->Color = clRed;
         pnlOperationMessage->Caption = "退片失敗: Robot通訊異常!";
         WriteSystemLog(pnlOperationMessage->Caption);
         goto error;
      }
   }
   if(pnlRobotWithWafer->Color == clLime) {
   */
   if(pnlRobotWithWafer->Color == clLime || pnlRobotWithWafer->Color == clRed) {

      pnlUnloadWafer->Color = clRed;
      pnlOperationMessage->Caption = "退片失敗: Robot上有Wafer!";
      WriteSystemLog(pnlOperationMessage->Caption);
      goto error;
   }

   // 4. 確認Chuck是否有片? 且在Home位置?
   // => 無法判斷!!!!
   pnlOperationMessage->Caption = "檢查Chuck...";
   WriteSystemLog(pnlOperationMessage->Caption);

   // 2022 12 22 - chc Chuck Wafer? Tazmo
   if(RobotMode == ROBOT_MODE_TAZMO) {
      btnChuckWithWaferClick(this);
      if(pnlChuckWithWafer->Color != clLime) {
         pnlUnloadWafer->Color = clRed;
         pnlOperationMessage->Caption = "退片失敗: Chuck上無Wafer!";
         WriteSystemLog(pnlOperationMessage->Caption);
         goto error;
      }
   }

   // 5. 確認指定Tray是否無片?
   // pnlTray1
   pnlOperationMessage->Caption = "Cassette有片?";
   WriteSystemLog(pnlOperationMessage->Caption);
   no = 25 - rgWaferNo->ItemIndex;
   if(rgFoupSource->ItemIndex == LOADPORT_1) {
      panel = (TPanel*)(FindComponent("pnlTray" + IntToStr(no)));
      panel1 = (TPanel*)(FindComponent("pnlTray" + IntToStr(no) + "Select"));
   }
   else {
      panel = (TPanel*)(FindComponent("pnlTray2_" + IntToStr(no)));
      panel1 = (TPanel*)(FindComponent("pnlTray2_" + IntToStr(no) + "Select"));
   }
   panela = (TPanel*)(frmRecipe->FindComponent("pnlTray" + IntToStr(no)));
   if(panel->Color == clLime || panel1->Color == clLime) {
      pnlUnloadWafer->Color = clRed;
      pnlOperationMessage->Caption = "退片失敗: 指定位置有Wafer!";
      WriteSystemLog(pnlOperationMessage->Caption);
      goto error;
   }

   // 退片...
   pnlStartMessage->Caption = "退第" + IntToStr(no) + "片作業中...";
   pnlStartMessage->Visible = true;
   pnlStartMessage->Refresh();

   // 2022 8 15 - chc 先詢問退片
   /*
   // 一定要問
   //if(cbPause->Checked == true) {
      // 在LoopTest中則不做
      if(btnLoopTestStop->Visible == false) {
         if(Application->MessageBox(("準備由Chuck退第" + IntToStr(no) + "片?      ").c_str(), "退片作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
            pnlUnloadWafer->Color = clPurple;
            goto error;
         }
      // 在LoopTest中則不做
      }
   // 一定要問
   //}
   */

   // 6. Chuck取片
   // 2022 9 15 - chc 退last片
   if(boolLoopStop == true && boolLastAbort == true && StageInformation[STAGE_MACRO].boolWithWafer == true) {
      if(cbPause->Checked == true) {
         if(Application->MessageBox("準備由Macro取出Wafer?      ", "退片作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
            pnlUnloadWafer->Color = clPurple;
            goto error;
         }
      }
      pnlOperationMessage->Caption = "Macro取片...";
      WriteSystemLog(pnlOperationMessage->Caption);
      rgWaferLocation->ItemIndex = LOCATION_MACRO;
   }
   else {

      if(cbPause->Checked == true) {
         if(Application->MessageBox("準備由Chuck取出Wafer?      ", "退片作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
            pnlUnloadWafer->Color = clPurple;
            goto error;
         }
      }
      pnlOperationMessage->Caption = "Chuck取片...";
      WriteSystemLog(pnlOperationMessage->Caption);
      rgWaferLocation->ItemIndex = LOCATION_CHUCK;
   }
   combRobotTrayNo->ItemIndex = no - 1;
   combRobotTrayNo->Text = IntToStr(no);
   btnRobotGetClick(this);
   if(pnlRobotGet->Color != clLime) {
      pnlUnloadWafer->Color = clRed;

      // 2022 9 15 - chc 退last片
      if(boolLoopStop == true && boolLastAbort == true && StageInformation[STAGE_MACRO].boolWithWafer == true)
         pnlOperationMessage->Caption = "退片失敗: Macro取片異常!";
      else

         pnlOperationMessage->Caption = "退片失敗: Chuck取片異常!";
      WriteSystemLog(pnlOperationMessage->Caption);
      goto error;
   }

   // 10. 執行Cassette放片
   // 11. 更新Cassette狀態

   // 要做Alignment
   if(cbUnloadNotch->Checked == true) {
   //---------------------------------------------------------------------------
      // 7. 執行Aligner放片
      if(cbPause->Checked == true) {
         if(Application->MessageBox("準備將Wafer放到Aligner?      ", "退片作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
            pnlUnloadWafer->Color = clPurple;
            goto error;
         }
      }
      pnlOperationMessage->Caption = "Aligner放片...";
      WriteSystemLog(pnlOperationMessage->Caption);

      // 2022 12 22 - chc Chuck Wafer? Tazmo
      if(RobotMode == ROBOT_MODE_TAZMO) {
         if(rgCST->ItemIndex == LOADPORT_1)
            rgWaferLocation->ItemIndex = LOCATION_ALIGNER1;
         else
            rgWaferLocation->ItemIndex = LOCATION_ALIGNER2;
      }
      else

         rgWaferLocation->ItemIndex = LOCATION_ALIGNER1;
      combRobotTrayNo->ItemIndex = no - 1;
      combRobotTrayNo->Text = IntToStr(no);
      btnRobotPutClick(this);
      if(pnlRobotPut->Color != clLime) {
         pnlUnloadWafer->Color = clRed;
         pnlOperationMessage->Caption = "退片失敗: Aligner放片異常!";
         WriteSystemLog(pnlOperationMessage->Caption);
         goto error;
      }
      if(cbAlignerAlignment->Checked == true) {
         // 8. 執行Aligner Alignment
         if(cbPause->Checked == true) {
            if(Application->MessageBox("準備進行Wafer轉正?      ", "退片作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
               pnlUnloadWafer->Color = clPurple;
               goto error;
            }
         }
         // Alignment: pnlAlignerAlignment->Color = clLime;
         // 會設定角度
         AlignmentDegreeMode = ALIGNMENT_DEGREE_UNLOAD;

         // 2022 12 27 - chc Tazmo: Aligner 1/2
         if(RobotMode == ROBOT_MODE_TAZMO) {
            if(rgCST->ItemIndex == LOADPORT_1)
               btnAlignerAlignmentClick(this);
            else
               btnAligner2AlignmentClick(this);
         }
         else

            btnAlignerAlignmentClick(this);
         WriteSystemLog("Wait... Aligner Alignment");
         GetTimeTic(&StartTime,&StartTick);

         // 2022 9 12a - chc 改成20sec
         //timeout = 10000;
         timeout = 20000;

         while(1) {

            // 2022 12 22 - chc Chuck Wafer? Tazmo
            if(RobotMode == ROBOT_MODE_TAZMO) {
               if(rgCST->ItemIndex == LOADPORT_1) {
                  if(pnlAlignerAlignment->Color == clLime)
                     break;
               }
               else {
                  if(pnlAligner2Alignment->Color == clLime)
                     break;
               }
            }
            else {

               if(pnlAlignerAlignment->Color == clLime)
                  break;
            }
            Sleep(1);
            Application->ProcessMessages();
            GetTimeTic(&StopTime,&StopTick);
            Elapsedms = ((StopTime*1000+StopTick) - (StartTime*1000+StartTick));
            if(Elapsedms > timeout) {
               pnlUnloadWafer->Color = clRed;
               pnlOperationMessage->Caption = "退片失敗: Aligner轉正異常!";
               WriteSystemLog(pnlOperationMessage->Caption);
               goto error;
            }
         }

         // 2022 12 22 - chc Chuck Wafer? Tazmo
         if(RobotMode == ROBOT_MODE_TAZMO) {
            WriteSystemLog("Tazmo-Aligner ALG, Auto Lift Up");
         }
         else {

            // Vacuum Off: pnlAlignerVacuumOff
            btnAlignerVacuumOffClick(this);
            WriteSystemLog("Wait... Aligner Vacuum Off");
            GetTimeTic(&StartTime,&StartTick);
            timeout = 5000;
            while(1) {
               if(pnlAlignerVacuumOff->Color == clLime)
                  break;
               Sleep(1);
               Application->ProcessMessages();
               GetTimeTic(&StopTime,&StopTick);
               Elapsedms = ((StopTime*1000+StopTick) - (StartTime*1000+StartTick));
               if(Elapsedms > timeout) {
                  pnlUnloadWafer->Color = clRed;
                  pnlOperationMessage->Caption = "退片失敗: Aligner關真空異常!";
                  WriteSystemLog(pnlOperationMessage->Caption);
                  goto error;
               }
            }
         }
      }

      // 9. 執行Aligner取片
      if(cbPause->Checked == true) {
         if(Application->MessageBox("準備由Aligner取片?      ", "退片作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
            pnlUnloadWafer->Color = clPurple;
            goto error;
         }
      }
      pnlOperationMessage->Caption = "Aligner取片...";
      WriteSystemLog(pnlOperationMessage->Caption);
      rgWaferLocation->ItemIndex = LOCATION_ALIGNER1;
      combRobotTrayNo->ItemIndex = no - 1;
      combRobotTrayNo->Text = IntToStr(no);
      btnRobotGetClick(this);
      if(pnlRobotGet->Color != clLime) {
         pnlUnloadWafer->Color = clRed;
         pnlOperationMessage->Caption = "退片失敗: Aligner取片異常!";
         WriteSystemLog(pnlOperationMessage->Caption);
         goto error;
      }
   }
   //---------------------------------------------------------------------------

   // 10. 執行Cassette放片
   if(cbPause->Checked == true) {
      if(Application->MessageBox(("準備放片到Cassette第" + IntToStr(no) + "片?      ").c_str(), "退片作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
         pnlUnloadWafer->Color = clPurple;
         goto error;
      }
   }
   if(rgFoupSource->ItemIndex == LOADPORT_1)
      rgWaferLocation->ItemIndex = LOCATION_LP1;
   else
      rgWaferLocation->ItemIndex = LOCATION_LP2;
   combRobotTrayNo->ItemIndex = no - 1;
   combRobotTrayNo->Text = IntToStr(no);
   btnRobotPutClick(this);
   if(pnlRobotPut->Color != clLime) {
      pnlUnloadWafer->Color = clRed;
      pnlOperationMessage->Caption = "退片失敗: Cassette放片異常!";
      WriteSystemLog(pnlOperationMessage->Caption);
      goto error;
   }
   // 11. 更新Cassette狀態
   panel->Color = clLime;
   // 要看Select
   panel1->Color = clLime;
   panela->Color = clLime;

   // Completed
   pnlUnloadWafer->Color = clLime;
   pnlOperationMessage->Caption = "退片完成.";
   WriteSystemLog(pnlOperationMessage->Caption);

   btnUnloadWafer->Enabled = false;
   btnLoadWafer->Enabled = true;
   pnlOperationMessage->Caption = "";

   // AutoLoad時指到下一片
   if(cbAutoLoad->Checked == true) {
      int outno = ToNextWafer(no);
      if(outno != -1) {
         rgWaferNo->ItemIndex = 25 - outno;
         // 已做完最後一片!
         pnlOperationMessage->Caption = "下一片作業編號: " + IntToStr(outno);
      }
      // 已做完最後一片!
      else {
         pnlOperationMessage->Caption = "已完成最後一片的取退片作業.";
      }
   }

   // 更新pbWafer
   UpdateProgress(no);

   // 設定Limit
   btnSetLimit->Visible = false;
   pnlSetLimit->Visible = false;
   pnlUnitName->Visible = false;
   pnlSetLimit->Color = 0x00FFAAAA;

error:

   // 記錄退片中
   boolInUnLoad = false;

   // Enable: pcRobot
   pcSystem->Enabled = true;
   pcRobot->Enabled = true;
   pnlCassetteStatus->Enabled = true;
   pnlCassette2Status->Enabled = true;

   // 退片...
   pnlStartMessage->Visible = false;
   AnsiString tstr;
   GetTimeTic(&OPStopTime,&OPStopTick);
   OPElapsedms = ((OPStopTime*1000+OPStopTick) - (OPStartTime*1000+OPStartTick));
   tstr.sprintf("%.2f秒",(double)OPElapsedms / 1000);
   WriteSystemLog("退片作業完成: " + tstr);

}
//---------------------------------------------------------------------------
// 2022 8 10 - chc AutoLoad時指到下一片
// In(no): 1-25
// Out: 1-25(-1: None)
int __fastcall TfrnMain::ToNextWafer(int no)
{
TPanel *panel;
int outno = -1;

   // 小到大
   if(rgLoadOrder->ItemIndex == 0) {
      for(int i=no+1 ; i<=25 ; i++) {
         if(rgFoupSource->ItemIndex == LOADPORT_1)
            panel = (TPanel*)(FindComponent("pnlTray" + IntToStr(i) + "Select"));
         else
            panel = (TPanel*)(FindComponent("pnlTray2_" + IntToStr(i) + "Select"));
         if(panel->Color == clLime) {
            outno = i;
            break;
         }
      }

      // 重頭開始
      if(outno == -1) {
         pnlOperationMessage->Caption = "已完成最後一片的取退片作業.";
         // ToNextWafer(): 若為SECS連線且Auto則不用重指定, 離線也可以
         //if((cbOffLine->Checked == false && cbSECSAtuo->Checked == true) || (cbOffLine->Checked == true && cbOffLineAtuo->Checked == true))
         //   return outno;
         for(int i=1 ; i<=25 ; i++) {
            if(rgFoupSource->ItemIndex == LOADPORT_1)
               panel = (TPanel*)(FindComponent("pnlTray" + IntToStr(i) + "Select"));
            else
               panel = (TPanel*)(FindComponent("pnlTray2_" + IntToStr(i) + "Select"));
            if(panel->Color == clLime) {
               outno = i;
               break;
            }
         }
      }

   }
   // 大到小
   else {
      for(int i=no-1 ; i>=1 ; i--) {
         if(rgFoupSource->ItemIndex == LOADPORT_1)
            panel = (TPanel*)(FindComponent("pnlTray" + IntToStr(i) + "Select"));
         else
            panel = (TPanel*)(FindComponent("pnlTray2_" + IntToStr(i) + "Select"));
         if(panel->Color == clLime) {
            outno = i;
            break;
         }
      }
      // 重頭開始
      if(outno == -1) {
         // ToNextWafer(): 若為SECS連線且Auto則不用重指定, 離線也可以
         //if((cbOffLine->Checked == false && cbSECSAtuo->Checked == true) || (cbOffLine->Checked == true && cbOffLineAtuo->Checked == true))
         //   return outno;
         pnlOperationMessage->Caption = "已完成最後一片的取退片作業.";
         for(int i=25 ; i>=1 ; i--) {
            if(rgFoupSource->ItemIndex == LOADPORT_1)
               panel = (TPanel*)(FindComponent("pnlTray" + IntToStr(i) + "Select"));
            else
               panel = (TPanel*)(FindComponent("pnlTray2_" + IntToStr(i) + "Select"));
            if(panel->Color == clLime) {
               outno = i;
               break;
            }
         }
      }
   }
   return outno;
}
//---------------------------------------------------------------------------
// 2022 8 10 - chc 更新pbWafer
void __fastcall TfrnMain::UpdateProgress(int no)
{
TPanel *panel;
bool first = true;
int cno = 0;
int progress = 0;

   if(pbWafer->Visible == false)
      return;

   // 小到大
   if(rgLoadOrder->ItemIndex == 0) {
      for(int i=0 ; i<25 ; i++) {
         if(rgFoupSource->ItemIndex == LOADPORT_1)
            panel = (TPanel*)(FindComponent("pnlTray" + IntToStr(i+1) + "Select"));
         else
            panel = (TPanel*)(FindComponent("pnlTray2_" + IntToStr(i+1) + "Select"));
         if(panel->Color == clLime) {
            cno++;
            if((i+1) == no) {
               WriteSystemLog("UpdateProgress小到大: 片數= " + IntToStr(cno) + "," + IntToStr(pbWafer->MaxValue));
               //pbWafer->Position = cno;
               break;;
            }
         }
      }
   }
   else {
      for(int i=24 ; i>=0 ; i--) {
         if(rgFoupSource->ItemIndex == LOADPORT_1)
            panel = (TPanel*)(FindComponent("pnlTray" + IntToStr(i+1) + "Select"));
         else
            panel = (TPanel*)(FindComponent("pnlTray2_" + IntToStr(i+1) + "Select"));
         if(panel->Color == clLime) {
            cno++;
            if((i+1) == no) {
               WriteSystemLog("UpdateProgress大到小: 片數= " + IntToStr(cno) + "," + IntToStr(pbWafer->MaxValue));
               //pbWafer->Position = cno;
               break;
            }
         }
      }
   }
   if(cno > 0 && TotalWafer > 0) {
      if(cno >= TotalWafer)
         progress = 100;
      else
         progress = (cno * 100) / TotalWafer;
   }
   pbWafer->Position = progress;
   frmMaintenance->pbWafer->Position = pbWafer->Position;

}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnToMeasurePointClick(TObject *Sender)
{
int no;

   btnToMeasurePoint->Enabled = false;
   pnlToMeasurePoint->Color = clSilver;
   no = rgMeasurePoint->ItemIndex + 1;
   ToUserPositionFun(no);
   pnlToMeasurePoint->Color = pnlToUserPosition->Color;
   btnToMeasurePoint->Enabled = true;

}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnLoadClick(TObject *Sender)
{

   btnLoad->Enabled = false;
   pnlLoad->Color = clSilver;
   btnToLoadPositionClick(this);
   pnlLoad->Color = pnlToLoadPosition->Color;
   btnLoad->Enabled = true;

}
//---------------------------------------------------------------------------


void __fastcall TfrnMain::btnA2MZMoveClick(TObject *Sender)
{
int step,direction;
AnsiString sdir,scmd;

   if(rgA2MZDirection->ItemIndex == 0) {
      direction = 0;
      sdir = "N";
   }
   else {
      direction = 1;
      sdir = "F";
   }
   pnlA2MZMove->Color = clSilver;
   step = edA2MZMoveStep->Text.ToInt();
   scmd.sprintf("MOV %s,%d",sdir.c_str(),step);
   edA2MCmd->Text = scmd;
   btnA2MCMDClick(this);

}
//---------------------------------------------------------------------------
// 2022 8 10 - chc 交給Timer做
// 800ms => 200ms
void __fastcall TfrnMain::tmAlignerORGNTimer(TObject *Sender)
{
long StartTime,StopTime,Elapsedms;
short StartTick,StopTick;
int cnt,timeout;

// 2022 8 19 - chc 等ORGN要有Timeout
static int orgncnt = 0;


   tmAlignerORGN->Enabled = false;
   WriteSystemLog("tmAlignerORGNTimer Enter...");

   if(AlignerStep == 0) {
      AlignerStep++;
      WriteSystemLog("tmAlignerORGNTimer Step=1");
      tmAlignerORGN->Interval = 200;
      pnlOperationMessage->Caption = "(取片Timer)檢查Aligner...";
      WriteSystemLog(pnlOperationMessage->Caption);
      // 先做ORGN: 原在放片後才做
      pnlOperationMessage->Caption = "Aligner原點...";
      WriteSystemLog(pnlOperationMessage->Caption);
      timeout = 10000;
      boolAlignerORGN = false;

      // 2022 12 22 - chc Tazmo
      if(RobotMode == ROBOT_MODE_TAZMO) {
         if(rgCST->ItemIndex == LOADPORT_1) {
            WriteSystemLog("tmAlignerORGNTimer Step=1");
            btnAlignerORGNClick(this);
         }
         else {
            btnAligner2ORGNClick(this);
         }
      }
      else

         btnAlignerORGNClick(this);

      // 2022 8 19 - chc 等ORGN要有Timeout
      orgncnt = 0;

      // 2022 8 17 - chc 要參考: pnlAlignerORGN->Color == clLime, 不用一直等
      /*
      WriteSystemLog("Wait... Aligner ORGN(取片Timer)");
      GetTimeTic(&StartTime,&StartTick);
      while(1) {
         if(boolAlignerORGN == true && pnlAlignerORGN->Color == clLime) {
            break;
         }
         // 2022 8 12 - chc 不用Sleep
         // 恢復
         Sleep(50);
         Application->ProcessMessages();
         GetTimeTic(&StopTime,&StopTick);
         Elapsedms = ((StopTime*1000+StopTick) - (StartTime*1000+StartTick));
         if(Elapsedms > timeout) {
            pnlOperationMessage->Caption = "取片失敗: Aligner歸Home異常!";
            WriteSystemLog(pnlOperationMessage->Caption);
            AlignerStep = -1;
            goto error;
         }
         WriteSystemLog("Wait...");
      }
      WriteSystemLog("取片: Aligner原點 Ok");
      */
      tmAlignerORGN->Enabled = true;
      return;
   }

   // 2022 8 17 - chc 要參考: pnlAlignerORGN->Color == clLime, 不用一直等
   //else if(AlignerStep == 1) {
   // 2022 8 19 - chc 要分段, 先看AlignerStep == 1
   //else if(AlignerStep == 1 && pnlAlignerORGN->Color != clSilver) {
   else if(AlignerStep == 1) {

      // 2022 8 19 - chc 等ORGN要有Timeout
      orgncnt++;

      // 2022 12 22 - chc Tazmo
      // TAZMO
      if(RobotMode == ROBOT_MODE_TAZMO) {
         TPanel *panelorgn,*panel;
         if(rgCST->ItemIndex == LOADPORT_1) {
            panel = pnlAligner;
            panelorgn = pnlAlignerORGN;
         }
         else {
            panel = pnlAligner2;
            panelorgn = pnlAligner2ORGN;
         }
         if(panelorgn->Color != clSilver) {
            if(boolAlignerORGN == true && panelorgn->Color == clLime) {
               WriteSystemLog("取片: Aligner原點 Ok, Step=1");
            }
            else if(panelorgn->Color == clRed || boolAlignerORGN == false) {
               pnlOperationMessage->Caption = "取片失敗: Aligner歸Home異常!";
               WriteSystemLog(pnlOperationMessage->Caption);
               AlignerStep = -1;
               WriteSystemLog("tmAlignerORGNTimer Step=-1");
               goto error;
            }
            AlignerStep++;
            WriteSystemLog("tmAlignerORGNTimer Step=2");
            // Aligner是否無片?
            // 2022 8 11 - chc 改成等待
            //Sleep(500);
            //Application->ProcessMessages();
            cnt = 0;
            // 2.5sec
            timeout = 50;
            while(1) {
               // 2022 8 12 - chc 不用Sleep
               // 恢復
               Sleep(50);
               Application->ProcessMessages();
               if(panel->Enabled == true)
                  break;
               cnt++;
               if(cnt > timeout) {
                  WriteSystemLog("tmAlignerORGNTimer()等Cmd作業完成Timeout!");
                  AlignerStep = -1;
                  WriteSystemLog("tmAlignerORGNTimer Step=-1");
                  goto error;
               }
               WriteSystemLog("[tmAlignerORGNTimer-1]Wait...");
            }
            WriteSystemLog("取片: Aligner原點完成");
            if(rgCST->ItemIndex == LOADPORT_1)
               btnAlignerStasClick(this);
            else
               btnAligner2StasClick(this);
         }
         // 等ORGN要有Timeout: 6sec (6000/200=30)
         else {
            if(orgncnt > 30) {
               WriteSystemLog("tmAlignerORGNTimer()等ORGN作業完成Timeout!");
               AlignerStep = -1;
               WriteSystemLog("tmAlignerORGNTimer Step=-1");
               goto error;
            }
         }
      }
      // HIRATA
      else {

         if(pnlAlignerORGN->Color != clSilver) {
            if(boolAlignerORGN == true && pnlAlignerORGN->Color == clLime) {
               WriteSystemLog("取片: Aligner原點 Ok, Step=2");
            }
            else if(pnlAlignerORGN->Color == clRed || boolAlignerORGN == false) {
               pnlOperationMessage->Caption = "取片失敗: Aligner歸Home異常!";
               WriteSystemLog(pnlOperationMessage->Caption);
               AlignerStep = -1;
               WriteSystemLog("tmAlignerORGNTimer Step=-1");
               goto error;
            }
            AlignerStep++;
            WriteSystemLog("tmAlignerORGNTimer Step=2");
            // Aligner是否無片?
            // 2022 8 11 - chc 改成等待
            //Sleep(500);
            //Application->ProcessMessages();
            cnt = 0;
            // 2.5sec
            timeout = 50;
            while(1) {
               // 2022 8 12 - chc 不用Sleep
               // 恢復
               Sleep(50);
               Application->ProcessMessages();
               if(pnlAligner->Enabled == true)
                  break;
               cnt++;
               if(cnt > timeout) {
                  WriteSystemLog("tmAlignerORGNTimer()等Cmd作業完成Timeout!");
                  AlignerStep = -1;
                  WriteSystemLog("tmAlignerORGNTimer Step=-1");
                  goto error;
               }
               WriteSystemLog("[tmAlignerORGNTimer-1]Wait...");
            }
            WriteSystemLog("取片: Aligner原點完成");
            btnAlignerStasClick(this);
         }

         // 2022 8 19 - chc 等ORGN要有Timeout: 6sec (6000/200=30)
         else {
            if(orgncnt > 30) {
               WriteSystemLog("tmAlignerORGNTimer()等ORGN作業完成Timeout!");
               AlignerStep = -1;
               WriteSystemLog("tmAlignerORGNTimer Step=-1");
               goto error;
            }
         }
      }

      tmAlignerORGN->Enabled = true;
      return;
   }

   else if(AlignerStep == 2) {
      AlignerStep++;
      WriteSystemLog("tmAlignerORGNTimer Step=3");
      cnt = 0;
      timeout = 20;
      // 等
      while(1) {

         // 2022 12 22 - chc Tazmo
         if(RobotMode == ROBOT_MODE_TAZMO) {
            if(rgCST->ItemIndex == LOADPORT_1 && pnlAligner->Enabled == true)
               break;
            if(rgCST->ItemIndex == LOADPORT_2 && pnlAligner2->Enabled == true)
               break;
         }
         else {

            if(pnlAligner->Enabled == true)
               break;
         }
         // 2022 8 12 - chc 不用Sleep
         // 恢復
         Sleep(50);
         Application->ProcessMessages();
         cnt++;
         if(cnt > timeout) {
            pnlLoadWafer->Color = clRed;
            pnlOperationMessage->Caption = "取片失敗: Aligner通訊異常!";
            WriteSystemLog(pnlOperationMessage->Caption);
            AlignerStep = -1;
            WriteSystemLog("tmAlignerORGNTimer Step=-1");
            goto error;
         }
         WriteSystemLog("[tmAlignerORGNTimer-2]Wait...");
      }
      WriteSystemLog("取片: Aligner Stat Ok");

      // 2022 12 22 - chc Tazmo
      if(RobotMode == ROBOT_MODE_TAZMO) {
         if((rgCST->ItemIndex == LOADPORT_1 && pnlAlingerStatus->Caption != "100") ||
            (rgCST->ItemIndex == LOADPORT_2 && pnlAlinger2Status->Caption != "100")) {
            pnlLoadWafer->Color = clRed;
            pnlOperationMessage->Caption = "取片失敗: Aligner上有Wafer!";
            WriteSystemLog(pnlOperationMessage->Caption);
            goto error;
         }
      }
      else {

         if(pnlAlignerS6->Caption != "011") {
            pnlLoadWafer->Color = clRed;
            pnlOperationMessage->Caption = "取片失敗: Aligner上有Wafer!";
            WriteSystemLog(pnlOperationMessage->Caption);
            goto error;
         }
      }
   }
   boolDoAlignerORGN = true;

   WriteSystemLog("取片[3]: Aligner無片 Ok, 設定boolDoAlignerORGN = true");
error:

}
//---------------------------------------------------------------------------
// Up
void __fastcall TfrnMain::btnA2MZMoveUpClick(TObject *Sender)
{
int step,direction,ratio;
AnsiString sdir,scmd;

   if(rgA2MRatio->ItemIndex == 0)
      ratio = 10;
   else if(rgA2MRatio->ItemIndex == 1)
      ratio = 50;
   else
      ratio = 100;
   sdir = "F";
   pnlA2MZMove->Color = clSilver;
   step = edA2MZMoveStep->Text.ToInt();
   step = step * ratio / 100;
   scmd.sprintf("MOV %s,%d",sdir.c_str(),step);
   edA2MCmd->Text = scmd;
   btnA2MCMDClick(this);

   //rgA2MZDirection->ItemIndex = 1;
   //btnA2MZMoveClick(this);

}
//---------------------------------------------------------------------------
// Down
void __fastcall TfrnMain::btnA2MZMoveDownClick(TObject *Sender)
{
int step,direction,ratio;
AnsiString sdir,scmd;

   if(rgA2MRatio->ItemIndex == 0)
      ratio = 10;
   else if(rgA2MRatio->ItemIndex == 1)
      ratio = 50;
   else
      ratio = 100;
   sdir = "N";
   pnlA2MZMove->Color = clSilver;
   step = edA2MZMoveStep->Text.ToInt();
   step = step * ratio / 100;
   scmd.sprintf("MOV %s,%d",sdir.c_str(),step);
   edA2MCmd->Text = scmd;
   btnA2MCMDClick(this);

   //rgA2MZDirection->ItemIndex = 0;
   //btnA2MZMoveClick(this);
}
//---------------------------------------------------------------------------
// 到入料點
void __fastcall TfrnMain::tmToLoadPositionTimer(TObject *Sender)
{

   tmToLoadPosition->Enabled = false;
   btnToLoadPositionClick(this);
}
//---------------------------------------------------------------------------
// POS?
void __fastcall TfrnMain::btnA2MPosClick(TObject *Sender)
{

   pnlA2MPos->Caption = "";
   edA2MCmd->Text = "POS?";
   btnA2MCMDClick(this);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnPositionSaveClick(TObject *Sender)
{
TIniFile *pSystemFile;
AnsiString str;
TLMDEdit *edx,*edy,*edz,*edt;
int x,y,z,t;

   pnlSystemMessage->Caption = "Update User Parameter...";
   // ini檔名與目錄
   pSystemFile = new TIniFile(UserINIFilename);
   pnlPositionGo->Color = clSilver;

   for(int i=0 ; i<10 ; i++) {
      edx = (TLMDEdit *)(FindComponent("edPos" + IntToStr(i+1) + "X"));
      edy = (TLMDEdit *)(FindComponent("edPos" + IntToStr(i+1) + "Y"));
      edz = (TLMDEdit *)(FindComponent("edPos" + IntToStr(i+1) + "Z"));
      edt = (TLMDEdit *)(FindComponent("edPos" + IntToStr(i+1) + "T"));
      x = edx->Text.ToInt();
      y = edy->Text.ToInt();
      z = edz->Text.ToInt();
      t = edt->Text.ToInt();
      pSystemFile->WriteInteger(USER_POSITION_SECTION,"UserPosition" + IntToStr(i+1) + "X"    ,x);
      pSystemFile->WriteInteger(USER_POSITION_SECTION,"UserPosition" + IntToStr(i+1) + "Y"    ,y);
      pSystemFile->WriteInteger(USER_POSITION_SECTION,"UserPosition" + IntToStr(i+1) + "Z"    ,z);
      pSystemFile->WriteInteger(USER_POSITION_SECTION,"UserPosition" + IntToStr(i+1) + "T"    ,t);
   }

   delete pSystemFile;
   pnlSystemMessage->Caption = "Update User Parameter Completed.";
   pnlPositionGo->Color = clLime;
}
//---------------------------------------------------------------------------
// 2022 8 12 - chc Load User Position
void __fastcall TfrnMain::LoadUserPosition()
{
TIniFile *pSystemFile;
AnsiString str;
TLMDEdit *edx,*edy,*edz,*edt;
int x,y,z,t;

   pnlSystemMessage->Caption = "Update User Parameter...";
   // ini檔名與目錄
   pSystemFile = new TIniFile(UserINIFilename);

   // try-catch
   try {
      for(int i=0 ; i<10 ; i++) {
         x = pSystemFile->ReadInteger(USER_POSITION_SECTION,"UserPosition" + IntToStr(i+1) + "X",0);
         y = pSystemFile->ReadInteger(USER_POSITION_SECTION,"UserPosition" + IntToStr(i+1) + "Y",0);
         z = pSystemFile->ReadInteger(USER_POSITION_SECTION,"UserPosition" + IntToStr(i+1) + "Z",0);
         t = pSystemFile->ReadInteger(USER_POSITION_SECTION,"UserPosition" + IntToStr(i+1) + "T",0);
         edx = (TLMDEdit *)(FindComponent("edPos" + IntToStr(i+1) + "X"));
         edy = (TLMDEdit *)(FindComponent("edPos" + IntToStr(i+1) + "Y"));
         edz = (TLMDEdit *)(FindComponent("edPos" + IntToStr(i+1) + "Z"));
         edt = (TLMDEdit *)(FindComponent("edPos" + IntToStr(i+1) + "T"));
         edx->Text = IntToStr(x);
         edy->Text = IntToStr(y);
         edz->Text = IntToStr(z);
         edt->Text = IntToStr(t);
      }
   }
   catch(Exception &e) {
      WriteSystemLog("LoadUserPosition() - Error");
      sbSystem->Panels->Items[1]->Text = "LoadUserPosition() - Error";
   }

   delete pSystemFile;
   pnlSystemMessage->Caption = "Update User Parameter Completed.";

}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnA2MAPosClick(TObject *Sender)
{

   pnlA2MAPos->Caption = "";
   edA2MCmd->Text = "APOS?";
   btnA2MCMDClick(this);
}
//---------------------------------------------------------------------------
// Save Macro Delay Time
void __fastcall TfrnMain::btnSaveMacroDelayTimeClick(TObject *Sender)
{
TIniFile *pSystemFile;
int dtime;

   pSystemFile = new TIniFile(SystemINIFilename);

   dtime = edDemoDelay->Text.ToInt();
   pSystemFile->WriteInteger("Macro","Delay Time"                               ,dtime);
   dtime = edDemoOutTime->Text.ToInt();
   pSystemFile->WriteInteger("Macro","Out Time"                                 ,dtime);

   // 2022 9 2 - chc 加入InTime/PointTime
   dtime = edDemoInTime->Text.ToInt();
   pSystemFile->WriteInteger("Macro","In Time"                                  ,dtime);
   dtime = edDemoPointTime->Text.ToInt();
   pSystemFile->WriteInteger("Macro","Point Time"                               ,dtime);

   delete pSystemFile;
}
//---------------------------------------------------------------------------
// 2022 8 12 - chc Load Macro Delay Time
void __fastcall TfrnMain::LoadMacroParameter()
{
TIniFile *pSystemFile;
int dtime;

   // ini檔名與目錄
   pSystemFile = new TIniFile(SystemINIFilename);

   // try-catch
   try {
      dtime = pSystemFile->ReadInteger("Macro","Delay Time"                               ,500);
      edDemoDelay->Text = IntToStr(dtime);
      dtime = pSystemFile->ReadInteger("Macro","Out Time"                                 ,2000);
      edDemoOutTime->Text = IntToStr(dtime);

      // 2022 9 2 - chc 加入InTime/PointTime
      dtime = pSystemFile->ReadInteger("Macro","In Time"                                  ,500);
      edDemoInTime->Text = IntToStr(dtime);
      dtime = pSystemFile->ReadInteger("Macro","Point Time"                               ,1000);
      edDemoPointTime->Text = IntToStr(dtime);

   }
   catch(Exception &e) {
      WriteSystemLog("LoadMacroParameter() - Error");
      sbSystem->Panels->Items[1]->Text = "LoadMacroParameter() - Error";
   }

   delete pSystemFile;
   pnlSystemMessage->Caption = "Update Macro Parameter Completed.";

}
//---------------------------------------------------------------------------
// A2M
void __fastcall TfrnMain::btnA2MSaveClick(TObject *Sender)
{
TIniFile *pSystemFile;
AnsiString str,fname;
int ivalue;

   pnlSystemMessage->Caption = "A2M參數更新中...";
   WriteSystemLog(pnlSystemMessage->Caption);
   pnlA2MMessage->Caption = pnlSystemMessage->Caption;
   // ini檔名與目錄
   fname = SystemDirectory + "\\A2M.ini";
   pSystemFile = new TIniFile(fname);

   // control
   ivalue = rgA2MControl->ItemIndex;
   pSystemFile->WriteInteger("A2M" ,"Control"                                   ,ivalue);

   // Z-Near
   ivalue = edA2MZNear->Text.ToInt();
   pSystemFile->WriteInteger("A2M" ,"Z Near"                                    ,ivalue);
   // Z-Far
   ivalue = edA2MZFar->Text.ToInt();
   pSystemFile->WriteInteger("A2M" ,"Z Far"                                     ,ivalue);
   // AF-Near
   ivalue = edA2MAFNear->Text.ToInt();
   pSystemFile->WriteInteger("A2M" ,"AF Near"                                   ,ivalue);
   // AF-Far
   ivalue = edA2MAFFar->Text.ToInt();
   pSystemFile->WriteInteger("A2M" ,"AF Far"                                    ,ivalue);
   // Lens1-Z
   ivalue = edA2MLens1Z->Text.ToInt();
   pSystemFile->WriteInteger("A2M" ,"Z Lens1"                                   ,ivalue);
   // Lens1-AF
   ivalue = edA2MLens1AF->Text.ToInt();
   pSystemFile->WriteInteger("A2M" ,"AF Lens1"                                  ,ivalue);
   // Lens2-Z
   ivalue = edA2MLens2Z->Text.ToInt();
   pSystemFile->WriteInteger("A2M" ,"Z Lens2"                                   ,ivalue);
   // Lens2-AF
   ivalue = edA2MLens2AF->Text.ToInt();
   pSystemFile->WriteInteger("A2M" ,"AF Lens2"                                  ,ivalue);
   // Lens3-Z
   ivalue = edA2MLens3Z->Text.ToInt();
   pSystemFile->WriteInteger("A2M" ,"Z Lens3"                                   ,ivalue);
   // Lens3-AF
   ivalue = edA2MLens3AF->Text.ToInt();
   pSystemFile->WriteInteger("A2M" ,"AF Lens3"                                  ,ivalue);
   // Lens4-Z
   ivalue = edA2MLens4Z->Text.ToInt();
   pSystemFile->WriteInteger("A2M" ,"Z Lens4"                                   ,ivalue);
   // Lens4-AF
   ivalue = edA2MLens4AF->Text.ToInt();
   pSystemFile->WriteInteger("A2M" ,"AF Lens4"                                  ,ivalue);
   // Lens5-Z
   ivalue = edA2MLens5Z->Text.ToInt();
   pSystemFile->WriteInteger("A2M" ,"Z Lens5"                                   ,ivalue);
   // Lens5-AF
   ivalue = edA2MLens5AF->Text.ToInt();
   pSystemFile->WriteInteger("A2M" ,"AF Lens5"                                  ,ivalue);

   // Value
   ivalue = edA2MZMoveStep->Text.ToInt();
   pSystemFile->WriteInteger("A2M" ,"Move Step"                                 ,ivalue);

   delete pSystemFile;
   pnlSystemMessage->Caption = "A2M參數更新完成.";
   WriteSystemLog(pnlSystemMessage->Caption);
   pnlA2MMessage->Caption = pnlSystemMessage->Caption;
}
//---------------------------------------------------------------------------
// A2M
// 2022 8 23 - chc Load BXFM/A2M Parameter: 但不執行
//void __fastcall TfrnMain::ReadA2MParameter()
void __fastcall TfrnMain::ReadA2MParameter(int mmode)
{
TIniFile *pSystemFile;
AnsiString str,fname;
int ivalue;

   pnlSystemMessage->Caption = "A2M參數讀取中...";
   WriteSystemLog(pnlSystemMessage->Caption);
   pnlBXFMMessage->Caption = pnlSystemMessage->Caption;
   // ini檔名與目錄
   fname = SystemDirectory + "\\A2M.ini";
   pSystemFile = new TIniFile(fname);

   // control
   ivalue = pSystemFile->ReadInteger("A2M" ,"Control"                                   ,BXFM_CONTROL_REMOTE);
   rgA2MControl->ItemIndex = ivalue;

   // Z-Near
   ivalue = pSystemFile->ReadInteger("A2M" ,"Z Near"                                    ,851110);
   edA2MZNear->Text = IntToStr(ivalue);
   // Z-Far
   ivalue = pSystemFile->ReadInteger("A2M" ,"Z Far"                                     ,1);
   edA2MZFar->Text = IntToStr(ivalue);
   // AF-Near
   ivalue = pSystemFile->ReadInteger("A2M" ,"AF Near"                                   ,780000);
   edA2MAFNear->Text = IntToStr(ivalue);
   // AF-Far
   ivalue = pSystemFile->ReadInteger("A2M" ,"AF Far"                                    ,350000);
   edA2MAFFar->Text = IntToStr(ivalue);
   // Lens1-Z
   ivalue = pSystemFile->ReadInteger("A2M" ,"Z Lens1"                                   ,706531);
   edA2MLens1Z->Text = IntToStr(ivalue);
   // Lens1-AF
   ivalue = pSystemFile->ReadInteger("A2M" ,"AF Lens1"                                  ,550);
   edA2MLens1AF->Text = IntToStr(ivalue);
   // Lens2-Z
   ivalue = pSystemFile->ReadInteger("A2M" ,"Z Lens2"                                   ,706531);
   edA2MLens2Z->Text = IntToStr(ivalue);
   // Lens2-AF
   ivalue = pSystemFile->ReadInteger("A2M" ,"AF Lens2"                                  ,572);
   edA2MLens2AF->Text = IntToStr(ivalue);
   // Lens3-Z
   ivalue = pSystemFile->ReadInteger("A2M" ,"Z Lens3"                                   ,706531);
   edA2MLens3Z->Text = IntToStr(ivalue);
   // Lens3-AF
   ivalue = pSystemFile->ReadInteger("A2M" ,"AF Lens3"                                  ,575);
   edA2MLens3AF->Text = IntToStr(ivalue);
   // Lens4-Z
   ivalue = pSystemFile->ReadInteger("A2M" ,"Z Lens4"                                   ,706531);
   edA2MLens4Z->Text = IntToStr(ivalue);
   // Lens4-AF
   ivalue = pSystemFile->ReadInteger("A2M" ,"AF Lens4"                                  ,720);
   edA2MLens4AF->Text = IntToStr(ivalue);
   // Lens5-Z
   ivalue = pSystemFile->ReadInteger("A2M" ,"Z Lens5"                                   ,706531);
   edA2MLens5Z->Text = IntToStr(ivalue);
   // Lens5-AF
   ivalue = pSystemFile->ReadInteger("A2M" ,"AF Lens5"                                  ,790);
   edA2MLens5AF->Text = IntToStr(ivalue);

   // Value
   ivalue = pSystemFile->ReadInteger("A2M" ,"Move Step"                                 ,1000);
   edA2MZMoveStep->Text = IntToStr(ivalue);

   delete pSystemFile;
   pnlSystemMessage->Caption = "A2M參數讀取完成.";
   WriteSystemLog(pnlSystemMessage->Caption);
   pnlA2MMessage->Caption = pnlSystemMessage->Caption;
}
//---------------------------------------------------------------------------
// 2022 8 15 - chc COM Port
void __fastcall TfrnMain::LoadCOMPort()
{
TIniFile *pSystemFile;
AnsiString str,fname;
int no;

   fname = SystemDirectory + "\\COMPort.ini" ;
   if(!FileExists(fname)) {
      sbSystem->Panels->Items[1]->Text = "COMPort.ini Not Existed!";
      return;
   }
   // 載入ini檔
   pSystemFile = new TIniFile(fname);

   // Robot/LP1/LP2/Aligner/LED1/LED2/BXFM/LP1-RFID/LP1-E84/LP2-RFID/LP2-E84
   no = pSystemFile->ReadInteger("Robot" ,"Port"                     ,5);
   combRobotComport->ItemIndex = no - 1;
   combRobotComport->Text = "COM" + IntToStr(no);
   no = pSystemFile->ReadInteger("LP1" ,"Port"                       ,2);
   combLoadPortComport->ItemIndex = no - 1;
   combLoadPortComport->Text = "COM" + IntToStr(no);
   no = pSystemFile->ReadInteger("LP2" ,"Port"                       ,3);
   combLoadPort2Comport->ItemIndex = no - 1;
   combLoadPort2Comport->Text = "COM" + IntToStr(no);
   no = pSystemFile->ReadInteger("Aligner1" ,"Port"                   ,15);
   combAlignerComport->ItemIndex = no - 1;
   combAlignerComport->Text = "COM" + IntToStr(no);
   no = pSystemFile->ReadInteger("LED1" ,"Port"                      ,6);
   combLED1Comport->ItemIndex = no - 1;
   combLED1Comport->Text = "COM" + IntToStr(no);
   no = pSystemFile->ReadInteger("LED2" ,"Port"                      ,22);
   combLED2Comport->ItemIndex = no - 1;
   combLED2Comport->Text = "COM" + IntToStr(no);
   no = pSystemFile->ReadInteger("BXFM" ,"Port"                      ,1);
   combBXFMComport->ItemIndex = no - 1;
   combBXFMComport->Text = "COM" + IntToStr(no);
   no = pSystemFile->ReadInteger("LP1" ,"RFID Port"                  ,7);
   combRFID12Comport->ItemIndex = no - 1;
   combRFID12Comport->Text = "COM" + IntToStr(no);
   no = pSystemFile->ReadInteger("LP2" ,"RFID Port"                  ,9);
   combRFID8Comport->ItemIndex = no - 1;
   combRFID8Comport->Text = "COM" + IntToStr(no);
   no = pSystemFile->ReadInteger("LP1" ,"E84 Port"                   ,8);
   no = pSystemFile->ReadInteger("LP2" ,"E84 Port"                   ,10);

   no = pSystemFile->ReadInteger("Aligner2" ,"Port"                   ,15);
   combAligner2Comport->ItemIndex = no - 1;
   combAligner2Comport->Text = "COM" + IntToStr(no);

   // 2023 1 11 - chc DIC
   no = pSystemFile->ReadInteger("DIC" ,"Port"                      ,22);
   combDICComport->ItemIndex = no - 1;
   combDICComport->Text = "COM" + IntToStr(no);

   // 2022 12 20 - chc Maintenance
   // Robot
   frmMaintenance->combRobotComport->ItemIndex = no - 1;
   frmMaintenance->combRobotComport->Text = "COM" + IntToStr(no);
   // LP1
   frmMaintenance->combLoadPortComport->ItemIndex = no - 1;
   frmMaintenance->combLoadPortComport->Text = "COM" + IntToStr(no);
   // LP2
   frmMaintenance->combLoadPort2Comport->ItemIndex = no - 1;
   frmMaintenance->combLoadPort2Comport->Text = "COM" + IntToStr(no);
   // Aligner1
   frmMaintenance->combAlignerComport->ItemIndex = no - 1;
   frmMaintenance->combAlignerComport->Text = "COM" + IntToStr(no);
   // Aligner2
   frmMaintenance->combAligner2Comport->ItemIndex = no - 1;
   frmMaintenance->combAligner2Comport->Text = "COM" + IntToStr(no);

   delete pSystemFile;
}
//---------------------------------------------------------------------------
// 2022 8 16 - chc 因在Wait中, 其它Process無法插入! 改交由Timer來做 : iAlignerORGNDone
// Interval: 50ms
// 2022 8 22 - chc Interval由50ms改成100ms
// timeout=5sec
void __fastcall TfrnMain::tmAlignerORGNDoneTimer(TObject *Sender)
{
int cnt = 0;
// 5sec
int max = 100;

   WriteSystemLog("tmAlignerORGNDoneTimer Enter...");
   tmAlignerORGNDone->Enabled = false;
   if(pnlAlignerORGN->Color == clRed) {
      return;
   }
   iAlignerORGNDone++;
   cnt = iAlignerORGNDone;
   if(cnt > max) {
      WriteSystemLog("btnAlignerORGNClick: 等完成ORGN(5sec) Timeout!");
      return;
   }
   // 發出STAS
   if(pnlAlignerORGN->Color == clLime) {
      WriteSystemLog("btnAlignerORGNClick: 完成ORGN, 發出GET:STAS;");
      btnAlignerStasClick(this);
      WriteSystemLog("執行Aligner ORGN.");
      return;
   }
   WriteSystemLog("[ORG Done]Wait...");
   tmAlignerORGNDone->Enabled = true;
}
//---------------------------------------------------------------------------
// 2022 8 16 - chc Robot Speed
void __fastcall TfrnMain::btnRobotSpeedClick(TObject *Sender)
{
AnsiString scmd;
int abspeed,zspeed;

   abspeed = edRobotABSpeed->Text.ToInt();
   if(abspeed < 1)
      abspeed = 1;
   if(abspeed > 100)
      abspeed = 100;
   zspeed = edRobotZSpeed->Text.ToInt();
   if(zspeed < 1)
      zspeed = 1;
   if(zspeed > 100)
      zspeed = 100;
   scmd.sprintf("SP%d %d",abspeed,zspeed);
   edRobotCmd->Text = scmd;
   btnRobotCMDClick(this);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::rgCCDSpeedChange(TObject *Sender,
      int ButtonIndex)
{

   if(rgCCDSpeed->ItemIndex == 0)
      tmISCCD->Interval = 80;
   else
      tmISCCD->Interval = 50;
}
//---------------------------------------------------------------------------
// 2022 8 16 - chc Robot Speed control
void __fastcall TfrnMain::btnRobotSaveClick(TObject *Sender)
{
TIniFile *pSystemFile;
AnsiString str;

   pnlSystemMessage->Caption = "Robot參數更新中...";
   pnlAlignerMessage->Caption = pnlSystemMessage->Caption;
   // ini檔名與目錄
   pSystemFile = new TIniFile(SystemINIFilename);

   // Aligner
   RobotABSpeed = edRobotABSpeed->Text.ToInt();
   if(RobotABSpeed < 1)
      RobotABSpeed = 1;
   if(RobotABSpeed > 100)
      RobotABSpeed = 100;
   pSystemFile->WriteInteger("Robot Parameter" ,"AB Speed"                      ,RobotABSpeed);
   RobotZSpeed = edRobotZSpeed->Text.ToInt();
   if(RobotZSpeed < 1)
      RobotZSpeed = 1;
   if(RobotZSpeed > 100)
      RobotZSpeed = 100;
   pSystemFile->WriteInteger("Robot Parameter" ,"Z Speed"                       ,RobotZSpeed);

   // Scan Speed
   RobotABScanSpeed = edRobotABScanSpeed->Text.ToInt();
   if(RobotABScanSpeed < 1)
      RobotABScanSpeed = 1;
   if(RobotABScanSpeed > 100)
      RobotABScanSpeed = 100;
   pSystemFile->WriteInteger("Robot Parameter" ,"AB Scan Speed"                 ,RobotABScanSpeed);

   delete pSystemFile;
   pnlSystemMessage->Caption = "Aligner參數更新完成.";
   pnlAlignerMessage->Caption = pnlSystemMessage->Caption;
}
//---------------------------------------------------------------------------
// 2022 8 16 - chc Robot Speed control
void __fastcall TfrnMain::LoadRobotParameter()
{
TIniFile *pSystemFile;
AnsiString str;

   pnlSystemMessage->Caption = "Robot參數讀取中...";
   pnlAlignerMessage->Caption = pnlSystemMessage->Caption;
   // ini檔名與目錄
   pSystemFile = new TIniFile(SystemINIFilename);

   // Aligner
   RobotABSpeed = pSystemFile->ReadInteger("Robot Parameter" ,"AB Speed"        ,80);
   if(RobotABSpeed < 1)
      RobotABSpeed = 1;
   if(RobotABSpeed > 100)
      RobotABSpeed = 100;
   edRobotABSpeed->Text = IntToStr(RobotABSpeed);
   RobotZSpeed = pSystemFile->ReadInteger("Robot Parameter" ,"Z Speed"          ,60);
   if(RobotZSpeed < 1)
      RobotZSpeed = 1;
   if(RobotZSpeed > 100)
      RobotZSpeed = 100;
   edRobotZSpeed->Text = IntToStr(RobotZSpeed);

   // Scan Speed
   RobotABScanSpeed = pSystemFile->ReadInteger("Robot Parameter" ,"AB Scan Speed"        ,25);
   if(RobotABScanSpeed < 1)
      RobotABScanSpeed = 1;
   if(RobotABScanSpeed > 100)
      RobotABScanSpeed = 100;
   edRobotABScanSpeed->Text = IntToStr(RobotABScanSpeed);

   delete pSystemFile;
   pnlSystemMessage->Caption = "Robot參數讀取完成.";
   pnlAlignerMessage->Caption = pnlSystemMessage->Caption;
}
//---------------------------------------------------------------------------
// 2022 8 16 - chc 全選
void __fastcall TfrnMain::btnAllSelectClick(TObject *Sender)
{
TPanel *panel,*panel1;

   for(int i=1 ; i<=25 ; i++) {
      panel = (TPanel*)(FindComponent("pnlTray" + IntToStr(i)));
      panel1 = (TPanel*)(FindComponent("pnlTray" + IntToStr(i) + "Select"));
      if(panel->Color == clLime)
         panel1->Color = panel->Color;
      else
         panel1->Color = clGray;
   }
}
//---------------------------------------------------------------------------
// 2022 8 16 - chc 全選
void __fastcall TfrnMain::btnAllSelect2Click(TObject *Sender)
{
TPanel *panel,*panel1;

   for(int i=1 ; i<=25 ; i++) {
      panel = (TPanel*)(FindComponent("pnlTray2_" + IntToStr(i)));
      panel1 = (TPanel*)(FindComponent("pnlTray2_" + IntToStr(i) + "Select"));
      if(panel->Color == clLime)
         panel1->Color = panel->Color;
      else
         panel1->Color = clGray;
   }
}
//---------------------------------------------------------------------------
// 2022 8 16 - chc Tray Select
void __fastcall TfrnMain::pnlTraySelectClick(TObject *Sender)
{

   TPanel* pnlSender = (TPanel*)Sender;
   if(pnlSender->Color == clSilver)
      pnlSender->Color = clLime;
   else if(pnlSender->Color == clLime)
      pnlSender->Color = clSilver;
}
//---------------------------------------------------------------------------
// 2022 8 16 - chc Tray Select
void __fastcall TfrnMain::pnlTray2SelectClick(TObject *Sender)
{

   TPanel* pnlSender = (TPanel*)Sender;
   if(pnlSender->Color == clSilver)
      pnlSender->Color = clLime;
   else if(pnlSender->Color == clLime)
      pnlSender->Color = clSilver;
}
//---------------------------------------------------------------------------
// 2022 8 17 - chc Wafer Position
void __fastcall TfrnMain::ChangeWaferPosition(int location, int getput, int step)
{
AnsiString path,fname,posname,opname;

   path = SystemDirectory + "\\Icon\\";

   if(location == LOCATION_LP1)
      posname = "LP1";
   else if(location == LOCATION_ALIGNER1)
      posname = "Aligner";
   else if(location == LOCATION_ALIGNER2)
      posname = "Aligner";
   else if(location == LOCATION_CHUCK)
      posname = "Chuck";
   else if(location == LOCATION_LP2)
      posname = "LP2";
   else if(location == LOCATION_MACRO)
      posname = "Macro";

   // Get
   if(getput == WAFER_GET) {
      // 1/2/3/4
      if(step == 1)
         opname = "Null";
      else if(step == 2)
         opname = "In";
      else if(step == 4)
         opname = "Standby";
   }
   // Put
   else {
      // 1/2/3/4
      if(step == 1)
         opname = "Standby";
      else if(step == 2)
         opname = "In";
      else if(step == 4)
         opname = "Wafer";
   }

   // fname
   fname = path + posname + "-" + opname + ".bmp";
   if(FileExists(fname))
      imWaferPosition->Picture->LoadFromFile(fname);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnLoopTestClick(TObject *Sender)
{
int loopcnt,loopno,startno,endno,workno,indexno,nextno;

   // 2022 9 15 - chc 退last片
   boolLastAbort = false;

   pnlLoopTest->Color = clSilver;
   loopcnt = edLoopTestCount->Text.ToInt();
   loopno = 0;
   pnlLoopTestCount->Caption = IntToStr(loopno);
   frmMaintenance->pnlLoopTestCount->Caption = pnlLoopTestCount->Caption;

   // 2022 9 5 - chc frmInspection
   frmInspection->pnlLoopTestCount->Caption = IntToStr(loopno);

   btnLoopTestStop->Visible = true;
   boolLoopStop = false;
   btnLoopTest->Enabled = false;
   if(rgLoopTest->ItemIndex == 0) {
      startno = 25 - rgWaferNo->ItemIndex;
      endno = 25 - rgWaferNo->ItemIndex;
   }
   else {
      startno = GetFirstNo();
      endno = GetLastNo();
      if(startno == -1 || endno == -1) {
         pnlOperationMessage->Caption = "Foup無Wafer!";
         pnlLoopTest->Color = clRed;
         goto end;
      }
   }
   if(CheckWithWafer(startno) == false) {
      pnlOperationMessage->Caption = "Foup指定位置無Wafer! " + IntToStr(startno);
      pnlLoopTest->Color = clRed;
      goto end;
   }
   boolInLoopTest = true;

   // 2022 9 5 - chc 顯示Inspection Form
   if(frmInspection->Visible == false)
      frmInspection->Show();

   // 2022 9 5 - chc frmInspection
   frmInspection->edLoopTestCount->Text = edLoopTestCount->Text;

   // startno: 1 - 25
   // workno: 1 - 25
   // indexno: 24 - 0
   workno = startno;
   while(1) {
nextwafer:
      if(CheckWithWafer(workno) == false) {
         pnlOperationMessage->Caption = "Foup指定位置無Wafer(作業前檢查)! " + IntToStr(workno);
         pnlLoopTest->Color = clRed;
         goto end;
      }
      if(boolLoopStop == true) {
         pnlOperationMessage->Caption = "Loop測試中斷!";
         pnlLoopTest->Color = clMaroon;

         // 2022 9 15 - chc 退last片
         // 2022 9 15a - chc 先不做
         //if(cbDoubleWafer->Checked == true) {
         //   WriteSystemLog("[雙片作業]");
         //   if(StageInformation[STAGE_MACRO].boolWithWafer == true && StageInformation[STAGE_CHUCK].boolWithWafer == false) {
         //      pnlSystemMessage->Caption = "[雙片作業]退最後一片: 在Macro...";
         //      WriteSystemLog(pnlSystemMessage->Caption);
         //      boolLastAbort = true;
         //      goto exitnext;
         //  }
         //}

         goto end;
      }
      indexno = 25 - workno;
      rgWaferNo->ItemIndex = indexno;
dirnext:
      btnLoadWaferClick(this);
      if(pnlLoadWafer->Color != clLime) {
         pnlSystemMessage->Caption = "取片異常!";
         pnlLoopTest->Color = clRed;
         goto end;
      }
      WaitTime(2000);
exitnext:
      btnUnloadWaferClick(this);
      if(pnlUnloadWafer->Color != clLime) {
         pnlSystemMessage->Caption = "退片異常!";
         pnlLoopTest->Color = clRed;
         goto end;
      }

      // 2022 9 15 - chc 退last片
      if(boolLoopStop == true && boolLastAbort == true)
         goto end;

      if(workno == endno) {

         // 2022 9 12a - chc Macro是否還有片?
         WriteSystemLog("最後一片已退片.");
         if(cbDoubleWafer->Checked == true) {
            WriteSystemLog("[雙片作業]");
            if(StageInformation[STAGE_MACRO].boolWithWafer == true) {
               pnlSystemMessage->Caption = "[雙片作業]取最後一片: 在Macro...";
               WriteSystemLog(pnlSystemMessage->Caption);
               goto dirnext;
            }
         }

         workno = startno;
      }
      else {

         // 2022 9 12 - chc Macro是否還有片?
         WriteSystemLog("已退片非最後一片, 繼續...");

         nextno = GetNextNo(workno);
         if(nextno == -1) {

            // 2022 9 12 - chc Macro是否還有片?
            WriteSystemLog("已最後一片, 結束作業.");

            pnlOperationMessage->Caption = "Foup指定下一位置無Wafer! " + IntToStr(workno);
            pnlLoopTest->Color = clRed;
            goto end;
         }
         workno = nextno;

         // 所有片
         if(rgLoopTest->ItemIndex == 1) {
            goto nextwafer;
         }

      }
      loopno++;
      pnlLoopTestCount->Caption = IntToStr(loopno);
      frmMaintenance->pnlLoopTestCount->Caption = pnlLoopTestCount->Caption;

      // 2022 9 5 - chc frmInspection
      frmInspection->pnlLoopTestCount->Caption = IntToStr(loopno);

      if(loopno >= loopcnt) {
         pnlOperationMessage->Caption = "Loop測試完成.";
         break;
      }
      if(cbLoopPause->Checked == true) {
         if(Application->MessageBox(("準備做Loop" + IntToStr(loopno+1) + ", 第" + IntToStr(workno) + "片?    ").c_str(), "Loop作業", MB_YESNO|MB_SYSTEMMODAL) == IDNO) {
            pnlLoopTest->Color = clGreen;
            goto end;
         }
      }
   }
   pnlLoopTest->Color = clLime;

end:
   btnLoopTest->Enabled = true;
   btnLoopTestStop->Visible = false;
   boolInLoopTest = false;

   // 2022 9 15 - chc 退last片
   boolLoopStop = false;
   boolLastAbort = false;

   // 2022 9 5 - chc 顯示Inspection Form
   if(frmInspection->Visible == true)
      frmInspection->Close();

}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnLoopTestStopClick(TObject *Sender)
{

   boolLoopStop = true;
   btnLoopTestStop->Visible = false;
}
//---------------------------------------------------------------------------
// 0 - 24 (25 - 1)
int __fastcall TfrnMain::GetFirstNo()
{
TPanel *panel;
int no=-1;

   // pnlTray1
   for(no=1 ; no<=25 ; no++) {
      if(rgFoupSource->ItemIndex == LOADPORT_1)
         panel = (TPanel*)(FindComponent("pnlTray" + IntToStr(no) + "Select"));
      else
         panel = (TPanel*)(FindComponent("pnlTray2_" + IntToStr(no) + "Select"));
      if(panel->Color == clLime) {
         break;
      }
   }
   return no;
}
//---------------------------------------------------------------------------
// 0 - 24 (25 - 1)
int __fastcall TfrnMain::GetLastNo()
{
TPanel *panel;
int no=-1;

   // pnlTray1
   for(no=25 ; no>=1 ; no--) {
      if(rgFoupSource->ItemIndex == LOADPORT_1)
         panel = (TPanel*)(FindComponent("pnlTray" + IntToStr(no) + "Select"));
      else
         panel = (TPanel*)(FindComponent("pnlTray2_" + IntToStr(no) + "Select"));
      if(panel->Color == clLime) {
         break;
      }
   }
   return no;
}
//---------------------------------------------------------------------------
// 0 - 24 (25 - 1)
int __fastcall TfrnMain::GetNextNo(int cno)
{
TPanel *panel;
int no=-1;

// 2022 9 12a - chc GetNextNo()寫錯! 用slotno
int slotno = -1;

   // pnlTray1
   for(no=cno+1 ; no<=25 ; no++) {
      if(rgFoupSource->ItemIndex == LOADPORT_1)
         panel = (TPanel*)(FindComponent("pnlTray" + IntToStr(no) + "Select"));
      else
         panel = (TPanel*)(FindComponent("pnlTray2_" + IntToStr(no) + "Select"));
      if(panel->Color == clLime) {

         // 2022 9 12a - chc 用slotno
         slotno = no;

         break;
      }
   }

   // 2022 9 12a - chc 用slotno
   //return no;
   return slotno;
}
//---------------------------------------------------------------------------
// 0 - 24 (25 - 1)
bool __fastcall TfrnMain::CheckWithWafer(int cno)
{
TPanel *panel;
int no=-1;

   // pnlTray1
   if(rgFoupSource->ItemIndex == LOADPORT_1)
      panel = (TPanel*)(FindComponent("pnlTray" + IntToStr(cno)));
   else
      panel = (TPanel*)(FindComponent("pnlTray2_" + IntToStr(cno)));
   if(panel->Color == clLime)
      return true;
   return false;
}
//---------------------------------------------------------------------------
void __fastcall TfrnMain::InitStageInformation()
{

   for(int i=0 ; i<STAGE_MAX_NO ; i++) {
      StageInformation[i].boolWithWafer = false;
      StageInformation[i].SlotNo = -1;
      StageInformation[i].FoupNo = -1;
      StageInformation[i].WaferID = "";
   }
}
//---------------------------------------------------------------------------
// 2022 8 24 - chc 自動計數: 退片後自動指到下一片 
void __fastcall TfrnMain::cbAutoLoadClick(TObject *Sender)
{

   pbWafer->Visible = cbAutoLoad->Checked;
   pbWafer->Position = 0;
   frmMaintenance->pbWafer->Position = pbWafer->Position;
}
//---------------------------------------------------------------------------
// 關閉
void __fastcall TfrnMain::imMapCloseClick(TObject *Sender)
{


   cbEFEM->Checked = false;
   pnlEFEM->Visible = cbEFEM->Checked;
}
//---------------------------------------------------------------------------


void __fastcall TfrnMain::csYuanliSocketConnect(TObject *Sender,
      TCustomWinSocket *Socket)
{

   pnlYuanliSocketConnect->Color = clLime;
   pnlOlympusStatus->Color = clLime;
   btnYuanliSend->Enabled = true;
   boolYuanliSocket = true;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::csYuanliSocketDisconnect(TObject *Sender,
      TCustomWinSocket *Socket)
{

   pnlYuanliSocketConnect->Color = clSilver;
   pnlOlympusStatus->Color = clSilver;
   pnlSocketReady->Color = clSilver;
   btnYuanliSend->Enabled = false;
   boolYuanliSocket = false;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::csYuanliSocketError(TObject *Sender,
      TCustomWinSocket *Socket, TErrorEvent ErrorEvent, int &ErrorCode)
{

   ErrorCode = 0;
   pnlYuanliSocketConnect->Color = clRed;
   pnlOlympusStatus->Color = clRed;
   pnlSocketReady->Color = clRed;
   btnYuanliSend->Enabled = false;
   boolYuanliSocket = false;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::csYuanliSocketRead(TObject *Sender,
      TCustomWinSocket *Socket)
{
static AnsiString eceivestr;
static bool inactive = false;
AnsiString text,cmdstr,slen,scmd,spar[30];
bool flag,done;
int pos,parcnt;

   if(inactive == true) {
      AddYuanliMessage("[<] Re-Entrant!");
      return;
   }
   inactive = true;
   text = Socket->ReceiveText();
   AddYuanliMessage("[<] " + text);

   // 2021 5 7 - chc 要移到while裡面
   //done = false;
   //parcnt = 0;

   // 分段
   // 07,Init,e>
   while((pos = text.Pos(">")) != 0) {

      // 2021 5 7 - chc 要移到while裡面
      done = false;
      parcnt = 0;

      // 取得完整命令字串
      cmdstr = text.SubString(1,pos);
      pnlYuanli->Caption = cmdstr;
      text.Delete(1,pos);
      pos = cmdstr.Pos(",");
      if(pos == 0) {                                                         // No Parameter!
         AddYuanliMessage("[<] Invalid: " + cmdstr);
         flag = false;
         continue;
      }
      slen = cmdstr.SubString(1,pos-1);
      cmdstr.Delete(1,pos);
      // Cmd
      pos = cmdstr.Pos(",");
      if(pos == 0) {
         pos = cmdstr.Pos(">");
         if(pos == 0) {
            AddYuanliMessage("[<] Invalid");
            flag = false;
            continue;
         }
         else {
            scmd = cmdstr.SubString(1,pos-1);
            cmdstr.Delete(1,pos);
            done = true;
         }
      }
      else {
         scmd = cmdstr.SubString(1,pos-1);
         cmdstr.Delete(1,pos);
      }
      AddYuanliMessage("[<] " + scmd);

      // Par
      while(done == false) {
         pos = cmdstr.Pos(",");
         if(pos == 0) {
            pos = cmdstr.Pos(">");
            if(pos == 0) {
               AddYuanliMessage("[<] Invalid");
               flag = false;
               continue;
            }
            else {
               spar[parcnt++] = cmdstr.SubString(1,pos-1);
               cmdstr.Delete(1,pos);
               done = true;
            }
         }
         else {
            spar[parcnt++] = cmdstr.SubString(1,pos-1);
            cmdstr.Delete(1,pos);
         }

         // 2021 4 28 - chc parcnt > 0
         if(parcnt > 0)

            AddYuanliMessage("[LC] " + spar[parcnt-1] + " : " + IntToStr(parcnt));
         if(cmdstr.Length() <= 0)
            break;
      }
      Decode(scmd,spar,parcnt,1);
   }
   inactive = false;
}
//---------------------------------------------------------------------------
// 2022 8 26 - chc Yuanli socket
// mode: 0-Simulate, 1-Socket
// Motion, ReadRecipe, GetErr
void __fastcall TfrnMain::Decode(AnsiString scmd, AnsiString *spar, int parcnt, int mode)
{
int cmdno,parno,len;
AnsiString sack,astr;
bool boolresult = false;
char brf[500];
double par1,par2;

   cmdno = GetCmdSet(scmd);

   // Log
   WriteSystemLog("Decode() cmd, cmdno, parcnt= " + scmd + "," + IntToStr(cmdno) + "," + IntToStr(parcnt));

   if(cmdno == -1) {
      AddYuanliMessage("Invalid");
      if(mode == 1) {
         SnedSocket("Invalid",0);
      }
      return;
   }

   // 12個
   switch(cmdno) {
      case CMD_YUANLI:
         WriteSystemLog("是YuanLi指令: " + scmd + "," + spar[0]);
         parno = 1;
         break;
      case CMD_MOVE:
         parno = 1;
         break;
      case CMD_BUSY:
         parno = 1;
         break;
      case CMD_INVALID:
         parno = 1;
         break;
      case CMD_MOTION:
         parno = 0;
         break;
      case CMD_GET_ERR:
         parno = 0;
         break;
      case CMD_SCANDONE:
         parno = 0;
         break;
   }
   if(parcnt != parno) {
      AddYuanliMessage("Invalid: 參數數量不對!");
      if(mode == 1) {
         SnedSocket("Invalid",0);
      }
      return;
   }

   if(parcnt == 1 && (spar[0] == "s" || spar[0] == "e" || spar[0] == "x"))
      // nothing
      len = 1;
   else

      // 2022 9 5 - chc 不用%02d
      if(cb2Code->Checked == true)
         sack.sprintf("%02d,%s,s>",scmd.Length()+3,scmd.c_str());
      else
         sack.sprintf("%d,%s,s>",scmd.Length()+3,scmd.c_str());

   AddYuanliMessage("[>] " + sack);
   if(mode == 1) {
      SnedSocket(sack,1);
   }
   pnlAIMessage->Caption = sack;
   pnlAIMessage->Refresh();
   Sleep(eduanliDelayTime->Text.ToInt());
   // Do Parameter
   switch(cmdno) {
      case CMD_YUANLI:
         WriteSystemLog("是YuanLi指令, 參數= " + spar[0]);
         if(spar[0] == "s" || spar[0] == "e") {
            pnlSocketReady->Color = clLime;
            AddYuanliMessage("[<] YuanLi - " + spar[0]);
            //if(spar[0] == "e")
               YuanliCmdStatus[CMD_YUANLI] = CMD_ACK_E;
         }
         else if(spar[0] == "x") {
            pnlSocketReady->Color = clRed;
            AddYuanliMessage("[<] YuanLi - x");
            YuanliCmdStatus[CMD_YUANLI] = CMD_ACK_X;
         }
         break;
      case CMD_MOVE:
         if(spar[0] == "s" || spar[0] == "e") {
            pnlSocketReady->Color = clLime;
            AddYuanliMessage("[<] Mode - " + spar[0]);
            //if(spar[0] == "e")
               YuanliCmdStatus[CMD_MOVE] = CMD_ACK_E;
         }
         else if(spar[0] == "x") {
            pnlSocketReady->Color = clRed;
            AddYuanliMessage("[<] Mode - x");
            YuanliCmdStatus[CMD_MOVE] = CMD_ACK_X;
         }
         break;
      case CMD_BUSY:
         if(spar[0] == "s" || spar[0] == "e") {
            pnlSocketReady->Color = clLime;
            AddYuanliMessage("[<] Busy - " + spar[0]);
            //if(spar[0] == "e")
               YuanliCmdStatus[CMD_BUSY] = CMD_ACK_E;
         }
         else if(spar[0] == "x") {
            pnlSocketReady->Color = clRed;
            AddYuanliMessage("[<] Busy - x");
            YuanliCmdStatus[CMD_BUSY] = CMD_ACK_X;
         }
         break;
      case CMD_INVALID:
         if(spar[0] == "s" || spar[0] == "e") {
            pnlSocketReady->Color = clLime;
            AddYuanliMessage("[<] Invalid - " + spar[0]);
            //if(spar[0] == "e")
               YuanliCmdStatus[CMD_INVALID] = CMD_ACK_E;
         }
         else if(spar[0] == "x") {
            pnlSocketReady->Color = clRed;
            AddYuanliMessage("[<] Invalid - x");
            YuanliCmdStatus[CMD_INVALID] = CMD_ACK_X;
         }
         break;

      case CMD_MOTION:
         break;
      case CMD_GET_ERR:
         boolresult = true;
         break;
      case CMD_SCANDONE:
         break;
   }

   // 要將ToYuanli的指令避開
   if(cmdno < CMD_MOTION)
      return;
   rgCommand->ItemIndex = cmdno - CMD_MOTION;

   if(boolresult == true) {
      if(cmdno == CMD_GET_ERR) {

         // 2022 9 5 - chc 不用%02d
         if(cb2Code->Checked == true)
            sack.sprintf("%02d,%s,%s>",scmd.Length()+6,scmd.c_str(),pnlErrorCode->Caption.c_str());
         else
            sack.sprintf("%d,%s,%s>",scmd.Length()+6,scmd.c_str(),pnlErrorCode->Caption.c_str());

      }
      else {

         // 2022 9 5 - chc 不用%02d
         if(cb2Code->Checked == true)
            sack.sprintf("%02d,%s,e>",scmd.Length()+3,scmd.c_str());
         else
            sack.sprintf("%d,%s,e>",scmd.Length()+3,scmd.c_str());

      }
      AddYuanliMessage("[>] " + sack);
      if(mode == 1) {
         SnedSocket(sack,1);
      }
      pnlAIMessage->Caption = sack;
      pnlAIMessage->Refresh();
   }
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::rgYuanliCommandSetClick(TObject *Sender)
{

int no;
double t;
AnsiString cmd;
int zero;
AnsiString msg;

   no = rgYuanliCommandSet->ItemIndex;
   switch(no) {
      // YuanLi
      case CMD_YUANLI:
         cmd = "YuanLi";
         break;
      // Move
      case CMD_MOVE:
         cmd = "Move";
         break;
      // Busy
      case CMD_BUSY:
         cmd = "Busy";
         break;
      // Invalid
      case CMD_INVALID:
         cmd = "Invalid";
         break;
   }
   edYuanliCmd->Text = cmd;
   AddYuanliMessage("[*] " + cmd);

   // 是否送出Command : boolSendYuanliCommand
   if(boolSendYuanliCommand == true) {
      boolSendYuanliCommand = false;
      btnYuanliSendClick(this);
   }

}
//---------------------------------------------------------------------------
// to Motin: Motion, GetErr
// to YUANLI: YuanLi, Move, Busy, Invalid
void __fastcall TfrnMain::SetCmdSet()
{

   CmdSet[0] = "YuanLi";
   CmdSet[1] = "Move";
   CmdSet[2] = "Busy";
   CmdSet[3] = "Invalid";

   CmdSet[4] = "Motion";
   CmdSet[5] = "GetErr";
   CmdSet[6] = "ScanDone";
}
//---------------------------------------------------------------------------
// -1: Fail
int __fastcall TfrnMain::GetCmdSet(AnsiString cmd)
{

   for(int i=0 ; i<CMD_MAX ; i++) {
      if(cmd == "Yuani")
         return CMD_YUANLI;
      if(CmdSet[i] == cmd) {
         return i;
      }
   }
   return -1;
}
//---------------------------------------------------------------------------
// mode
//#define CMD_YUANLI              0
//#define CMD_MOVE                1
//#define CMD_BUSY                2
//#define CMD_INVALID             3
// ret s/e/x
//#define CMD_ACK_WAIT              0
//#define CMD_ACK_E                 1
//#define CMD_ACK_X                 2
//#define CMD_ACK_TIMEOUT           3
//int YuanliCmdStatus[YUANLI_CMD_NO];
// Send and wait
int __fastcall TfrnMain::WaitYuanliCmd(int mode)
{
long StartTime,StopTime,Elapsedms;
short StartTick,StopTick;
// 30sec
int timeout = 6000;

   // 先確認YuanLi是否連線?
   if(pnlOlympusStatus->Color != clLime) {
      YuanliCmdStatus[mode] = CMD_ACK_X;
      return YuanliCmdStatus[mode];
   }

   // Set init status
   YuanliCmdStatus[mode] = CMD_ACK_WAIT;

   // Send
   rgYuanliCommandSet->ItemIndex = -1;
   boolSendYuanliCommand = true;
   rgYuanliCommandSet->ItemIndex = mode;

   // 2022 9 5 - chc 若為取片Scan則要縮短Timeout時間
   if(boolInLoad == true && cbChuckScan->Checked == true) {
      // 2022 9 6 - chc 改成0.2sec
      //timeout = 2000;
      timeout = 200;
   }

   GetTimeTic(&StartTime,&StartTick);
   while(1) {
      WaitTime(100);
      GetTimeTic(&StopTime,&StopTick);
      Elapsedms = ((StopTime*1000+StopTick) - (StartTime*1000+StartTick));
      if(Elapsedms > timeout) {
         WriteSystemLog("YuanLi Socket Command Timeout!");
         return CMD_ACK_TIMEOUT;
      }
      if(YuanliCmdStatus[mode] == CMD_ACK_E || YuanliCmdStatus[mode] == CMD_ACK_X)
         return YuanliCmdStatus[mode];
   }
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnYunliReConnectClick(TObject *Sender)
{

   csYuanliSocket->Address = edYuanliIP->Text;
   csYuanliSocket->Port = edYuanliPort->Text.ToInt();

   try {
      csYuanliSocket->Active = false;
      WaitTime(1500);
      csYuanliSocket->Active = true;
   }
   catch(Exception &e) {
      WriteSystemLog(">>Error(btnYunliReConnectClick): "+e.Message);
      pnlSystemMessage->Caption = "Yuanli Socket重連線失敗!";
   }
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnYuanliSendClick(TObject *Sender)
{
int no,sno,count,eno,timedelay;

   btnYuanliSend->Enabled = false;

   pnlSocketReady->Color = clSilver;
   int pos,len;
   AnsiString cmd,str;
   char buf[50];
   pnlYuanliSend->Color = clSilver;
   str = edYuanliCmd->Text;
   len = str.Length();
   if(len <= 0) {
      pnlYuanliSend->Color = clRed;
      return;
   }
   len += 1;

   // 2022 9 5 - chc 不用%02d
   if(cb2Code->Checked == true)
      cmd.sprintf("%02d,%s>",len,str.c_str());
   else
      cmd.sprintf("%d,%s>",len,str.c_str());

   sprintf(buf,"%s",cmd.c_str());
   pnlYuanli->Caption = cmd;
   len = strlen(buf);
   AddYuanliMessage("[>] " + pnlYuanli->Caption);

   if(csYuanliSocket->Active == true) {
      pnlYuanliSend->Color = clLime;
      csYuanliSocket->Socket->SendBuf(buf,len);
   }

   btnYuanliSend->Enabled = true;
   return;
}
//---------------------------------------------------------------------------
// 2022 8 26 - chc Yuanli socket
void __fastcall TfrnMain::AddYuanliMessage(AnsiString msg)
{
AnsiString putmsg;
static AnsiString oldmsg = "";

   if(oldmsg == msg)                            // 重複不收錄
      return;
   oldmsg = msg;
   putmsg = Now().FormatString("hh':'nn':'ss':'zzz'-> '") + msg;
   // 最多共470 Rows
   mmYuanli->Lines->Insert(0,putmsg);
   // Realtime
   mmYuanli->Refresh();

   if(mmYuanli->Lines->Count > 500) {
      for(int i=470 ; i<mmYuanli->Lines->Count ; i++)
         mmYuanli->Lines->Delete(i);
   }
}
//---------------------------------------------------------------------------
// 2022 8 26 - chc YuanLi是否連線
bool __fastcall TfrnMain::YuanLiConnect()
{
int no;
bool boolreconnect = false;

   if(pnlYuanliSocketConnect->Color != clLime) {
again:
      boolreconnect = true;
      pnlOperationMessage->Caption = "YuanLi未連線, 重連線中...";
      pnlSystemMessage->Caption = pnlOperationMessage->Caption;
      WriteSystemLog(pnlOperationMessage->Caption);
      btnYunliReConnectClick(this);
      no = 0;
      while(1) {
         if(pnlYuanliSocketConnect->Color == clLime) {
            pnlOperationMessage->Caption = "YuanLi已連線, 測試通訊...";
            pnlSystemMessage->Caption = pnlOperationMessage->Caption;
            WriteSystemLog(pnlOperationMessage->Caption);
            break;
         }
         WaitTime(100);
         no++;
         // 10sec
         if(no > 100) {
            pnlOperationMessage->Caption = "YuanLi通訊失敗(Timeout)!";
            pnlSystemMessage->Caption = pnlOperationMessage->Caption;
            WriteSystemLog(pnlOperationMessage->Caption);
            boolYuanliSocket = false;
            return false;
         }
      }
   }
   // YuanLi Command
   if(WaitYuanliCmd(CMD_YUANLI) != CMD_ACK_E) {
      if(boolreconnect == false) {
         pnlOperationMessage->Caption = "YuanLi通訊失敗! 重連線中...";
         pnlSystemMessage->Caption = pnlOperationMessage->Caption;
         WriteSystemLog(pnlOperationMessage->Caption);
         pnlYuanliSocketConnect->Color = clSilver;
         WaitTime(500);
         goto again;
      }
      pnlOperationMessage->Caption = "YuanLi通訊失敗!";
      pnlSystemMessage->Caption = pnlOperationMessage->Caption;
      WriteSystemLog(pnlOperationMessage->Caption);
      boolYuanliSocket = false;
      return false;
   }
   pnlOperationMessage->Caption = "YuanLi通訊ok.";
   pnlSystemMessage->Caption = pnlOperationMessage->Caption;
   WriteSystemLog(pnlOperationMessage->Caption);
   boolYuanliSocket = true;
   return true;
}
//---------------------------------------------------------------------------
// mode: 0-未加入長度, 1-已加入長度
void __fastcall TfrnMain::SnedSocket(AnsiString str, int mode)
{
AnsiString astr,sack;
int len;
char buf[500];

   astr = str;
   if(mode == 0) {
      len = astr.Length();

      // 2022 9 5 - chc 不用%02d
      if(cb2Code->Checked == true)
         sack.sprintf("%02d,%s>",len+1,astr.c_str());
      else
         sack.sprintf("%d,%s>",len+1,astr.c_str());

      sprintf(buf,"%s",sack.c_str());
   }
   else {
      sprintf(buf,"%s",astr.c_str());
   }
   len = strlen(buf);

   csYuanliSocket->Socket->SendBuf(buf,len);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::pnlMainRecipeClick(TObject *Sender)
{

   // Main
   SetST(ST_RECIPE,true);

   //frmRecipe->Visible =! frmRecipe->Visible;
   if(PriorityLevel == PRIORITY_OP) {
      frmRecipe->pnlAdminstrator->BevelInner = Controls::bvRaised;
      frmRecipe->pnlOperator->BevelInner = Controls::bvLowered;
   }
   else {
      frmRecipe->pnlAdminstrator->BevelInner = Controls::bvLowered;
      frmRecipe->pnlOperator->BevelInner = Controls::bvRaised;
   }
   frmRecipe->ShowModal();
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::pnlMainInspectionClick(TObject *Sender)
{

   // Main
   SetST(ST_INSPECTION,true);

   //frmInspection->Visible =! frmInspection->Visible;
   frmInspection->ShowModal();
}
//---------------------------------------------------------------------------
// 2022 9 2 - chc Get/Put前先將Arm收回
bool __fastcall TfrnMain::RobotArmWithDraw()
{

   // 2022 9 14 - chc 暫不做
   return true;

   if(SendRobotPosCMD(1) == false) {
      return false;
   }
   return true;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::pnlMainClick(TObject *Sender)
{

   //frnMain->Visible = false;
   //frmLogo->ShowModal();
   pnlEFEM->Visible = false;
   //frnMain->pnlSystem->Visible = true;
   cbEFEM->Checked = false;
   if(frmLogo->Visible == false) {
      frmLogo->Visible = true;
   }
}
//---------------------------------------------------------------------------
// 2022 9 5 - chc 雙片作業
// 1. CST取片(nextno)
// 2. 放到Macro
// => 不用檢查狀態
void __fastcall TfrnMain::DoChuckMeasure()
{

   // 2022 9 7 - chc 改成Timer 5次
   MeasurePointNo = 0;

   WriteSystemLog("設定Timer(同步做Chuck 5點量測): tmChuckMeasure");
   tmChuckMeasure->Enabled = true;
}
//---------------------------------------------------------------------------


void __fastcall TfrnMain::pnlMovingClick(TObject *Sender)
{

   pnlMoving->Visible = false;
}
//---------------------------------------------------------------------------
// 100ms
void __fastcall TfrnMain::tmChuckMeasureTimer(TObject *Sender)
{

   WriteSystemLog("tmChuckMeasureTimer: Enter: " + IntToStr(MeasurePointNo+1));
   tmChuckMeasure->Enabled = false;
   boolChuckMeasure = true;

   // 2022 9 7 - chc 改成Timer 5次
   //if(ChuckMeasure() == false)
   //   boolChuckMeasureResult = false;
   //else
   //   boolChuckMeasureResult = true;
   int delaytime;
   delaytime = edDemoPointTime->Text.ToInt();
   MeasurePointNo++;

   // 2022 9 12 - chc 分離全部做或分段做
   //if(ChuckMeasure() == false) {
   if(ChuckMeasure(2) == false) {

      boolChuckMeasureResult = false;
   }
   else {
      if(MeasurePointNo < 5) {
         tmChuckMeasure->Interval = delaytime;
         tmChuckMeasure->Enabled = true;
      }
      else {
         boolChuckMeasureResult = true;

         // 2022 9 12 - chc Reset為-1
         MeasurePointNo = -1;

      }
   }
}
//---------------------------------------------------------------------------
// 5 點移動
// 2022 9 12 - chc 分離全部做或分段做: 1-全做, 2-分段做
//bool __fastcall TfrnMain::ChuckMeasure()
bool __fastcall TfrnMain::ChuckMeasure(int mode)

{
int delaytime;

   delaytime = edDemoPointTime->Text.ToInt();

   WriteSystemLog("執行: ChuckMeasure, mode[1-全部, 2-分段]= " + IntToStr(mode));

   // 5點移動
   // 2022 9 7 - chc 改成Timer 5次
   if(mode == 1)

      MeasurePointNo = -1;

   if(cbChuckDemo->Checked == true) {

      // 2022 9 7 - chc 改成Timer 5次
      // 2022 9 12 - chc 分離全部做或分段做: 1-全做, 2-分段做
      //if(MeasurePointNo == 1) {
      if(MeasurePointNo == 1 || mode == 1) {

         WriteSystemLog("執行: ChuckMeasure 5點...");
         // 開啟檢測視窗
         if(frmInspection->Visible != true) {
            WaferGetStep = 2;
            // 不可以用ShowModal()會不動
            //frmInspection->ShowModal();
            frnMain->Enabled = false;
            frmInspection->Show();
         }
      }

      // 2022 9 12 - chc 分離全部做或分段做: 1-全做, 2-分段做
      if(mode == 1 || (mode == 2 && MeasurePointNo == 1)) {

         MeasurePointNo = 1;
         WriteSystemLog("To Pos1...");
         btnPos1GoClick(this);
         WriteSystemLog("To Pos1.");
         if(pnlToUserPosition->Color != clLime) {
            pnlLoadWafer->Color = clRed;
            pnlOperationMessage->Caption = "取片失敗: Chuck第1點移動失敗!";
            WriteSystemLog(pnlOperationMessage->Caption);
            goto error1;
         }
         WaitTimeChuck(delaytime);
      }

      // 2022 9 12 - chc 分離全部做或分段做: 1-全做, 2-分段做
      if(mode == 1 || (mode == 2 && MeasurePointNo == 2)) {

         MeasurePointNo = 2;
         WriteSystemLog("To Pos2...");
         btnPos2GoClick(this);
         WriteSystemLog("To Pos2.");
         if(pnlToUserPosition->Color != clLime) {
            pnlLoadWafer->Color = clRed;
            pnlOperationMessage->Caption = "取片失敗: Chuck第2點移動失敗!";
            WriteSystemLog(pnlOperationMessage->Caption);
            goto error1;
         }
         WaitTimeChuck(delaytime);
      }

      // 2022 9 12 - chc 分離全部做或分段做: 1-全做, 2-分段做
      if(mode == 1 || (mode == 2 && MeasurePointNo == 3)) {

         MeasurePointNo = 3;
         WriteSystemLog("To Pos3...");
         btnPos3GoClick(this);
         WriteSystemLog("To Pos3.");
         if(pnlToUserPosition->Color != clLime) {
            pnlLoadWafer->Color = clRed;
            pnlOperationMessage->Caption = "取片失敗: Chuck第3點移動失敗!";
            WriteSystemLog(pnlOperationMessage->Caption);
            goto error1;
         }
         WaitTimeChuck(delaytime);
      }

      // 2022 9 12 - chc 分離全部做或分段做: 1-全做, 2-分段做
      if(mode == 1 || (mode == 2 && MeasurePointNo == 4)) {

         MeasurePointNo = 4;
         WriteSystemLog("To Pos4...");
         btnPos4GoClick(this);
         WriteSystemLog("To Pos4.");
         if(pnlToUserPosition->Color != clLime) {
            pnlLoadWafer->Color = clRed;
            pnlOperationMessage->Caption = "取片失敗: Chuck第4點移動失敗!";
            WriteSystemLog(pnlOperationMessage->Caption);
            goto error1;
         }
         WaitTimeChuck(delaytime);
      }

      // 2022 9 12 - chc 分離全部做或分段做: 1-全做, 2-分段做
      if(mode == 1 || (mode == 2 && MeasurePointNo == 5)) {

         MeasurePointNo = 5;
         WriteSystemLog("To Pos5...");
         btnPos5GoClick(this);
         WriteSystemLog("To Pos5.");
         if(pnlToUserPosition->Color != clLime) {
            pnlLoadWafer->Color = clRed;
            pnlOperationMessage->Caption = "取片失敗: Chuck第5點移動失敗!";
            WriteSystemLog(pnlOperationMessage->Caption);
            goto error1;
         }
         WriteSystemLog("執行: ChuckMeasure 5點完成.");

         // 2022 9 12 - chc Mode=1才要Reset
         if(mode == 1)

            MeasurePointNo = -1;
      }
   }
   // 移到Center
   else {
      btnToCenterPositionClick(this);
      if(pnlToCenterPosition->Color != clLime)
         goto error1;
   }
   return true;

error1:
   return false;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::tmMacroDemoTimer(TObject *Sender)
{

   WriteSystemLog("tmMacroDemoTimer: Enter...");
   tmMacroDemo->Enabled = false;
   boolMacroDemo = true;
   // 開啟檢測視窗
   if(frmInspection->Visible != true) {
      WaferGetStep = 1;
      // 不可以用ShowModal()會不動
      //frmInspection->ShowModal();
      //frnMain->Enabled = false;
      frmInspection->Show();
   }
   btnMacroDemoClick(this);
   //frnMain->Enabled = true;
   // 開啟檢測視窗
   //if(frmInspection->Visible == true) {
   //   frmInspection->Close();
   //}
   if(pnlMacroDemo->Color != clLime) {
      pnlOperationMessage->Caption = "取片失敗: Macro Demo異常!";
      WriteSystemLog(pnlOperationMessage->Caption);
   }
   else
      boolMacroDemoResult = true;
   WriteSystemLog("tmMacroDemoTimer: Leave");

}
//---------------------------------------------------------------------------
// Wait time: Chuck
void __fastcall TfrnMain::WaitTimeChuck(int no)
{
long starttime,stoptime,elapsedms;
short starttick,stoptick;
int cnt = 0;

   // 2022 9 23 - chc 進來與離開各做一次
   if(boolInMotionUpdate == false) {
      UpdateMotionStatus();
   }

   frnMain->GetTimeTic(&starttime,&starttick);
   while(1) {

      // 2022 9 23 - chc 進來與離開各做一次
      //if(boolInMotionUpdate == false) {
      //   UpdateMotionStatus();
      //}

      // 2022 9 22a - chc 不做看看
      // 2022 9 27 - chc 要做: 因不會更新其他: Robot RS232
      Application->ProcessMessages();

      // 2022 9 5 - chc 改成2, 因有時不會更新DI!!!
      //Sleep(2);
      Sleep(10);

      cnt++;
      if(cnt >= 1) {
         cnt = 0;
         frnMain->GetTimeTic(&stoptime,&stoptick);
         elapsedms = ((stoptime*1000+stoptick) - (starttime*1000+starttick));
         if(elapsedms > no) {

            // 2022 9 23 - chc 進來與離開各做一次
            if(boolInMotionUpdate == false) {
               UpdateMotionStatus();
            }

            return;
         }
      }
   }
}
//---------------------------------------------------------------------------
// Wait time: Macro
int AskCount = 0;
int DoCount = 0;
void __fastcall TfrnMain::WaitTimeMacro(int no)
{
long starttime,stoptime,elapsedms;
short starttick,stoptick;
int cnt = 0;

   // 2022 9 22a - chc 進來與離開各做一次
   AskCount++;
   pnlAskCount->Caption = IntToStr(AskCount);
   pnlAskCount->Refresh();
   if(boolInMotionUpdate == false) {
      UpdateMotionStatus();
      DoCount++;
      pnlDoCount->Caption = IntToStr(DoCount);
      pnlDoCount->Refresh();
   }

   frnMain->GetTimeTic(&starttime,&starttick);
   while(1) {

      // 2022 9 22 - chc 記錄是否在做Z1 Up
      // 2022 9 22a - chc 進來與離開各做一次
      /*
      AskCount++;
      pnlAskCount->Caption = IntToStr(AskCount);

      if(boolInMotionUpdate == false) {
         UpdateMotionStatus();

         // 2022 9 15 - chc 記錄是否在做Z1 Up
         if(boolZ1InUp == true)
            WriteSystemLog("Z1 Up(WaitTimeMacro): 做DI更新");

         // 2022 9 22 - chc 記錄是否在做Z1 Up
         DoCount++;
         pnlDoCount->Caption = IntToStr(DoCount);

      }
      */

      // 2022 9 22a - chc 不做看看
      // 2022 9 27 - chc 要做: 因不會更新其他: Robot RS232
      Application->ProcessMessages();

      // 2022 9 5 - chc 改成2, 因有時不會更新DI!!!
      //Sleep(2);
      // 2022 9 22 - chc 太快! 改成20
      //Sleep(10);
      Sleep(20);

      cnt++;
      if(cnt >= 1) {
         cnt = 0;
         frnMain->GetTimeTic(&stoptime,&stoptick);
         elapsedms = ((stoptime*1000+stoptick) - (starttime*1000+starttick));
         if(elapsedms > no) {

            // 2022 9 22a - chc 進來與離開各做一次
            AskCount++;
            pnlAskCount->Caption = IntToStr(AskCount);
            pnlAskCount->Refresh();
            if(boolInMotionUpdate == false) {
               UpdateMotionStatus();
               DoCount++;
               pnlDoCount->Caption = IntToStr(DoCount);
               pnlDoCount->Refresh();
            }

            return;
         }
      }
   }
}
//---------------------------------------------------------------------------
// 2022 9 14 - chc 用Timer
void __fastcall TfrnMain::tmRobotLSTimer(TObject *Sender)
{
unsigned char command[50],buf[50];
AnsiString msg;
int len,cs1,cs2;
char checksum;
// 使用或不使用unsigned均一樣的結果GP 880 ( 0 0 40 0)
unsigned char checksum1;

   tmRobotLS->Enabled = false;
   edRobotCmd->Text = "LS";

   if(boolRobotStatus == false) {
      pnlRobotMessage->Caption = "未連線!";
      WriteSystemLog("btnRobotCMDClick: Robot尚未連線!");
      return;
   }

   // robot
   if(cbRobot->Checked == true)
      sprintf(command,"001 %s%c",edRobotCmd->Text,0x03);
   else
      // Aligner
      sprintf(command,"0000%s",edRobotCmd->Text);

   len = strlen(command);
   checksum = 0;
   checksum1 = 0;
   for(int i=0 ; i<len ; i++) {
      // Robot
      if(cbRobot->Checked == true) {
         checksum ^= command[i];
         checksum1 ^= command[i];
      }
      else
         // Aligner
         checksum += command[i];
   }

   // Robot
   if(cbRobot->Checked == true) {
      sprintf(buf,"%c%s",0x02,command);
      len = strlen(buf);
      sprintf(buf,"%c%s%c",0x02,command,checksum);
      len++;
      buf[len] = 0x0;
   }
   else {
      // Aligner
      int c1,c2;
      c1 = checksum & 0xf0;
      c1 = c1 >> 4;
      c2 = checksum & 0x0f;
      if(c1 < 10)
         c1 = c1 + '0';
      else
         c1 = c1 - 10 + 'A';
      if(c2 < 10)
         c2 = c2 + '0';
      else
         c2 = c2 - 10 + 'A';
      sprintf(buf,"%c%s%c%c%c",0x01,command,c1,c2,0x0d);
      len = strlen(buf);
      buf[len] = 0x0;
   }

   WriteSystemLog("tmRobotLSTimer: run...");
   ybRobot->Write(buf,len);
   pnlRobotOperation->Caption = "Busy";
   pnlRobot->Enabled = false;
   btnRobotEnable->Visible = true;

   msg.sprintf("CMD: %s",command);
   pnlSystemMessage->Caption = msg;
   WriteSystemLog(msg);

   AddRobotSendMessage(edRobotCmd->Text);
   pnlRobotMessage->Caption = msg;
   WriteSystemLog("tmRobotLSTimer: edRobotCmd= " + edRobotCmd->Text);
}
//---------------------------------------------------------------------------



void __fastcall TfrnMain::pnlStartMessageClick(TObject *Sender)
{

   pnlStartMessage->Visible = false;
}
//---------------------------------------------------------------------------
void __fastcall TfrnMain::pnlMainUserClick(TObject *Sender)
{

   SetST(ST_LEVEL,true);
   btnPasswordClick(this);
}
//---------------------------------------------------------------------------
// 2022 12 5 - chc Tool
#define ST_MAIN              0
#define ST_LEVEL             1
#define ST_RECIPE            2
#define ST_INSPECTION        3
#define ST_DEVICE            4
#define ST_TROUBLES          5
#define ST_MAINTENANCE       6
#define ST_MEASUREMENT       7
#define ST_OPERATION         8
#define ST_SIGNALTOWER       9
#define ST_MODE              10
#define ST_VERSION           11
#define ST_HELP              12
int CurrentST = ST_MAIN;
TPanel *LastPanel;
// 0x006A4E47, clBlack
void __fastcall TfrnMain::SetST(int no, bool mode)
{
TPanel *panel;

   // Main
   if(no == ST_MAIN)
      panel = pnlMain;
   // Level
   else if(no == ST_LEVEL)
      panel = pnlMainUser;
   // Recipe
   else if(no == ST_RECIPE)
      panel = pnlMainRecipe;
   // Inspection
   else if(no == ST_INSPECTION)
      panel = pnlMainInspection;
   // Device
   else if(no == ST_DEVICE)
      panel = pnlMainDevice;
   // Toubles shoothing and Error List
   else if(no == ST_TROUBLES)
      panel = pnlMainTroubles;
   // Maintenance
   else if(no == ST_MAINTENANCE)
      panel = pnlMainMaintenance;
   // Measurement
   else if(no == ST_MEASUREMENT)
      panel = pnlMainMeasurement;
   // Operation
   else if(no == ST_OPERATION)
      panel = pnlMainOperation;
   // Signal Tower
   else if(no == ST_SIGNALTOWER)
      panel = pnlMainSignal;
   // Mode
   else if(no == ST_MODE)
      panel = pnlMainMode;
   // Vesion
   else if(no == ST_VERSION)
      panel = pnlMainVersion;
   // Help
   else if(no == ST_HELP)
      panel = pnlMainHelp;

   // pnlMain
   if(mode == true) {
      panel->Color = clBlack;
      if(CurrentST == ST_MAIN)
         pnlMain->Color = (TColor)0x006A4E47;
      else
         LastPanel->Color = (TColor)0x006A4E47;
      CurrentST = no;
      LastPanel = panel;
   }
   else {
      panel->Color = (TColor)0x006A4E47;
      pnlMain->Color = clBlack;
      CurrentST = ST_MAIN;
      LastPanel = pnlMain;
   }
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::pnlMainDeviceClick(TObject *Sender)
{

   // Main
   SetST(ST_DEVICE,true);
   SetST(ST_DEVICE,false);
   pnlCurrentOperation->Caption = "Device Setting";
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::pnlMainTroublesClick(TObject *Sender)
{

   // Main
   SetST(ST_TROUBLES,true);
   pcMaintenance->ActivePage = tsErrorLog;
   SetST(ST_TROUBLES,false);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::pnlMainMaintenanceClick(TObject *Sender)
{

   // Main
   SetST(ST_MAINTENANCE,true);
   SetST(ST_MAINTENANCE,false);
   pnlCurrentOperation->Caption = "Maintenance";
   frmMaintenance->ShowModal();
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::pnlMainMeasurementClick(TObject *Sender)
{

   // Main
   SetST(ST_MEASUREMENT,true);
   SetST(ST_MEASUREMENT,false);
   pnlCurrentOperation->Caption = "Measurement";
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::pnlMainOperationClick(TObject *Sender)
{

   // Main
   SetST(ST_OPERATION,true);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::pnlMainSignalClick(TObject *Sender)
{

   // Main
   SetST(ST_SIGNALTOWER,true);

   // 2022 12 5 - chc 測試Signal Tower: R/Y/G/B/Buzzer
   //Application->MessageBox("塔燈測試一長一短, 請確認.    ","塔燈測試作業    ",MB_ICONINFORMATION|MB_OK);
   TestSignalTower();

   SetST(ST_SIGNALTOWER,false);

}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::pnlMainModeClick(TObject *Sender)
{

   // Main
   SetST(ST_MODE,true);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::pnlMainVersionClick(TObject *Sender)
{

   // Main
   SetST(ST_VERSION,true);
   pnlWidthValueClick(this);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::pnlMainHelpClick(TObject *Sender)
{

   // Main
   SetST(ST_HELP,true);
}
//---------------------------------------------------------------------------
// 2022 12 5 - chc 重Init
void __fastcall TfrnMain::pnlEFEMReadyClick(TObject *Sender)
{

   if(pnlEFEMReady->Color == clRed) {
      if(Application->MessageBox("執行EFEM重啟動?         ", "EFEM Init作業", MB_YESNO|MB_SYSTEMMODAL) == IDYES) {
         if(frnMain->SetupEFEM(1) == false) {
            frnMain->pnlEFEMReady->Color = clRed;
            frnMain->pcRobot->Enabled = false;
            frnMain->pnlSystemMessage->Caption = "EFEM異常! 無法作業.";
            frnMain->pnlAlarmMessage->Caption = "EFEM異常! 無法作業.";
         }
         else {
            frnMain->pnlEFEMReady->Color = clLime;
            frnMain->pcRobot->Enabled = true;
            frnMain->pnlSystemMessage->Caption = "EFEM正常! 系統Ready.";
         }
         frnMain->pcSystem->Enabled = true;
         frnMain->pnlEFEM->Enabled = true;
      }
   }
}
//---------------------------------------------------------------------------
// 2022 12 5 - chc Init BXFM
bool __fastcall TfrnMain::SetupBXFM()
{

   pnlStartMessage->Caption = "Init BXFM...";
   pnlMainOperation->Caption = pnlStartMessage->Caption;
   pnlStartMessage->Refresh();
   if(frmLogo->Visible == true)
      frmLogo->pnlMessage->Caption = pnlStartMessage->Caption;
   InitBXFMCom();

   // 2023 1 11 - chc Tazmo
   if(RobotMode == ROBOT_MODE_TAZMO)
      InitDICCom();

   pnlStartMessage->Caption = "Init A2M...";
   pnlStartMessage->Refresh();
   pnlMainOperation->Caption = pnlStartMessage->Caption;
   pnlMainOperation->Refresh();
   if(frmLogo->Visible == true)
      frmLogo->pnlMessage->Caption = pnlStartMessage->Caption;
   // BXFM Parameter
   ReadA2MParameter(1);                                                         // 要先讀取AF/Z Table值

   // 晚做
   //btnA2MORGClick(this);                                                        // 要先做ORG
   //Sleep(500);

   ReadDICParameter(1);                                                         // DIC
   Sleep(500);
   ReadBXFMParameter(1);                                                        // 會切換Lens: 改變AF/Z
   // Switch AF to OFF
   if(pnlA2MControl->Color == clLime) {
      rgA2MAFMode->ItemIndex = 2;
      WriteSystemLog("Set A2M AF to OFF...");
      btnA2MAFClick(this);
      WriteSystemLog("Set A2M AF to OFF.");
   }

   // Set AF Parameter
   pnlStartMessage->Caption = "Init AF...";
   pnlMainOperation->Caption = pnlStartMessage->Caption;
   pnlMainOperation->Refresh();
   Sleep(500);
   btnA2MZNearFarSetClick(this);
   Sleep(500);
   btnA2MAFNearFarSetClick(this);
   Sleep(500);
   btnA2MORGClick(this);
   int max,cnt;
   cnt = 0;
   max = 40;
   // 20sec
   while(1) {
      Sleep(500);
      Application->ProcessMessages();
      cnt++;
      if(cnt > max) {
         pnlStartMessage->Caption = "Init AF Fail!";
         pnlMainOperation->Caption = pnlStartMessage->Caption;
         pnlMainOperation->Refresh();
         break;
      }
      if(pnlA2MORG->Color == clLime) {
         pnlStartMessage->Caption = "Init AF Done.";
         pnlMainOperation->Caption = pnlStartMessage->Caption;
         pnlMainOperation->Refresh();
         break;
      }
   }
   return true;
}
//---------------------------------------------------------------------------
// 2022 12 6 - chc Main Log
// ErrorLog.txt
void __fastcall TfrnMain::AddMainLog(AnsiString msg, int ErrorCode, bool mode)
{
AnsiString temp,name;

   if(mode == true)
      name = "ERR";
   else
      name = "RST";
   DateTimeToString(temp,"yyyy'/'mm'/'dd hh':'nn':'ss",Now());
   msg.sprintf("%s> %s [%05d]  %s\n",temp.c_str(),name.c_str(),ErrorCode,msg.c_str());
   mmMainLog->Lines->Insert(0,msg);
   //mmMainLog->Lines->Append(msg);
   //if(mmMainLog->Lines->Count > 400) {
   //   for(int i=370 ; i<mmMainLog->Lines->Count ; i++)
   //      mmMainLog->Lines->Delete(i);
   //}
   frmSystemLog->mmMainLog->Lines->Insert(0,msg);

   if(ErrorCode != EFEM_RESTART && ErrorCode != EFEM_RESTART_OK) {
      mmError->Lines->Insert(0,msg);
      if(mmError->Lines->Count > 5) {
         for(int i=5 ; i<mmError->Lines->Count ; i++)
            mmError->Lines->Delete(i);
      }
      frmRecipe->mmError->Lines->Insert(0,msg);
      if(frmRecipe->mmError->Lines->Count > 5) {
         for(int i=5 ; i<frmRecipe->mmError->Lines->Count ; i++)
            frmRecipe->mmError->Lines->Delete(i);
      }
   }

   FILE *logFile;
   logFile = fopen(MainLogFileName.c_str(),"a+t");
   fprintf(logFile,msg.c_str());
   fclose(logFile);
}
//---------------------------------------------------------------------------
int ImageXPos,ImageYPos;
bool ImageLeftMouse = false;

void __fastcall TfrnMain::imOperationMouseMove(TObject *Sender,
      TShiftState Shift, int X, int Y)
{
int gray,sx,sy;

   // 主畫面
   unsigned char r,g,b;
   TColor color;
   sx = 0;
   sy = 0;
   color = imOperation->Canvas->Pixels[X][Y];
   b = (color & 0xff0000) >> 16;
   g = (color & 0x00ff00) >> 8;
   r = color & 0x0000ff;
   // 顯示游標值
   pnlCCDR->Caption = r;
   pnlCCDG->Caption = g;
   pnlCCDB->Caption = b;
   pnlCCDX->Caption = X + sx;
   pnlCCDY->Caption = Y + sy;
   AnsiString str;
   str.sprintf("XY:(%d,%d)",X,Y);
   sbSystem->Panels->Items[3]->Text = str;

   str.sprintf("RGB:(%3d,%3d,%3d)",r,g,b);
   // Gray Value
   //str.sprintf("G:(%3d)",g);

   sbSystem->Panels->Items[4]->Text = str;

   // Move
   if(ImageLeftMouse == true) {
      int dx,dy,sx,sy;
      int width,height,w,h,no,w1,h1;
      w1 = imOperation->Width;
      h1 = imOperation->Height;
      dx = X - ImageXPos;
      dy = Y - ImageYPos;
      width = GigaWidth;
      height = GigaHeight;
      w = width / ImageFactor;
      h = height / ImageFactor;
      dx = (dx * width) / (w1 * ImageFactor);
      dy = (dy * height) / (h1 * ImageFactor);
      sx = ImageSX - dx;
      sy = ImageSY - dy;
      if(sx > 0) {
         ImageSX = sx;
      }
      else
         ImageSX = 0;
      if(sy > 0) {
         ImageSY = sy;
      }
      else
         ImageSY = 0;
      if((ImageSX + w) > width)
         ImageSX = width - w;
      if((ImageSY + h) > height)
         ImageSY = height - h;

      no = 0;
      imOperation->Picture->Bitmap->Width = w;
      imOperation->Picture->Bitmap->Height = h;
      usb_ImageROIAry[no].SetPlacement(ImageSX,ImageSY,w,h);
      usb_ImageROIAry[no].Draw(imOperation->Canvas->Handle);
      imOperation->Refresh();
   }
   ImageXPos = X;
   ImageYPos = Y;

   // Measure
   /*
   if(MeasureState == 1 && cbMeasure->Checked == true) {
      Mx2 = X;
      My2 = Y;
      int w,h,l,t;
      if(Mx1 < Mx2)
         l = Mx1;
      else
         l = Mx2;
      if(My1 < My2)
         t = My1;
      else
         t = My2;
      w = abs(Mx2 - Mx1);
      h = abs(My2 - My1);
      shMeasure->Left = l + imCCD->Left;
      shMeasure->Top = t + imCCD->Top;
      shMeasure->Width = w;
      shMeasure->Height = h;

      // Realtime display
      double wvalue,hvalue,lvalue,dx;
      AnsiString msg;
      dx = GetLensPrecision();
      // Width
      wvalue = (abs(Mx2 - Mx1)+1) * dx;
      // Height
      hvalue = (abs(My2 - My1)+1) * dx;

      // Length
      lvalue = sqrt(wvalue*wvalue + hvalue*hvalue);
      if(pnlUnit->Caption == "um")
         msg.sprintf("(um)W:%.2f  H:%.2f  L:%.2f  A:%.2f  a:%.2f",wvalue,hvalue,lvalue,wvalue*hvalue,((wvalue*hvalue)/4)*M_PI);
      else {
         wvalue /= MM_TO_UM;
         hvalue /= MM_TO_UM;
         lvalue /= MM_TO_UM;
         msg.sprintf("(mm)W:%.3f  H:%.3f  L:%.3f  A:%.4f  a:%.4f",wvalue,hvalue,lvalue,wvalue*hvalue,((wvalue*hvalue)/4)*M_PI);
      }
      pnlMeasureResult->Caption = msg;
      shEllipse->Left = shMeasure->Left;
      shEllipse->Top = shMeasure->Top;
      shEllipse->Width = shMeasure->Width;
      shEllipse->Height = shMeasure->Height;
      shEllipse->Visible = true;
   }
   */
}
//---------------------------------------------------------------------------
// ImageSX,ImageSY,ImageFactor
// usb_ImageROIAry[no].SetPlacement(ImageSX,ImageSY,width,height);
// usb_ImageROIAry[no].Draw(imCCD->Canvas->Handle);

void __fastcall TfrnMain::imAddClick(TObject *Sender)
{
int width,height,w,h,no;

   no = 0;
   width = GigaWidth;
   height = GigaHeight;
   ImageFactor++;
   if(ImageFactor > 16) {
      ImageFactor = 16;
      return;
   }
   pnlMainFactor->Caption = IntToStr(ImageFactor) + "x";
   w = width / ImageFactor;
   h = height / ImageFactor;
   imOperation->Picture->Bitmap->Width = w;
   imOperation->Picture->Bitmap->Height = h;

   double fdw,fdh;
   // Button: 中心點
   if(boolFormWheel == false) {
      fdw = double(width)/(ImageFactor-1) - w;
      fdw /= 2;
      fdh = double(height)/(ImageFactor-1) - h;
      fdh /= 2;
      ImageSX += fdw;
      ImageSY += fdh;
   }
   // Wheel: 指定點 : ImageXPos, ImageYPos
   else {
      fdw = double(width)/(ImageFactor-1) - w;
      fdw /= 2;
      fdh = double(height)/(ImageFactor-1) - h;
      fdh /= 2;
      fdw *= ((double)ImageXPos / ((double)imOperation->Width/2));
      fdh *= ((double)ImageYPos / ((double)imOperation->Height/2));
      ImageSX += fdw;
      ImageSY += fdh;
   }
   if((ImageSX + w) > width)
      ImageSX = width - w;
   if((ImageSY + h) > height)
      ImageSY = height - h;
   usb_ImageROIAry[no].SetPlacement(ImageSX,ImageSY,w,h);
   usb_ImageROIAry[no].Draw(imOperation->Canvas->Handle);

   int X,Y,ox,oy,nx,ny,ow,dw;
   if(boolFormWheel == true) {
      X = ImageXPos;
      Y = ImageYPos;
   }
   else {
      X = imOperation->Width / 2;
      Y = imOperation->Height / 2;
   }

}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::imDecClick(TObject *Sender)
{
int width,height,w,h,no;

   no = 0;
   width = GigaWidth;
   height = GigaHeight;
   if(ImageFactor >= 2) {
      ImageFactor--;
      pnlMainFactor->Caption = IntToStr(ImageFactor) + "x";
      w = width / ImageFactor;
      h = height / ImageFactor;
      imOperation->Picture->Bitmap->Width = w;
      imOperation->Picture->Bitmap->Height = h;

      double fdw,fdh;
      fdw = w - double(width)/(ImageFactor+1);
      fdw /= 2;
      fdh = h - double(height)/(ImageFactor+1);
      fdh /= 2;
      fdw *= ((double)ImageXPos / ((double)imOperation->Width/2));
      fdh *= ((double)ImageYPos / ((double)imOperation->Height/2));
      ImageSX -= fdw;
      ImageSY -= fdh;
      if(ImageSX < 0)
         ImageSX = 0;
      if(ImageSY < 0)
         ImageSY = 0;

      if((ImageSX + w) > width)
         ImageSX = width - w;
      if((ImageSY + h) > height)
         ImageSY = height - h;

      usb_ImageROIAry[no].SetPlacement(ImageSX,ImageSY,w,h);
      usb_ImageROIAry[no].Draw(imOperation->Canvas->Handle);
   }
}
//---------------------------------------------------------------------------
// 2022 12 7 - chc Mouse Position
void __fastcall TfrnMain::FormMouseMove(TObject *Sender, TShiftState Shift,
      int X, int Y)
{

   MousePosX = X;
   MousePosX = Y;
}
//---------------------------------------------------------------------------
// EMO / Power : boolInEMO
void __fastcall TfrnMain::CloseAllWindow()
{

   if(frmRecipe->Visible == true) {
      frmRecipe->Close();
   }
   if(frmInspection->Visible == true) {
      frmInspection->Close();
   }
   if(frmLogo->Visible == false) {
      frmLogo->Visible = true;
      frmLogo->pnlHome3->Font->Color = clSilver;
   }
   frmLogo->pnlHome3->Caption = "RESET";
   frmLogo->pnlMacroUnit->Caption = "";
   frmLogo->pnlMicroUnit->Caption = "";
   frmLogo->pnlWaferUnit->Caption = "";

}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::pnlCurrentOperationClick(TObject *Sender)
{

   pnlWidthValueClick(this);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnSVONAllClick(TObject *Sender)
{

   AxisSVON();
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::pcMainChange(TObject *Sender)
{
int no;

   no = 1;
}
//---------------------------------------------------------------------------
void __fastcall TfrnMain::imOperationMouseDown(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   ImageXPos = X;
   ImageYPos = Y;
   if(Button == mbLeft) {
      ImageLeftMouse = true;
   }
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::imOperationMouseUp(TObject *Sender,
      TMouseButton Button, TShiftState Shift, int X, int Y)
{

   //if(Button == mbLeft) {
      ImageLeftMouse = false;
   //}
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::pnlXClick(TObject *Sender)
{

   if(frmLogo->Visible == false)
      frmLogo->Visible = true;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::pnlYClick(TObject *Sender)
{

   if(pnlEFEM2->Visible == false)
      pnlEFEM2->Visible = true;
   else
      pnlEFEM2->Visible = false;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::combAligner2ComportChange(TObject *Sender)
{

   InitAligner2Com();
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::combAligner2BaudrateChange(TObject *Sender)
{

   InitAligner2Com();
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnAligner2ConnectClick(TObject *Sender)
{

   try {
      ybAligner2->SettingsDialog(this,true);
      if(boolAligner2Status == false)
         ybAligner2->Active = true;
      boolAligner2Status = true;
      Aligner2Button();
   }
   catch(Exception &e) {
      ShowMessage("ybAligner2: " + e.Message);
      boolAligner2Status = false;
      Aligner2Button();
      pnlSystemMessage->Caption = "COM Port(Aligner2) 啟動失敗!";
      WriteSystemLog(pnlSystemMessage->Caption);
   }
   UpdateAligner2Status();
}
//---------------------------------------------------------------------------
// 2022 12 19 - chc Tazmo
AnsiString Aligner2CommandCode = "";
bool boolAligner2Ack = false;
bool boolAligner2Complete = false;
bool boolAligner2Nak = false;

void __fastcall TfrnMain::btnAligner2CMDClick(TObject *Sender)
{
unsigned char command[50],buf[50];
AnsiString msg;
int len,cs1,cs2;
unsigned char checksum;

   if(boolAligner2Status == false) {
      pnlAligner2Message->Caption = "未連線!";
      return;
   }

   // 2022 12 19 - chc Tazmo
   if(RobotMode != ROBOT_MODE_TAZMO) {
      // Aligner
      sprintf(command,"0000%s",edAligner2Cmd->Text);

      len = strlen(command);
      checksum = 0;
      for(int i=0 ; i<len ; i++) {
         checksum += command[i];
      }

      int c1,c2;
      c1 = checksum & 0xf0;
      c1 = c1 >> 4;
      c2 = checksum & 0x0f;
      if(c1 < 10)
         c1 = c1 + '0';
      else
         c1 = c1 - 10 + 'A';
      if(c2 < 10)
         c2 = c2 + '0';
      else
         c2 = c2 - 10 + 'A';
      sprintf(buf,"%c%s%c%c%c",0x01,command,c1,c2,0x0d);

      len = strlen(buf);
      buf[len] = 0x0;

      // 改慢速送
      //ybAligner->Write(buf,len);
      for(int i=0 ; i<len ; i++) {
         ybAligner2->Write(&buf[i],1);
         Sleep(20);
      }
   }
   else {

      boolAligner2Ack = false;
      boolAligner2Complete = false;
      boolAligner2Nak = false;
      sprintf(command,"%s",edAligner2Cmd->Text);
      sprintf(buf,"%s%c",command,0x0d);
      len = strlen(buf);
      Aligner2CommandCode = "";
      if(edAligner2Cmd->Text.Length() >= 3)
         Aligner2CommandCode = edAligner2Cmd->Text.SubString(1,3);
      WriteSystemLog("btnAligner2CMDClick: run...");
      ybAligner2->Write(buf,len);
   }

   pnlAligner2Operation->Caption = "Busy";
   pnlAligner2->Enabled = false;
   btnAligner2Enable->Visible = true;

   msg.sprintf("CMD: %s",command);
   pnlSystemMessage->Caption = msg;
   WriteSystemLog(msg);

   // 2020 5 6 - chc 不能有Sleep, 會卡住!
   //Sleep(100);

   AddAligner2SendMessage(edAligner2Cmd->Text);
   pnlAligner2Message->Caption = msg;

}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnAligner2ORGNClick(TObject *Sender)
{

   // 2022 12 19 - chc Tazmo
   if(RobotMode == ROBOT_MODE_TAZMO) {
bool ret;

   pnlAligner2ORGN->Color = clSilver;
      edAligner2Cmd->Text = "HOM";
      // 要Refresh
      edAligner2Cmd->Refresh();
      btnAligner2CMDClick(this);
      ret = WaitTMAligner2Done(30000);
      if(ret == true)
         pnlAligner2ORGN->Color = clLime;
      else
         pnlAligner2ORGN->Color = clRed;

      WaitTime(1000);

      pnlAligner2ORGN->Color = clSilver;
      edAligner2Cmd->Text = "PRP,A";
      // 要Refresh
      edAligner2Cmd->Refresh();
      btnAligner2CMDClick(this);

      ret = WaitTMAligner2Done(30000);
      if(ret == true) {
         pnlAligner2ORGN->Color = clLime;
         boolAlignerORGN = true;
      }
      else
         pnlAligner2ORGN->Color = clRed;
      return;
   }

   pnlAligner2ORGN->Color = clSilver;
   edAligner2Cmd->Text = "MOV:ORGN;";
   WriteSystemLog("執行Aligner2 ORGN...");
   btnAligner2CMDClick(this);

   // 2022 8 11 - chc Check Timeout : 等ORGN完成, 送出STAS
   // 2022 8 16 - chc 因在Wait中, 其它Process無法插入! 改交由Timer來做 : iAlignerORGNDone
   /*
   int cnt = 0;
   // 5sec
   int max = 100;
   while(1) {
      if(pnlAligner2ORGN->Color == clRed)
         break;
      // 發出STAS
      if(pnlAligner2ORGN->Color == clLime) {
         WriteSystemLog("btnAligner2ORGNClick: 完成ORGN, 發出GET:STAS;");
         btnAligner2StasClick(this);
         break;
      }
      Sleep(50);
      Application->ProcessMessages();
      cnt++;
      if(cnt > max) {
         WriteSystemLog("btnAligner2ORGNClick: 等完成ORGN(5sec) Timeout!");
         break;
      }
      WriteSystemLog("Wait...");
   }
   WriteSystemLog("執行Aligner2 ORGN.");
   */
   WriteSystemLog("確認Aligner ORGN是否完成, 改由Timer處理.");
   iAligner2ORGNDone = 0;
   tmAligner2ORGNDone->Enabled = true;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnAligner2VacuumOffClick(TObject *Sender)
{

   pnlAligner2VacuumOff->Color = clSilver;
   edAligner2Cmd->Text = "MOV:ACOP;";
   btnAligner2CMDClick(this);
}
//---------------------------------------------------------------------------
int Aligner2OFSEState = 0;

void __fastcall TfrnMain::btnAligner2AlignmentClick(TObject *Sender)
{

   // 2022 12 19 - chc Tazmo
   if(RobotMode == ROBOT_MODE_TAZMO) {
bool ret;

      pnlAligner2Alignment->Color = clSilver;
      int degree = edAligner2Degree->Text.ToInt();
      degree /= 450;
      degree++;
      if(degree > 8)
         degree = 8;
      edAligner2Cmd->Text = "ALG," + IntToStr(degree);
      // 要Refresh
      edAligner2Cmd->Refresh();
      btnAligner2CMDClick(this);
      ret = WaitTMAligner2Done(30000);
      if(ret == true)
         pnlAligner2Alignment->Color = clLime;
      else
         pnlAligner2Alignment->Color = clRed;
      return;
   }

   // 選擇角度: AlignmentDegreeMode
   int degree;
   if(AlignmentDegreeMode == ALIGNMENT_DEGREE_UNLOAD) {
      // 備份角度值
      degree = edAligner2Degree->Text.ToInt();
      edAligner2Degree->Text = edAligner2DegreeOut->Text;
   }

   // 先做角度設定
   rgAligner2Set->ItemIndex = 1;
   Aligner2OFSEState = 0;
   btnAligner2SetClick(this);

   // 還原角度值
   if(AlignmentDegreeMode == ALIGNMENT_DEGREE_UNLOAD) {
      edAligner2Degree->Text = IntToStr(degree);
   }

   int cnt = 0;
   int max = 20;
   while(1) {
      if(Aligner2OFSEState == 1) {
         break;
      }
      else if(Aligner2OFSEState == 2) {
         pnlAligner2Alignment->Color = clRed;
         pnlAligner2Message->Caption = "角度設定失敗!";
         return;
      }
      cnt++;
      if(cnt > max) {
         pnlAligner2Message->Caption = "角度設定Timeout!";
         return;
      }
      WaitTime(100);
   }

   pnlAligner2Alignment->Color = clSilver;
   edAligner2Cmd->Text = "MOV:ARLD;";
   btnAligner2CMDClick(this);

}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnAligner2StasClick(TObject *Sender)
{

   // 2022 12 19 - chc Tazmo
   if(RobotMode == ROBOT_MODE_TAZMO) {
      edAligner2Cmd->Text = "STS";
      // 要Refresh
      edAligner2Cmd->Refresh();
      btnAligner2CMDClick(this);
      return;
   }

   edAligner2Cmd->Text = "GET:STAS;";

   // 2020 7 17 - chc 是ORGN, 加做STAT
   //WriteSystemLog("Aligner2: 是ORGN, 送出GET:STAS...");

   btnAligner2CMDClick(this);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnAligner2WithWaferClick(TObject *Sender)
{
int ret;

   // 2022 12 19 - chc Tazmo
   if(RobotMode == ROBOT_MODE_TAZMO) {
      pnlAligner2WithWafer->Color = clSilver;
      edAligner2Cmd->Text = "WCH";
      // 要Refresh
      edAligner2Cmd->Refresh();
      btnAligner2CMDClick(this);
      ret = WaitTMAligner2Done(30000);
      if(ret == false) {
         pnlAligner2WithWafer->Color = clRed;
         return;
      }
      WaitTime(1000);

      /*
      edAligner2Cmd->Text = "PRP,A";
      // 要Refresh
      edAligner2Cmd->Refresh();
      btnAligner2CMDClick(this);
      ret = WaitTMAligner2Done(30000);
      if(ret == false) {
         pnlAligner2WithWafer->Color = clRed;
      }
      */

      return;
   }

   edAligner2Cmd->Text = "GET:STAS;";
   btnAligner2CMDClick(this);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnAligner2SetClick(TObject *Sender)
{
char command[100];

   // RSET: Error reset
   if(rgAligner2Set->ItemIndex == 0)
      sprintf(command,"SET:RSET;");
   // OFSE: 1/10度, 0000~3600
   else if(rgAligner2Set->ItemIndex == 1)
      sprintf(command,"SET:OFSE%04d;",edAligner2Degree->Text.ToInt());
   // OFS2: 1/10度, 0000~3600
   else if(rgAlignerSet->ItemIndex == 2)
      sprintf(command,"SET:OFS2%04d;",edAligner2Degree->Text.ToInt());
   // SPED: 0000~0100(100%)
   else if(rgAlignerSet->ItemIndex == 3)
      sprintf(command,"SET:SPED%04d;",edAligner2Speed->Text.ToInt());
   // TYPE: 00~06
   //   00 （06-orientation flat * standard setting)
   //   01 (08-orientation flat * standard setting)
   //   02 (* For enhancement)
   //   03（06-notch * standard setting)
   //   04 (08-notch * standard setting)
   //   05 (12-notch * standard setting)
   //   06 (18-notch * stnadrad setting)
   else if(rgAligner2Set->ItemIndex == 4)
      sprintf(command,"SET:TYPE%02d;",edAligner2Type->Text.ToInt());

   edAligner2Cmd->Text = command;
   btnAligner2CMDClick(this);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnAligner2GetClick(TObject *Sender)
{
char command[100];

   // STAS
   if(rgAligner2Set->ItemIndex == 0)
      sprintf(command,"GET:STAS;");
   // OFSE
   else if(rgAligner2Set->ItemIndex == 1)
      sprintf(command,"GET:OFSE;");
   // OFS2
   else if(rgAligner2Set->ItemIndex == 2)
      sprintf(command,"GET:OFS2;");
   // SPED
   else if(rgAligner2Set->ItemIndex == 3)
      sprintf(command,"GET:SPED;");
   // TYPE
   else if(rgAligner2Set->ItemIndex == 4)
      sprintf(command,"GET:TYPE;");

   edAligner2Cmd->Text = command;
   btnAligner2CMDClick(this);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnAligner2ResetClick(TObject *Sender)
{

   // 2022 12 19 - chc Tazmo
   if(RobotMode == ROBOT_MODE_TAZMO) {
bool ret;

      pnlAligner2Reset->Color = clSilver;
      pnlAligner2ORGN->Color = clSilver;
      edAligner2Cmd->Text = "RST";
      // 要Refresh
      edAligner2Cmd->Refresh();
      btnAligner2CMDClick(this);
      ret = WaitTMAligner2Done(60000);
      if(ret == true) {
         pnlAligner2Reset->Color = clLime;
         pnlAligner2ORGN->Color = clLime;
      }
      else {
         pnlAligner2Reset->Color = clRed;
         pnlAligner2ORGN->Color = clRed;
      }
      return;
   }

   pnlAligner2Reset->Color = clSilver;
   edAligner2Cmd->Text = "SET:RSET;";
   btnAligner2CMDClick(this);

   // TSMC修改: 不關紅燈
   //RedLamp(false);
   boolEFEMError = false;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnAligner2SaveClick(TObject *Sender)
{
TIniFile *pSystemFile;
AnsiString str;

   pnlSystemMessage->Caption = "Aligner2參數更新中...";
   pnlAligner2Message->Caption = pnlSystemMessage->Caption;
   // ini檔名與目錄
   pSystemFile = new TIniFile(SystemINIFilename);

   // Aligner-2
   Aligner2Degree = edAligner2Degree->Text.ToInt();
   pSystemFile->WriteInteger("Aligner Parameter2" ,"Degree"                      ,Aligner2Degree);
   Aligner2Speed = edAligner2Speed->Text.ToInt();
   pSystemFile->WriteInteger("Aligner Parameter2" ,"Speed"                       ,Aligner2Speed);
   Aligner2Type = edAligner2Type->Text.ToInt();
   pSystemFile->WriteInteger("Aligner Parameter2" ,"Type"                        ,Aligner2Type);

   // AlignerOut
   Aligner2DegreeOut = edAligner2DegreeOut->Text.ToInt();
   pSystemFile->WriteInteger("Aligner Parameter2" ,"Degree Out"                  ,Aligner2DegreeOut);

   delete pSystemFile;
   pnlSystemMessage->Caption = "Aligner2參數更新完成.";
   pnlAligner2Message->Caption = pnlSystemMessage->Caption;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnAligner2EnableClick(TObject *Sender)
{

   pnlAligner2->Enabled = true;
   btnAligner2Enable->Visible = false;
}
//---------------------------------------------------------------------------
// 2022 12 19 - chc Init Aligner ComPort
// COM5
void __fastcall TfrnMain::InitAligner2Com()
{

   // 由參數決定COM Port
   pnlSystemMessage->Caption = "啟動Aligner2 Com Port...";
   try {
      pnlAligner2Status->Color = clSilver;
      ybAligner2->Active = false;
      Sleep(200);
      /*
      if(combAligner2Baudrate->Text == "115200")
         ybAligner2->Baud = ybAligner->br115200;
      else if(combAligner2Baudrate->Text == "57600")
         ybAligner2->Baud = ybAligner->br57600;
      else if(combAligner2Baudrate->Text == "38400")
         ybAligner2->Baud = ybAligner->br38400;
      else if(combAligner2Baudrate->Text == "19200")
         ybAligner2->Baud = ybAligner->br19200;
      else if(combAligner2Baudrate->Text == "9600")
         ybAligner2->Baud = ybAligner->br9600;
      */
      // 由參數決定COM Port
      ybAligner2->PortNo = combAligner2Comport->ItemIndex+1;

      // Parity, DataBit, StopBit
      //ybAligner2->Parity = ybAligner2->ptNoParity;
      //ybAligner2->ByteSize = 8;
      //ybAligner2->StopBits = ybAligner2->sbOneStopBit;

      // Parity
      //if(cbNoParity->Checked == true)
      //   ybAligner2->Parity = ybAligner2->ptNoParity;
      //else
      //   ybAligner2->Parity = ybAligner2->ptEvenParity;

      // Tazmo
      if(RobotMode == ROBOT_MODE_TAZMO) {
         ybAligner2->Baud = ybRobot->br9600;
      }
      else {
         ybAligner2->Baud = ybRobot->br19200;
         combAligner2Baudrate->Text == "19200";
      }

      ybAligner2->Active = true;
      pnlAligner2Status->Color = clLime;
      boolAligner2Status = true;
      Aligner2Button();
   }
   catch(Exception &e) {
      pnlSystemMessage->Caption = "ybAligner2: " + e.Message;
      sbSystem->Panels->Items[1]->Text = "ybAligner2: " + e.Message;
      pnlAligner2Status->Color = clRed;
      boolAligner2Status = false;
      Aligner2Button();
   }
   UpdateAligner2Status();
   pnlSystemMessage->Caption = "啟動Aligner2 Com Port.";

}
//---------------------------------------------------------------------------
AnsiString ReplyStrAligner2 = "";
//unsigned char AlignerStatus[15];
//int LoadUnloadState;
// 0-None, 1-OK, 2-NG
bool boolAligner2ORGN = false;

void __fastcall TfrnMain::ybAligner2CommNotify(TObject *Sender,
      int NotifyType)
{
char Buf[8192+1];
AnsiString msg,msg1,lcode;
int len,pos,n;
bool boolstas = false;
bool boolclearerrorcode = false;

   // 先不管
   //if(NotifyType == EV_RXCHAR) {

      n = ybAligner2->Read(Buf,8192);
      if(n > 0) {
         Buf[n] = 0;
         for(int i=0 ; i<n ; i++) {
            // 0x03
            if(Buf[i] == ACK || Buf[i] == NAK || Buf[i] == BUSY || Buf[i] == CR) {
               // Display
               if(Buf[i] == ACK)
                  lcode = "[Ack]";
               else if(Buf[i] == NAK)
                  lcode = "[Nak]";
               else if(Buf[i] == BUSY)
                  lcode = "[Busy]";
               else if(Buf[i] == CR)
                  lcode = ReplyStrAligner2 + "[Cr]";
               AddAligner2RecvMessage(lcode);
               WriteSystemLog("Aligner2 Recv= " + lcode);

               if(Buf[i] == ACK) {
                  boolAligner2Ack = true;
                  WriteSystemLog("Aligner2Cmd-1 = [Ack]");
               }
               else if(Buf[i] == NAK) {
                  boolAligner2Nak = true;
                  WriteSystemLog("Aligner2Cmd-1 = [Nak]");
               }
               else if(Buf[i] == BUSY) {
                  WriteSystemLog("Aligner2Cmd-1 = [Busy]");
               }
               else if(Buf[i] == CR) {
                  WriteSystemLog("Aligner2Cmd-1 = [Cr]");
                  if(ReplyStrAligner2.SubString(1,3) == "ERR") {
                     boolAligner2Nak = true;
                     WriteSystemLog("Aligner2Cmd-1 = [Err]");
                  }
                  else if(ReplyStrAligner2.SubString(1,3) == Aligner2CommandCode) {
                     tmAligner2Ack->Enabled = true;
                     boolAligner2Complete = true;
                     pnlAligner2Operation->Caption = "Ready";
                     pnlAligner2->Enabled = true;
                     if(ReplyStrAligner2.SubString(1,3) == "STS") {
                        // STS,100[Cr]
                        // 123456789
                        pnlAlinger2Status->Caption = ReplyStrAligner2.SubString(5,3);;
                        //if(pnlAlinger2Status->Caption == "100")
                        //   pnlAligner2WithWafer->Color = clSilver;
                        //else if(pnlAlinger2Status->Caption == "101")
                        //   pnlAligner2WithWafer->Color = clLime;
                     }
                     else if(ReplyStrAligner2.SubString(1,3) == "RST") {
                        boolAligner2PRP = false;
                     }
                     else if(ReplyStrAligner2.SubString(1,3) == "HOM") {
                        boolAligner2PRP = false;
                     }
                     else if(ReplyStrAligner2.SubString(1,3) == "PRP") {
                        boolAligner2PRP = true;
                     }
                     else if(ReplyStrAligner2.SubString(1,3) == "WCH") {
                        boolAligner2PRP = false;
                        if(ReplyStrAligner2.SubString(5,1) == "1")
                           pnlAligner2WithWafer->Color = clLime;
                        else if(ReplyStrAligner2.SubString(5,1) == "0")
                           pnlAligner2WithWafer->Color = clSilver;
                        else
                           pnlAligner2WithWafer->Color = clRed;
                     }
                  }
               }

               // Clear
               ReplyStrAligner2 = "";
               // Ignore LRC
               i++;
            }
            else {
               ReplyStrAligner2 += Buf[i];
            }
         }
      }

   // 先不管
   //}

   if(pnlAligner2->Enabled == true) {
      btnAligner2Enable->Visible = false;
   }


/*
   // 先不管
   //if(NotifyType == EV_RXCHAR) {

      n = ybAligner2->Read(Buf,8192);
      if(n > 0) {
         Buf[n] = 0;

         // 2022 7 13 - chc 即時顯示
         // => 取消: 是USB轉RS232才可以, 否則有亂碼
         //msg.sprintf("[org]%s",Buf);
         //AddAlignerRecvMessage(msg);
         //WriteSystemLog(msg);
         //msg = "[X]";
         //for(int i=0 ; i<n ; i++) {
         //   msg1.sprintf("%2X ",Buf[i]);
         //   msg = msg + msg1;
         //}
         //WriteSystemLog(msg);

         for(int i=0 ; i<n ; i++) {
            if(Buf[i] == 0x0d) {
               // Display
               AddAligner2RecvMessage(ReplyStrAligner2);
               // Recv: 0000INF:FPML;41* (INF = 完成)
               if(ReplyStrAligner2.Pos("INF") > 0) {
                  pnlAligner2Operation->Caption = "Ready";
                  pnlAligner2->Enabled = true;
                  boolclearerrorcode = true;
                  // ORGN加做STAS
                  if(ReplyStrAligner2.Pos("ORGN") > 0) {
                     boolstas = true;
                     boolAligner2ORGN = true;
                     pnlAligner2ORGN->Color = clLime;

                     // 2022 8 23 - chc Log
                     WriteSystemLog("Aligner2: 收到ORGN.");

                     // 2020 7 17 - chc 是ORGN, 加做STAT
                     // 2022 8 11 - chc 不做
                     //WriteSystemLog("Aligner: 是ORGN, 加做STAS...");

                  }
                  if(ReplyStrAligner2.Pos("ARLD") > 0) {
                     pnlAligner2Alignment->Color = clLime;
                  }
                  if(ReplyStrAligner2.Pos("ACOP") > 0) {
                     pnlAligner2VacuumOff->Color = clLime;
                  }
                  if(ReplyStrAligner2.Pos("RSET") > 0) {
                     pnlAligner2Reset->Color = clSilver;
                  }

                  // 2020 5 4 - chc 角度設定是否正確?
                  if(ReplyStrAligner2.Pos("OFSE") > 0) {
                     Aligner2OFSEState = 1;
                  }

               }
               // 0000ABS:FPML/16;D0* (ABS=有error, 16=error code)
               // 12345678901234567890
               else if(ReplyStrAligner2.Pos("ABS") > 0) {
                  pos = ReplyStrAligner2.Pos("ABS");
                  pnlAligner2Operation->Caption = "Error";
                  pnlAligner2ErrorCode->Caption = ReplyStrAligner2.SubString(pos+9,2);
                  pnlAligner2ErrorCode1->Caption = ReplyStrAligner2.SubString(pos+9,2);

                  // 2020 5 14 - chc Error Code
                  PutAligner2CodeMsg();

                  pnlAligner2->Enabled = true;
                  if(ReplyStrAligner2.Pos("ORGN") > 0) {
                     pnlAligner2ORGN->Color = clRed;
                  }
                  if(ReplyStrAligner2.Pos("ARLD") > 0) {
                     pnlAligner2Alignment->Color = clRed;
                  }
                  if(ReplyStrAligner2.Pos("ACOP") > 0) {
                     pnlAligner2VacuumOff->Color = clRed;
                  }

                  // 2020 5 4 - chc 角度設定是否正確?
                  if(ReplyStrAligner2.Pos("OFSE") > 0) {
                     Aligner2OFSEState = 2;
                  }

               }
               else if(ReplyStrAligner2.Pos("GET:STAS") > 0) {
                  pos = ReplyStrAligner2.Pos("STAS/");
                  pnlAligner2Operation->Caption = "Ready";
                  pnlAligner2->Enabled = true;
                  sprintf(Aligner2Status,"%s",ReplyStrAligner2.SubString(pos+5,15).c_str());
                  UpdateAligner2Status_1();
               }
               // 取回設定值: Offset/Speed/Type
               else if(ReplyStrAligner2.Pos("GET:") > 0 && ReplyStrAligner2.Pos("/") > 0) {
                  pos = ReplyStrAligner2.Pos("/");
                  int pos1 = ReplyStrAligner2.Pos(";");
                  int len = pos1 - pos - 1;
                  pnlAligner2Operation->Caption = "Ready";
                  pnlAligner2->Enabled = true;
                  AnsiString recv;
                  // 0000GET:OFSE/1800;A1
                  // 0000GET:SPED/100;01
                  // 0000GET:TYPE/5;B8
                  //             123456
                  if(ReplyStrAligner2.Pos("OFSE") > 0) {
                     recv = ReplyStrAligner2.SubString(pos+1,len);
                     edAligner2Degree->Text = recv;
                  }
                  else if(ReplyStrAligner2.Pos("OFS2") > 0) {
                     recv = ReplyStrAligner2.SubString(pos+1,len);
                     edAligner2Degree->Text = recv;
                  }
                  else if(ReplyStrAligner2.Pos("SPED") > 0) {
                     recv = ReplyStrAligner2.SubString(pos+1,len);
                     edAligner2Speed->Text = recv;
                  }
                  else if(ReplyStrAligner2.Pos("TYPE") > 0) {
                     recv = ReplyStrAligner2.SubString(pos+1,len);
                     edAligner2Type->Text = recv;
                  }
               }

               // 2020 5 20 - chc Clear Error Code & Msg
               if(boolclearerrorcode == true) {
                  // Error code
                  pnlAligner2ErrorCode->Caption = "";
                  pnlAligner2ErrorCode1->Caption = "";
                  pnlAligner2ErrorMsg->Caption = "";
               }

               // Clear
               ReplyStrAligner2 = "";
            }
            else {
               if(Buf[i] == 0x01)
                  ReplyStrAligner2 += "<";
               else
                  ReplyStrAligner2 += Buf[i];
            }
         }
      }

   // 先不管
   //}

   if(pnlAligner2->Enabled == true) {
      btnAligner2Enable->Visible = false;
      if(boolstas == true) {

         // 2020 7 17 - chc 是ORGN, 改由Timer加做STAT
         // 2022 8 11 - chc 不做
         //WriteSystemLog("Aligner2: 是ORGN, 執行GetStas...");
         //btnAligner2StasClick(this);

      }
   }
*/
}
//---------------------------------------------------------------------------
//unsigned char AlignerStatus[15];
// A B C D EE FFF G H I JJJ
// 0 1 2 3 45 678 9 0 1 234
// 0 1 2 3 4  5   6 7 8 9
void __fastcall TfrnMain::UpdateAligner2Status_1()
{
TPanel *panel;
AnsiString msg;

   for(int i=0 ; i<10 ; i++) {
      // pnlAlignerS1
      panel = (TPanel*)(FindComponent("pnlAligner2S" + IntToStr(i+1)));
      switch(i) {
         case 0:
         case 1:
         case 2:
         case 3:
            msg.sprintf("%c",Aligner2Status[i]);
            panel->Caption = msg;
            break;
         case 4:
            msg.sprintf("%c%c",Aligner2Status[4],Aligner2Status[5]);
            panel->Caption = msg;
            // Error code
            pnlAligner2ErrorCode->Caption = msg;
            pnlAligner2ErrorCode1->Caption = msg;
            break;
         case 5:
            msg.sprintf("%c%c%c",Aligner2Status[6],Aligner2Status[7],Aligner2Status[8]);
            panel->Caption = msg;
            // 011 - 無片, 111- 有片
            if(msg == "011")
               pnlAligner2WithWafer->Color = clSilver;
            else
               pnlAligner2WithWafer->Color = clLime;
            break;
         case 6:
            msg.sprintf("%c",Aligner2Status[9]);
            panel->Caption = msg;
            break;
         case 7:
            msg.sprintf("%c",Aligner2Status[10]);
            panel->Caption = msg;
            break;
         case 8:
            msg.sprintf("%c",Aligner2Status[11]);
            panel->Caption = msg;
            break;
         case 9:
            msg.sprintf("%c%c%c",Aligner2Status[12],Aligner2Status[13],Aligner2Status[14]);
            panel->Caption = msg;
            break;
      }
   }
}
//---------------------------------------------------------------------------
// boolAligner2Status = false;
void __fastcall TfrnMain::Aligner2Button()
{

   btnAligner2CMD->Enabled = boolAligner2Status;
   btnAligner2ORGN->Enabled = boolAligner2Status;
   btnAligner2VacuumOff->Enabled = boolAligner2Status;
   btnAligner2Alignment->Enabled = boolAligner2Status;
   btnAligner2Stas->Enabled = boolAligner2Status;
   btnAligner2WithWafer->Enabled = boolAligner2Status;
   //rgAligner2Set->Enabled = boolAligner2Status;
   //btnAligner2Set->Enabled = boolAligner2Status;
   //btnAligner2Get->Enabled = boolAligner2Status;
   btnAligner2Reset->Enabled = boolAligner2Status;
   btnAligner2Save->Enabled = boolAligner2Status;
   edAligner2Degree->Enabled = boolAligner2Status;
   edAligner2DegreeOut->Enabled = boolAligner2Status;
   //edAligner2Speed->Enabled = boolAligner2Status;
   //edAligner2Type->Enabled = boolAligner2Status;
}
//---------------------------------------------------------------------------
// 2022 12 19 - chc Aligner Active
void __fastcall TfrnMain::UpdateAligner2Status()
{

   if(boolAligner2Status == true) {
      pnlAligner2Status->Color = clLime;
      pnlAligner2Ready->Color = clLime;
   }
   else {
      pnlAligner2Status->Color = clRed;
      pnlAligner2Ready->Color = clRed;
   }
}
//---------------------------------------------------------------------------
// Aliger Send
void __fastcall TfrnMain::AddAligner2SendMessage(AnsiString msg)
{
AnsiString putmsg;

   // 固定要清除, 否則速度會變慢!
   if(mmAligner2Msg->Lines->Count > 400) {
      for(int i=320 ; i<mmAligner2Msg->Lines->Count ; i++)
         mmAligner2Msg->Lines->Delete(i);
   }

   //putmsg = ">" + msg;
   //mmAligner2Msg->Lines->Insert(0,putmsg);
   putmsg = Now().FormatString("nn':'ss':'zzz' > '") + msg;
   mmAligner2Msg->Lines->Insert(0,putmsg);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::tmAligner2ORGNDoneTimer(TObject *Sender)
{
int cnt = 0;
// 5sec
int max = 100;

   WriteSystemLog("tmAligner2ORGNDoneTimer Enter...");
   tmAligner2ORGNDone->Enabled = false;
   if(pnlAligner2ORGN->Color == clRed) {
      return;
   }
   iAligner2ORGNDone++;
   cnt = iAligner2ORGNDone;
   if(cnt > max) {
      WriteSystemLog("btnAligner2ORGNClick: 等完成ORGN(5sec) Timeout!");
      return;
   }
   // 發出STAS
   if(pnlAligner2ORGN->Color == clLime) {
      WriteSystemLog("btnAligner2ORGNClick: 完成ORGN, 發出GET:STAS;");
      btnAligner2StasClick(this);
      WriteSystemLog("執行Aligner2 ORGN.");
      return;
   }
   WriteSystemLog("[ORG Done]Wait...");
   tmAligner2ORGNDone->Enabled = true;
}
//---------------------------------------------------------------------------
// mmAligerMsg Recv
void __fastcall TfrnMain::AddAligner2RecvMessage(AnsiString msg)
{
AnsiString putmsg;

   // 固定要清除, 否則速度會變慢!
   if(mmAligner2Msg->Lines->Count > 400) {
      for(int i=320 ; i<mmAligner2Msg->Lines->Count ; i++)
         mmAligner2Msg->Lines->Delete(i);
   }

   //putmsg = "<" + msg;
   //putmsg = msg;
   //mmAligner2Msg->Lines->Insert(0,putmsg);
   putmsg = Now().FormatString("nn':'ss':'zzz' < '") + msg;
   mmAligner2Msg->Lines->Insert(0,putmsg);
}
//---------------------------------------------------------------------------
// 2022 12 19 - chc Error Code
//00  Normal
//10  Suction ON time over
//11  Suction OFF time over
//12  Lift UP time over
//13  Lift DOWN time over
//14  Workpiece lost error
//40  AREA ERROR
//50  OVER RUN ERROR
//99  SYSTEM ERROR
//A0  DRIVER ERROR
//D0  LINE SENSOR NOT READY
//D1  SEARCHED FEW EDGES
//D3  SCAN DATA OVER FLOW
//D5  ROTATION.LESS
//D7  OFFSET LIMIT OVER
//D8  OFFSET ROBOT OVER
//D9  OFFSET AXIS OVER
//DA  OFFSET ADDR ERROR
//DB  MOTOR DIRECTION ERROR
//DC  PARAMETER ERROR
void __fastcall TfrnMain::PutAligner2CodeMsg()
{
AnsiString msg = "";
AnsiString errorcode;
int code = 0;

   errorcode = pnlAligner2ErrorCode->Caption;
   if(errorcode == "")
      code = 0;
   else if(errorcode == "10")
      code = 1;
   else if(errorcode == "11")
      code = 2;
   else if(errorcode == "12")
      code = 3;
   else if(errorcode == "13")
      code = 4;
   else if(errorcode == "14")
      code = 5;
   else if(errorcode == "40")
      code = 6;
   else if(errorcode == "50")
      code = 7;
   else if(errorcode == "99")
      code = 8;
   else if(errorcode == "A0")
      code = 9;
   else if(errorcode == "D0")
      code = 10;
   else if(errorcode == "D1")
      code = 11;
   else if(errorcode == "D3")
      code = 12;
   else if(errorcode == "D5")
      code = 13;
   else if(errorcode == "D7")
      code = 14;
   else if(errorcode == "D8")
      code = 15;
   else if(errorcode == "D9")
      code = 16;
   else if(errorcode == "DA")
      code = 17;
   else if(errorcode == "DB")
      code = 18;
   else if(errorcode == "DC")
      code = 19;

   switch(code) {
      case 0:
         msg = "";
         break;
      case 1:
         msg = "Suction ON time over";
         break;
      case 2:
         msg = "Suction OFF time over";
         break;
      case 3:
         msg = "Lift UP time over";
         break;
      case 4:
         msg = "Lift DOWN time over";
         break;
      case 5:
         msg = "Workpiece lost error";
         break;
      case 6:
         msg = "AREA ERROR";
         break;
      case 7:
         msg = "OVER RUN ERROR";
         break;
      case 8:
         msg = "SYSTEM ERROR";
         break;
      case 9:
         msg = "DRIVER ERROR";
         break;
      case 10:
         msg = "LINE SENSOR NOT READY";
         break;
      case 11:
         msg = "SEARCHED FEW EDGES";
         break;
      case 12:
         msg = "SCAN DATA OVER FLOW";
         break;
      case 13:
         msg = "ROTATION.LESS";
         break;
      case 14:
         msg = "OFFSET LIMIT OVER";
         break;
      case 15:
         msg = "OFFSET ROBOT OVER";
         break;
      case 16:
         msg = "OFFSET AXIS OVER";
         break;
      case 17:
         msg = "OFFSET ADDR ERROR";
         break;
      case 18:
         msg = "MOTOR DIRECTION ERROR";
         break;
      case 19:
         msg = "PARAMETER ERROR";
         break;

   }
   pnlAligner2ErrorMsg->Caption = msg;
   pnlAligner2ErrorMsg->Hint = msg;

   // 2020 5 20a - chc Error Log
   if(code > 0) {
      AddErrorLog("[Aligner2] " + errorcode + ": " + msg);
   }

}
//---------------------------------------------------------------------------
//14:59:49.826 -> RST[Cr]
//14:59:49.857 <- [Ack]
//14:59:59.966 <- RST[Cr]
//15:00:00.961 <- RST[Cr]
//15:00:01.958 <- RST[Cr]
//
bool __fastcall TfrnMain::WaitTMRobotDone(timems)
{
long starttime,stoptime,elapsedms;
short starttick,stoptick;
// 記錄State : 下完Command, 等0.1sec才進來 WaitRobotDone()
int state = 0;

   GetTimeTic(&starttime,&starttick);
   while(1) {
      if((/*boolRobotAck == true &&*/ boolRobotComplete == true) || boolRobotNak == true) {
         if(/*boolRobotAck == true &&*/ boolRobotComplete == true)
            WriteSystemLog("WaitRobotDone: Ok");
         else
            WriteSystemLog("WaitRobotDone: Nak");
         break;
      }
      Sleep(50);
      Application->ProcessMessages();
      Sleep(50);

      GetTimeTic(&stoptime,&stoptick);
      elapsedms = ((stoptime*1000+stoptick) - (starttime*1000+starttick));
      if(elapsedms > timems) {
         WriteSystemLog("WaitRobotDone: Timeout! " + IntToStr(timems));
         return false;
      }
   }
   return true;
}
//---------------------------------------------------------------------------
bool __fastcall TfrnMain::WaitTMAlignerDone(timems)
{
long starttime,stoptime,elapsedms;
short starttick,stoptick;
// 記錄State : 下完Command, 等0.1sec才進來 WaitRobotDone()
int state = 0;

   GetTimeTic(&starttime,&starttick);
   while(1) {
      if((/*boolAlignerAck == true &&*/ boolAlignerComplete == true) || boolAlignerNak == true) {
         if(/*boolAlignerAck == true &&*/ boolAlignerComplete == true)
            WriteSystemLog("WaitAlignerDone: Ok");
         else
            WriteSystemLog("WaitAlignerDone: Nak");
         break;
      }
      Sleep(50);
      Application->ProcessMessages();
      Sleep(50);

      GetTimeTic(&stoptime,&stoptick);
      elapsedms = ((stoptime*1000+stoptick) - (starttime*1000+starttick));
      if(elapsedms > timems) {
         WriteSystemLog("WaitAlignerDone: Timeout! " + IntToStr(timems));
         return false;
      }
   }
   return true;
}
//---------------------------------------------------------------------------
bool __fastcall TfrnMain::WaitTMAligner2Done(timems)
{
long starttime,stoptime,elapsedms;
short starttick,stoptick;
// 記錄State : 下完Command, 等0.1sec才進來 WaitRobotDone()
int state = 0;

   GetTimeTic(&starttime,&starttick);
   while(1) {
      if((/*boolAligner2Ack == true &&*/ boolAligner2Complete == true) || boolAligner2Nak == true) {
         if(/*boolAligner2Ack == true &&*/ boolAligner2Complete == true)
            WriteSystemLog("WaitAligner2Done: Ok");
         else
            WriteSystemLog("WaitAligner2Done: Nak");
         break;
      }
      Sleep(50);
      Application->ProcessMessages();
      Sleep(50);

      GetTimeTic(&stoptime,&stoptick);
      elapsedms = ((stoptime*1000+stoptick) - (starttime*1000+starttick));
      if(elapsedms > timems) {
         WriteSystemLog("WaitAligner2Done: Timeout! " + IntToStr(timems));
         return false;
      }
   }
   return true;
}
//---------------------------------------------------------------------------
// Macro開真空 : for Tazmo
void __fastcall TfrnMain::MacroVacuum(bool mode)
{

   if(mode == true) {
      // 12"
      if(rgCST->ItemIndex == LOADPORT_1) {
         cbBit2->Checked = false;
         cbBit3->Checked = true;
      }
      // 8"
      else {
         cbBit2->Checked = true;
         cbBit3->Checked = false;
      }
   }
   else {
      cbBit2->Checked = false;
      cbBit3->Checked = false;
   }
   WriteDO(IO1_ID);

   // 在取放片作業時不用等
   if(boolInLoad == true || boolInUnLoad == true)
      return;

   WaitTime(1000);
}
//---------------------------------------------------------------------------
// 2022 12 20 - chc 交給timer同步做
void __fastcall TfrnMain::tmAligner2ResetTimer(TObject *Sender)
{

   tmAligner2Reset->Enabled = false;
   if(boolAligner2Status == true)
      btnAligner2ResetClick(this);
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::tmAlignerAckTimer(TObject *Sender)
{
unsigned char buf[50];
int len;

   tmAlignerAck->Enabled = false;
   sprintf(buf,"%c",ACK);
   len = strlen(buf);
   ybAligner->Write(buf,len);
   //WriteSystemLog("Aligner Send ACK");
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::tmAligner2AckTimer(TObject *Sender)
{
unsigned char buf[50];
int len;

   tmAligner2Ack->Enabled = false;
   sprintf(buf,"%c",ACK);
   len = strlen(buf);
   ybAligner2->Write(buf,len);
   //WriteSystemLog("Aligner2 Send ACK");
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::tmRobotAckTimer(TObject *Sender)
{
unsigned char buf[50];
int len;

   tmRobotAck->Enabled = false;
   sprintf(buf,"%c",ACK);
   len = strlen(buf);
   ybRobot->Write(buf,len);
   //WriteSystemLog("Robot Send ACK");
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnAlignerPRPClick(TObject *Sender)
{
bool ret;

   pnlAlignerPRP->Color = clSilver;
   edAlignerCmd->Text = "PRP,A";
   // 要Refresh
   edAlignerCmd->Refresh();
   btnAlignerCMDClick(this);
   ret = WaitTMAlignerDone(30000);
   if(ret == true)
      pnlAlignerPRP->Color = clLime;
   else
      pnlAlignerPRP->Color = clRed;
   return;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnAligner2PRPClick(TObject *Sender)
{
bool ret;

   pnlAligner2PRP->Color = clSilver;
   edAligner2Cmd->Text = "PRP,A";
   // 要Refresh
   edAligner2Cmd->Refresh();
   btnAligner2CMDClick(this);
   ret = WaitTMAligner2Done(30000);
   if(ret == true)
      pnlAligner2PRP->Color = clLime;
   else
      pnlAligner2PRP->Color = clRed;
   return;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::imCloseClick(TObject *Sender)
{

   pnlMaintenance->Visible = false;
   frmLogo->Visible = true;
}
//---------------------------------------------------------------------------
// 2022 12 22 - chc Tazmo
void __fastcall TfrnMain::btnMacroWithWaferClick(TObject *Sender)
{
bool boolBit1;
bool boolBit2;
bool boolBit3;
bool bool8 = false;
bool bool12 = false;

   // 2022 12 19 - chc Tazmo @@@@
   if(RobotMode != ROBOT_MODE_TAZMO) {
      WriteSystemLog(">btnMacroWithWaferClick()Enter");
      pnlMacroWithWafer->Color = clSilver;
      pcMotion->Enabled = false;
      // Save
      boolBit1 = cbBit1->Checked;
      boolBit2 = cbBit2->Checked;

      // 8" Vacuum
      cbBit1->Checked = true;
      cbBit2->Checked = false;
      WriteDO(IO1_ID);
      WaitTime(800);
      // Check
      if(pnlBit6->Color == clLime) {
         pnlMacroWithWafer->Caption = "內";
         bool8 = true;
      }
      else {
         // 12" Vacuum
         cbBit1->Checked = false;
         cbBit2->Checked = true;
         WriteDO(IO1_ID);
         WaitTime(800);
         // Check
         if(pnlBit7->Color == clLime) {
            pnlMacroWithWafer->Caption = "外";
            bool12 = true;
         }
      }

      if(bool8 == true || bool12 == true) {
         pnlMacroWithWafer->Color = clLime;
      }
      else {
         pnlMacroWithWafer->Color = clSilver;
         pnlMacroWithWafer->Caption = "";
      }

      // Restore
      cbBit1->Checked = boolBit1;
      cbBit2->Checked = boolBit2;
      WriteDO(IO1_ID);
      pcMotion->Enabled = true;
      return;
   }

   WriteSystemLog(">btnMacroWithWaferClick()Enter");
   pnlMacroWithWafer->Color = clSilver;
   pcMotion->Enabled = false;
   // Save
   boolBit2 = cbBit2->Checked;
   boolBit3 = cbBit3->Checked;

   // 8" Vacuum
   cbBit2->Checked = true;
   cbBit3->Checked = false;
   WriteDO(IO1_ID);
   WaitTime(800);
   // Check
   if(pnlBit7->Color == clLime) {
      pnlMacroWithWafer->Caption = "8";
      bool8 = true;
   }
   else {
      // 12" Vacuum
      cbBit2->Checked = false;
      cbBit3->Checked = true;
      WriteDO(IO1_ID);
      WaitTime(800);
      // Check
      if(pnlBit8->Color == clLime) {
         pnlMacroWithWafer->Caption = "12";
         bool12 = true;
      }
   }

   if(bool8 == true || bool12 == true) {
      pnlMacroWithWafer->Color = clLime;
   }
   else {
      pnlMacroWithWafer->Color = clSilver;
      pnlMacroWithWafer->Caption = "";
   }

   // Restore
   cbBit2->Checked = boolBit2;
   cbBit3->Checked = boolBit3;
   WriteDO(IO1_ID);
   pcMotion->Enabled = true;

}
//---------------------------------------------------------------------------
// 2022 12 22 - chc Tazmo
void __fastcall TfrnMain::btnChuckWithWaferClick(TObject *Sender)
{
bool boolBit0;
bool boolBit1;
bool bool8 = false;
bool bool12 = false;

   // 檢測中
   if(boolInInspecting == true) {
      if(RobotMode == ROBOT_MODE_TAZMO) {
         // 12"
         if(rgCST->ItemIndex == LOADPORT_1) {
            if(pnlBit6->Color == clLime)
               pnlChuckWithWafer->Color = clLime;
            else
               pnlChuckWithWafer->Color = clSilver;
         }
         // 8"
         else {
            if(pnlBit5->Color == clLime)
               pnlChuckWithWafer->Color = clLime;
            else
               pnlChuckWithWafer->Color = clSilver;
         }
      }
      else {
         if(pnlBit5->Color == clLime)
            pnlChuckWithWafer->Color = clLime;
         else
            pnlChuckWithWafer->Color = clSilver;
      }
      return;
   }

   // 2022 12 19 - chc Tazmo @@@@
   if(RobotMode != ROBOT_MODE_TAZMO) {
      pnlChuckWithWafer->Color = clSilver;
      pcMotion->Enabled = false;
      // Save
      boolBit0 = cbBit0->Checked;

      // 12" Vacuum
      cbBit0->Checked = true;
      WriteDO(IO1_ID);
      WaitTime(1000);
      // Check
      if(pnlBit5->Color == clLime) {
         pnlChuckWithWafer->Caption = "12";
         bool12 = true;
      }
      if(bool12 == true) {
         pnlChuckWithWafer->Color = clLime;
      }
      else {
         pnlChuckWithWafer->Color = clSilver;
         pnlChuckWithWafer->Caption = "";
      }

      // Restore
      cbBit0->Checked = boolBit0;
      WriteDO(IO1_ID);
      pcMotion->Enabled = true;
      return;
   }

   pnlChuckWithWafer->Color = clSilver;
   pcMotion->Enabled = false;
   // Save
   boolBit0 = cbBit0->Checked;
   boolBit1 = cbBit1->Checked;

   // 8" Vacuum
   cbBit0->Checked = true;
   cbBit1->Checked = false;
   WriteDO(IO1_ID);
   WaitTime(1000);
   // Check
   if(pnlBit5->Color == clLime) {
      pnlChuckWithWafer->Caption = "8";
      bool8 = true;
   }
   else {
      // 12" Vacuum
      cbBit0->Checked = false;
      cbBit1->Checked = true;
      WriteDO(IO1_ID);
      WaitTime(1000);
      // Check
      if(pnlBit6->Color == clLime) {
         pnlChuckWithWafer->Caption = "12";
         bool12 = true;
      }
   }

   if(bool8 == true || bool12 == true) {
      pnlChuckWithWafer->Color = clLime;
   }
   else {
      pnlChuckWithWafer->Color = clSilver;
      pnlChuckWithWafer->Caption = "";
   }

   // Restore
   cbBit0->Checked = boolBit0;
   cbBit1->Checked = boolBit1;
   WriteDO(IO1_ID);
   pcMotion->Enabled = true;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnMacroInverseClick(TObject *Sender)
{

   // Check Macro
   pnlMacroInverse->Color = clSilver;
   btnMacroWithWaferClick(this);
   if(pnlMacroWithWafer->Color == clSilver) {
      pnlMainOperation->Caption = "Macro Without Wafer!";
      pnlMacroInverse->Color = clRed;
      return;
   }

   // Check Robot
   btnRobotWithWaferClick(this);
   if(pnlRobotWithWafer->Color == clLime) {
      pnlMainOperation->Caption = "Robot With Wafer!";
      pnlMacroInverse->Color = clRed;
      return;
   }

   // Macro Home
   btnMacroHomeClick(this);
   if(pnlMacroHome->Color != clLime) {
      pnlMainOperation->Caption = "Macro Home Fail!";
      pnlMacroInverse->Color = clRed;
      return;
   }
   if(pnlRobot->Enabled == false) {
      pnlMainOperation->Caption = "Robot Busy!";
      pnlMacroInverse->Color = clRed;
      return;
   }

   rgWaferLocation->ItemIndex = LOCATION_MACRO;
   combRobotTrayNo->ItemIndex = 0;
   combRobotTrayNo->Text = "1";
   // Top to Back
   if(rgSide->ItemIndex == WAFER_TOP) {
      // Macro Get
      btnRobotGetClick(this);
      if(pnlRobotGet->Color != clLime) {
         pnlMainOperation->Caption = "Robot Get Fail!";
         pnlMacroInverse->Color = clRed;
         return;
      }
      rgSide->ItemIndex = WAFER_BACK;
      // Macro Put
      btnRobotPutClick(this);
      if(pnlRobotPut->Color != clLime) {
         pnlMainOperation->Caption = "Robot Put Fail!";
         pnlMacroInverse->Color = clRed;
         return;
      }
   }
   // Back to Top
   else {
      btnRobotGetClick(this);
      if(pnlRobotGet->Color != clLime) {
         pnlMainOperation->Caption = "Robot Get Fail!";
         pnlMacroInverse->Color = clRed;
         return;
      }
      rgSide->ItemIndex = WAFER_TOP;
      // Macro Put
      btnRobotPutClick(this);
      if(pnlRobotPut->Color != clLime) {
         pnlMainOperation->Caption = "Robot Put Fail!";
         pnlMacroInverse->Color = clRed;
         return;
      }
   }
   pnlMacroInverse->Color = clLime;
}
//---------------------------------------------------------------------------
// 2022 12 26 - chc Multi CCD
void __fastcall TfrnMain::combCCDSelectChange(TObject *Sender)
{
int ccdno;

   ccdno = combCCDSelect->ItemIndex;
   rgCCDShutter->ItemIndex = CCDShutterAry[ccdno];
   tbCCDGain->Position = CCDGainAry[ccdno];
   tbContrast->Position = CCDContrastAry[ccdno];

   // 2023 1 3 - chc White Balance
   cbWBAuto->Checked = CCDWBAuto[ccdno];

}
//---------------------------------------------------------------------------
// 2022 12 26 - chc Multi CCD
int CaptureCounterLeft = 0;
void __fastcall TfrnMain::tmISLeftCCDTimer(TObject *Sender)
{
int no;
static int count = 0;
AnsiString msg;
int width,height,sx,sy,x,y,w,h;

   // 2022 12 28 - chc Stop Capture
   /*
   if(frmInspection->Visible == true && frmInspection->pcInspection->ActivePage == frmInspection->tsMacroInspection) {
      //ICImagingControl2->LiveCaptureContinuous = true;
      ICImagingControl1->LiveStart();
      goto tocapture;
   }
   else {
      //ICImagingControl2->LiveCaptureContinuous = false;
      ICImagingControl1->LiveStop();
      return;
   }
   */
tocapture:

   tmISLeftCCD->Enabled = false;
   pnlISCCD2Capture->Color = clLime;
   pnlISCCD2Capture->Refresh();

   // Snap an image.
   ICImagingControl2->MemorySnapImage();
   // Copy the last grabbed image to the PictureBox control

   // Buffer Mode: 取得資料加以解讀
   //unsigned char r,g,b;
   //color = imCCD->Canvas->Pixels[X][Y];
   //b = (color & 0xff0000) >> 16;
   //g = (color & 0x00ff00) >> 8;
   //r = color & 0x0000ff;
   unsigned char *buffer;
   buffer = (unsigned char *)ICImagingControl2->ImageActiveBuffer->get_ImageDataPtr();
   int bytesperpixel;
   bytesperpixel = ICImagingControl2->ImageBitsPerPixel / 8;

   // 累計數量
   CaptureCounterLeft++;

   // Index
   pnlCCD2Status->Color = clSilver;
   no = 1;
   width = CCDInfoAry[no].Width;
   height = CCDInfoAry[no].Height;
   //WriteSystemLog("Show-0: " + IntToStr(width) + "," + IntToStr(height) + "," + IntToStr(CCDInfoAry[no].Type));
   w = frmInspection->imLeftCCD->Width;
   h = frmInspection->imLeftCCD->Height;
   // 固定為CCDRangeX,CCDRangeY: 部份影像的起點(有雷射機要以雷射點為主)
   LaserCenterX = CCDRangeX;
   LaserCenterY = CCDRangeY;
   sx = LaserCenterX;
   sy = LaserCenterY;
   //WriteSystemLog("Frame sx,sy= " + IntToStr(sx) + "," + IntToStr(sy));

   // Check Range: 檢查起點是否錯誤?
   // sx,sy目前可視區域的起點: Scrollbar的Position值
   //   CCDDx = CCDInfoAry[0].Width - imCCD->Width;
   //   CCDDy = CCDInfoAry[0].Height - imCCD->Height;
   //   CCDRangeX = CCDDx / 2;
   //   CCDRangeY = CCDDy / 2;
   CheckRange(&sx,&sy);
   // 在影像處理中
   boolInGigaBufferAry[no] = true;
   //WriteSystemLog("Frame sx,sy= " + IntToStr(sx) + "," + IntToStr(sy));

   count++;
   unsigned char *pt,*pt1;
   int i;
   int pointer;
   // 記錄Basler存檔中...: 目前無作用
   if(boolInGigaSaveAry[no] == true) {
      pnlSystemMessage->Caption = "In Saving... Stop Refeshing Image";
      boolInGigaBufferAry[no] = false;
      return;
   }
   pnlCCD2Status->Color = clLime;

   // 要顯示在主畫面
   // width,height: CCD解析度
   // sx,sy: 目前可視區域的起點, Scrollbar的Position值
   // w,h: imCCD解析度
   GetImageXY(width,height,sx,sy,w,h,&x,&y);

   //height = 960;
   //WriteSystemLog("Show-1: " + IntToStr(width) + "," + IntToStr(height) + "," + IntToStr(CCDInfoAry[no].Type));
   if(CCDInfoAry[no].Type == CCD_BW)
      CCDImageAry[no].SetSize(width,height);
   else
      usb_ImageAry[no].SetSize(width,height);
   //WriteSystemLog("Show-2");

   // BW : CCDImageAry
   if(CCDInfoAry[no].Type == CCD_BW) {
      //WriteSystemLog("Show-Gray");
      i = 0;
      for(int row=height-1 ; row>=0 ; row--) {
         pt = (unsigned char *)CCDImageAry[no].GetImagePtr(0,row);
         // 由buffer到pt
         memcpy(pt, &buffer[i],width);
         i += width;
      }

      // Inspection
      if(frmInspection->Visible == true && frmInspection->pcInspection->ActivePage == frmInspection->tsMacroInspection &&
         frmInspection->cbFreezeRL->Checked == false) {
         w = frmInspection->imLeftCCD->Width;
         h = frmInspection->imLeftCCD->Height;
         if(frmInspection->cbCCDFullImageLR->Checked == true) {
            w = width;
            h = height;
         }
         sx = (width - frmInspection->imLeftCCD->Width) / 2;
         sy = (height - frmInspection->imLeftCCD->Height) / 2;
         frmInspection->LaserCenterX = sx;
         frmInspection->LaserCenterY = sy;
         frmInspection->CCDRangeX = sx;
         frmInspection->CCDRangeY = sy;
         frmInspection->imLeftCCD->Picture->Bitmap->Width = w;
         frmInspection->imLeftCCD->Picture->Bitmap->Height = h;
         CCDImageROIAry[no].Detach();
         CCDImageROIAry[no].Attach(&CCDImageAry[no]);
         GetImageXY(width,height,sx,sy,w,h,&x,&y);
         CCDImageROIAry[no].SetPlacement(x,y,w,h);
         CCDImageROIAry[no].Draw(frmInspection->imLeftCCD->Canvas->Handle);
         frmInspection->imLeftCCD->Refresh();
      }
      // Recipe Set
      else if(frmRecipeSet->Visible == true && frmRecipeSet->pcWaferInformation->ActivePage == frmRecipeSet->tsMacro) {
         w = frmRecipeSet->imLeftCCD->Width;
         h = frmRecipeSet->imLeftCCD->Height;
         if(frmRecipeSet->cbCCDFullImageLR->Checked == true) {
            w = width;
            h = height;
         }
         sx = (width - frmRecipeSet->imLeftCCD->Width) / 2;
         sy = (height - frmRecipeSet->imLeftCCD->Height) / 2;
         frmRecipeSet->LaserCenterX = sx;
         frmRecipeSet->LaserCenterY = sy;
         frmRecipeSet->CCDRangeX = sx;
         frmRecipeSet->CCDRangeY = sy;
         frmRecipeSet->imLeftCCD->Picture->Bitmap->Width = w;
         frmRecipeSet->imLeftCCD->Picture->Bitmap->Height = h;
         CCDImageROIAry[no].Detach();
         CCDImageROIAry[no].Attach(&CCDImageAry[no]);
         GetImageXY(width,height,sx,sy,w,h,&x,&y);
         CCDImageROIAry[no].SetPlacement(x,y,w,h);
         CCDImageROIAry[no].Draw(frmRecipeSet->imLeftCCD->Canvas->Handle);
         frmRecipeSet->imLeftCCD->Refresh();
      }

      /*
      //WriteSystemLog("Show-3");
      CCDImageROIAry[no].Detach();
      //WriteSystemLog("Show-4");
      CCDImageROIAry[no].Attach(&CCDImageAry[no]);
      //WriteSystemLog("Show-5");

      // Full Image
      //WriteSystemLog("Frame x,y,w,h= " + IntToStr(x) + "," + IntToStr(y) + "," + IntToStr(w) + "," + IntToStr(h));
      if(frmInspection->cbCCDFullImageLR->Checked == true) {
         frmInspection->imLeftCCD->Picture->Bitmap->Width = width;
         frmInspection->imLeftCCD->Picture->Bitmap->Height = height;
         CCDImageROIAry[no].SetPlacement(0,0,width,height);
      }
      else {
         // 要設Size
         frmInspection->imLeftCCD->Picture->Bitmap->Width = w;
         frmInspection->imLeftCCD->Picture->Bitmap->Height = h;
         CCDImageROIAry[no].SetPlacement(x,y,w,h);
      }

      // 2022 9 4 - chc Inspection
      if(frmInspection->Visible == true && frmInspection->pcInspection->ActivePage == frmInspection->tsMacroInspection &&
         frmInspection->cbFreezeRL->Checked == false) {
         if(frmInspection->cbCCDFullImageLR->Checked == true) {
            frmInspection->imLeftCCD->Picture->Bitmap->Width = width;
            frmInspection->imLeftCCD->Picture->Bitmap->Height = height;
         }
         else {
            frmInspection->imLeftCCD->Picture->Bitmap->Width = frmInspection->imLeftCCD->Width;
            frmInspection->imLeftCCD->Picture->Bitmap->Height = frmInspection->imLeftCCD->Height;
         }
         CCDImageROIAry[no].Draw(frmInspection->imLeftCCD->Canvas->Handle);
      }

      // 2023 1 5 - chc Recipe Set
      else if(frmRecipeSet->Visible == true && frmRecipeSet->pcWaferInformation->ActivePage == frmRecipeSet->tsMacro) {
         w = frmRecipeSet->imLeftCCD->Width;
         h = frmRecipeSet->imLeftCCD->Height;
         GetImageXY(width,height,sx,sy,w,h,&x,&y);
         if(frmRecipeSet->cbCCDFullImageLR->Checked == true) {
            frmRecipeSet->imLeftCCD->Picture->Bitmap->Width = width;
            frmRecipeSet->imLeftCCD->Picture->Bitmap->Height = height;
            CCDImageROIAry[no].SetPlacement(0,0,width,height);
         }
         else {
            // 要設Size
            frmRecipeSet->imLeftCCD->Picture->Bitmap->Width = w;
            frmRecipeSet->imLeftCCD->Picture->Bitmap->Height = h;
            CCDImageROIAry[no].SetPlacement(x,y,w,h);
         }
         CCDImageROIAry[no].Draw(frmRecipeSet->imLeftCCD->Canvas->Handle);
      }
      */

      //WriteSystemLog("Show-7");
      // 計算平均灰階
      ComputeAverageGray();
   }
   // Color
   else {
      // Color : usb_ImageAry
      i = 0;
      for(int row=height-1 ; row>=0 ; row--) {
         pt = (unsigned char *)usb_ImageAry[no].GetImagePtr(0,row);
         // 由buffer到pt
         memcpy(pt, &buffer[i],width*3);
         i += (width*3);
      }

      // Inspection
      if(frmInspection->Visible == true && frmInspection->pcInspection->ActivePage == frmInspection->tsMacroInspection &&
         frmInspection->cbFreezeRL->Checked == false) {
         w = frmInspection->imLeftCCD->Width;
         h = frmInspection->imLeftCCD->Height;
         if(frmInspection->cbCCDFullImageLR->Checked == true) {
            w = width;
            h = height;
         }
         sx = (width - frmInspection->imLeftCCD->Width) / 2;
         sy = (height - frmInspection->imLeftCCD->Height) / 2;
         frmInspection->LaserCenterX = sx;
         frmInspection->LaserCenterY = sy;
         frmInspection->CCDRangeX = sx;
         frmInspection->CCDRangeY = sy;
         frmInspection->imLeftCCD->Picture->Bitmap->Width = w;
         frmInspection->imLeftCCD->Picture->Bitmap->Height = h;
         usb_ImageROIAry[no].Detach();
         usb_ImageROIAry[no].Attach(&usb_ImageAry[no]);
         GetImageXY(width,height,sx,sy,w,h,&x,&y);
         usb_ImageROIAry[no].SetPlacement(x,y,w,h);
         usb_ImageROIAry[no].Draw(frmInspection->imLeftCCD->Canvas->Handle);
         frmInspection->imLeftCCD->Refresh();
      }
      // Recipe Set
      else if(frmRecipeSet->Visible == true && frmRecipeSet->pcWaferInformation->ActivePage == frmRecipeSet->tsMacro) {
         w = frmRecipeSet->imLeftCCD->Width;
         h = frmRecipeSet->imLeftCCD->Height;
         if(frmRecipeSet->cbCCDFullImageLR->Checked == true) {
            w = width;
            h = height;
         }
         sx = (width - frmRecipeSet->imLeftCCD->Width) / 2;
         sy = (height - frmRecipeSet->imLeftCCD->Height) / 2;
         frmRecipeSet->LaserCenterX = sx;
         frmRecipeSet->LaserCenterY = sy;
         frmRecipeSet->CCDRangeX = sx;
         frmRecipeSet->CCDRangeY = sy;
         frmRecipeSet->imLeftCCD->Picture->Bitmap->Width = w;
         frmRecipeSet->imLeftCCD->Picture->Bitmap->Height = h;
         usb_ImageROIAry[no].Detach();
         usb_ImageROIAry[no].Attach(&usb_ImageAry[no]);
         GetImageXY(width,height,sx,sy,w,h,&x,&y);
         usb_ImageROIAry[no].SetPlacement(x,y,w,h);
         usb_ImageROIAry[no].Draw(frmRecipeSet->imLeftCCD->Canvas->Handle);
         frmRecipeSet->imLeftCCD->Refresh();
      }
      /*
      usb_ImageROIAry[no].Detach();
      usb_ImageROIAry[no].Attach(&usb_ImageAry[no]);

      if(frmInspection->Visible == true && frmInspection->pcInspection->ActivePage == frmInspection->tsMacroInspection &&
         frmInspection->cbFreezeRL->Checked == false) {
         if(frmInspection->cbCCDFullImageLR->Checked == true) {
            frmInspection->imLeftCCD->Picture->Bitmap->Width = width;
            frmInspection->imLeftCCD->Picture->Bitmap->Height = height;
            usb_ImageROIAry[no].SetPlacement(0,0,width,height);
         }
         else {
            // 要設Size
            frmInspection->imLeftCCD->Picture->Bitmap->Width = w;
            frmInspection->imLeftCCD->Picture->Bitmap->Height = h;
            usb_ImageROIAry[no].SetPlacement(x,y,w,h);
         }
         usb_ImageROIAry[no].Draw(frmInspection->imLeftCCD->Canvas->Handle);
         frmInspection->imLeftCCD->Refresh();
      }

      // 2023 1 5 - chc Recipe Set
      else if(frmRecipeSet->Visible == true && frmRecipeSet->pcWaferInformation->ActivePage == frmRecipeSet->tsMacro) {
         w = frmRecipeSet->imLeftCCD->Width;
         h = frmRecipeSet->imLeftCCD->Height;
         GetImageXY(width,height,sx,sy,w,h,&x,&y);
         if(frmRecipeSet->cbCCDFullImageLR->Checked == true) {
            frmRecipeSet->imLeftCCD->Picture->Bitmap->Width = width;
            frmRecipeSet->imLeftCCD->Picture->Bitmap->Height = height;
            usb_ImageROIAry[no].SetPlacement(0,0,width,height);
         }
         else {
            // 要設Size
            frmRecipeSet->imLeftCCD->Picture->Bitmap->Width = w;
            frmRecipeSet->imLeftCCD->Picture->Bitmap->Height = h;
            usb_ImageROIAry[no].SetPlacement(x,y,w,h);
         }
         usb_ImageROIAry[no].Draw(frmRecipeSet->imLeftCCD->Canvas->Handle);
         frmRecipeSet->imLeftCCD->Refresh();
      }
      */

   }

   // Basler Pylon GigE CCD: 計算Capture Rate
   boolBaslerImageLoadedAry[no] = true;
   boolCCDImageLoadedAry[no] = true;
   BaslerCaptureNoAry[no]++;
   if((count % 5) == 0) {
      GetTimeTic(&BaslerStopTimeAry[no],&BaslerStopTickAry[no]);
      BaslerElapsedmsAry[no] = ((BaslerStopTimeAry[no]*1000+BaslerStopTickAry[no]) - (BaslerStartTimeAry[no]*1000+BaslerStartTickAry[no]));
      double ratio;
      AnsiString msg;
      // Devide by zero
      if(BaslerElapsedmsAry[no] != 0) {
         ratio = ((double)BaslerCaptureNoAry[no] * 1000.0) / BaslerElapsedmsAry[no];
         msg.sprintf("%.1f",ratio);
         pnlCapturedNo2->Caption = msg;
      }
   }

   // 未在影像處理中
   boolInGigaBufferAry[no] = false;
   tmISLeftCCD->Enabled = true;
   pnlISCCD2Capture->Color = clSilver;
   pnlISCCD2Capture->Refresh();
}
//---------------------------------------------------------------------------
int CaptureCounterRight = 0;
// 2022 12 26 - chc Multi CCD
void __fastcall TfrnMain::tmISRightCCDTimer(TObject *Sender)
{
int no;
static int count = 0;
AnsiString msg;
int width,height,sx,sy,x,y,w,h;

   // 2022 12 28 - chc Stop Capture
   /*
   if(frmInspection->Visible == true && frmInspection->pcInspection->ActivePage == frmInspection->tsMacroInspection) {
      //ICImagingControl3->LiveCaptureContinuous = true;
      ICImagingControl1->LiveStart();
      goto tocapture;
   }
   else {
      //ICImagingControl3->LiveCaptureContinuous = false;
      ICImagingControl1->LiveStop();
      return;
   }
   */
tocapture:

   tmISRightCCD->Enabled = false;
   pnlISCCD3Capture->Color = clLime;
   pnlISCCD3Capture->Refresh();

   // Snap an image.
   ICImagingControl3->MemorySnapImage();
   // Copy the last grabbed image to the PictureBox control

   // Buffer Mode: 取得資料加以解讀
   //unsigned char r,g,b;
   //color = imCCD->Canvas->Pixels[X][Y];
   //b = (color & 0xff0000) >> 16;
   //g = (color & 0x00ff00) >> 8;
   //r = color & 0x0000ff;
   unsigned char *buffer;
   buffer = (unsigned char *)ICImagingControl3->ImageActiveBuffer->get_ImageDataPtr();
   int bytesperpixel;
   bytesperpixel = ICImagingControl3->ImageBitsPerPixel / 8;

   // 累計數量
   CaptureCounterRight++;

   // Index
   pnlCCD3Status->Color = clSilver;
   no = 2;
   width = CCDInfoAry[no].Width;
   height = CCDInfoAry[no].Height;
   //WriteSystemLog("Show-0: " + IntToStr(width) + "," + IntToStr(height) + "," + IntToStr(CCDInfoAry[no].Type));
   w = frmInspection->imRightCCD->Width;
   h = frmInspection->imRightCCD->Height;
   // 固定為CCDRangeX,CCDRangeY: 部份影像的起點(有雷射機要以雷射點為主)
   LaserCenterX = CCDRangeX;
   LaserCenterY = CCDRangeY;
   sx = LaserCenterX;
   sy = LaserCenterY;
   //WriteSystemLog("Frame sx,sy= " + IntToStr(sx) + "," + IntToStr(sy));

   // Check Range: 檢查起點是否錯誤?
   // sx,sy目前可視區域的起點: Scrollbar的Position值
   //   CCDDx = CCDInfoAry[0].Width - imCCD->Width;
   //   CCDDy = CCDInfoAry[0].Height - imCCD->Height;
   //   CCDRangeX = CCDDx / 2;
   //   CCDRangeY = CCDDy / 2;
   CheckRange(&sx,&sy);
   // 在影像處理中
   boolInGigaBufferAry[no] = true;
   //WriteSystemLog("Frame sx,sy= " + IntToStr(sx) + "," + IntToStr(sy));

   count++;
   unsigned char *pt,*pt1;
   int i;
   int pointer;
   // 記錄Basler存檔中...: 目前無作用
   if(boolInGigaSaveAry[no] == true) {
      pnlSystemMessage->Caption = "In Saving... Stop Refeshing Image";
      boolInGigaBufferAry[no] = false;
      return;
   }
   pnlCCD3Status->Color = clLime;

   // 要顯示在主畫面
   // width,height: CCD解析度
   // sx,sy: 目前可視區域的起點, Scrollbar的Position值
   // w,h: imCCD解析度
   GetImageXY(width,height,sx,sy,w,h,&x,&y);

   //height = 960;
   //WriteSystemLog("Show-1: " + IntToStr(width) + "," + IntToStr(height) + "," + IntToStr(CCDInfoAry[no].Type));
   if(CCDInfoAry[no].Type == CCD_BW)
      CCDImageAry[no].SetSize(width,height);
   else
      usb_ImageAry[no].SetSize(width,height);
   //WriteSystemLog("Show-2");

   // BW : CCDImageAry
   if(CCDInfoAry[no].Type == CCD_BW) {
      //WriteSystemLog("Show-Gray");
      i = 0;
      for(int row=height-1 ; row>=0 ; row--) {
         pt = (unsigned char *)CCDImageAry[no].GetImagePtr(0,row);
         // 由buffer到pt
         memcpy(pt, &buffer[i],width);
         i += width;
      }

      // Inspection
      if(frmInspection->Visible == true && frmInspection->pcInspection->ActivePage == frmInspection->tsMacroInspection &&
         frmInspection->cbFreezeRL->Checked == false) {
         w = frmInspection->imRightCCD->Width;
         h = frmInspection->imRightCCD->Height;
         if(frmInspection->cbCCDFullImageLR->Checked == true) {
            w = width;
            h = height;
         }
         sx = (width - frmInspection->imRightCCD->Width) / 2;
         sy = (height - frmInspection->imRightCCD->Height) / 2;
         frmInspection->LaserCenterX = sx;
         frmInspection->LaserCenterY = sy;
         frmInspection->CCDRangeX = sx;
         frmInspection->CCDRangeY = sy;
         frmInspection->imRightCCD->Picture->Bitmap->Width = w;
         frmInspection->imRightCCD->Picture->Bitmap->Height = h;
         CCDImageROIAry[no].Detach();
         CCDImageROIAry[no].Attach(&CCDImageAry[no]);
         GetImageXY(width,height,sx,sy,w,h,&x,&y);
         CCDImageROIAry[no].SetPlacement(x,y,w,h);
         CCDImageROIAry[no].Draw(frmInspection->imRightCCD->Canvas->Handle);
         frmInspection->imRightCCD->Refresh();
      }
      // Recipe Set
      else if(frmRecipeSet->Visible == true && frmRecipeSet->pcWaferInformation->ActivePage == frmRecipeSet->tsMacro) {
         w = frmRecipeSet->imRightCCD->Width;
         h = frmRecipeSet->imRightCCD->Height;
         if(frmRecipeSet->cbCCDFullImageLR->Checked == true) {
            w = width;
            h = height;
         }
         sx = (width - frmRecipeSet->imRightCCD->Width) / 2;
         sy = (height - frmRecipeSet->imRightCCD->Height) / 2;
         frmRecipeSet->LaserCenterX = sx;
         frmRecipeSet->LaserCenterY = sy;
         frmRecipeSet->CCDRangeX = sx;
         frmRecipeSet->CCDRangeY = sy;
         frmRecipeSet->imRightCCD->Picture->Bitmap->Width = w;
         frmRecipeSet->imRightCCD->Picture->Bitmap->Height = h;
         CCDImageROIAry[no].Detach();
         CCDImageROIAry[no].Attach(&CCDImageAry[no]);
         GetImageXY(width,height,sx,sy,w,h,&x,&y);
         CCDImageROIAry[no].SetPlacement(x,y,w,h);
         CCDImageROIAry[no].Draw(frmRecipeSet->imRightCCD->Canvas->Handle);
         frmRecipeSet->imRightCCD->Refresh();
      }

      /*
      //WriteSystemLog("Show-3");
      CCDImageROIAry[no].Detach();
      //WriteSystemLog("Show-4");
      CCDImageROIAry[no].Attach(&CCDImageAry[no]);
      //WriteSystemLog("Show-5");

      // Full Image
      //WriteSystemLog("Frame x,y,w,h= " + IntToStr(x) + "," + IntToStr(y) + "," + IntToStr(w) + "," + IntToStr(h));
      if(frmInspection->cbCCDFullImageLR->Checked == true) {
         frmInspection->imRightCCD->Picture->Bitmap->Width = width;
         frmInspection->imRightCCD->Picture->Bitmap->Height = height;
         CCDImageROIAry[no].SetPlacement(0,0,width,height);
      }
      else {
         // 要設Size
         frmInspection->imRightCCD->Picture->Bitmap->Width = w;
         frmInspection->imRightCCD->Picture->Bitmap->Height = h;
         CCDImageROIAry[no].SetPlacement(x,y,w,h);
      }

      // 2022 9 4 - chc Inspection
      if(frmInspection->Visible == true && frmInspection->pcInspection->ActivePage == frmInspection->tsMacroInspection &&
         frmInspection->cbFreezeRL->Checked == false) {
         if(frmInspection->cbCCDFullImageLR->Checked == true) {
            frmInspection->imRightCCD->Picture->Bitmap->Width = width;
            frmInspection->imRightCCD->Picture->Bitmap->Height = height;
         }
         else {
            frmInspection->imRightCCD->Picture->Bitmap->Width = frmInspection->imRightCCD->Width;
            frmInspection->imRightCCD->Picture->Bitmap->Height = frmInspection->imRightCCD->Height;
         }
         CCDImageROIAry[no].Draw(frmInspection->imRightCCD->Canvas->Handle);
      }

      // 2023 1 5 - chc Recipe Set
      else if(frmRecipeSet->Visible == true && frmRecipeSet->pcWaferInformation->ActivePage == frmRecipeSet->tsMacro) {
         w = frmRecipeSet->imRightCCD->Width;
         h = frmRecipeSet->imRightCCD->Height;
         GetImageXY(width,height,sx,sy,w,h,&x,&y);
         if(frmRecipeSet->cbCCDFullImageLR->Checked == true) {
            frmRecipeSet->imRightCCD->Picture->Bitmap->Width = width;
            frmRecipeSet->imRightCCD->Picture->Bitmap->Height = height;
            CCDImageROIAry[no].SetPlacement(0,0,width,height);
         }
         else {
            // 要設Size
            frmRecipeSet->imRightCCD->Picture->Bitmap->Width = w;
            frmRecipeSet->imRightCCD->Picture->Bitmap->Height = h;
            CCDImageROIAry[no].SetPlacement(x,y,w,h);
         }
         CCDImageROIAry[no].Draw(frmRecipeSet->imRightCCD->Canvas->Handle);
      }
      */

      //WriteSystemLog("Show-7");
      // 計算平均灰階
      ComputeAverageGray();
   }
   // Color
   else {
      // Color : usb_ImageAry
      i = 0;
      for(int row=height-1 ; row>=0 ; row--) {
         pt = (unsigned char *)usb_ImageAry[no].GetImagePtr(0,row);
         // 由buffer到pt
         memcpy(pt, &buffer[i],width*3);
         i += (width*3);
      }

      // Inspection
      if(frmInspection->Visible == true && frmInspection->pcInspection->ActivePage == frmInspection->tsMacroInspection &&
         frmInspection->cbFreezeRL->Checked == false) {
         w = frmInspection->imRightCCD->Width;
         h = frmInspection->imRightCCD->Height;
         if(frmInspection->cbCCDFullImageLR->Checked == true) {
            w = width;
            h = height;
         }
         sx = (width - frmInspection->imRightCCD->Width) / 2;
         sy = (height - frmInspection->imRightCCD->Height) / 2;
         frmInspection->LaserCenterX = sx;
         frmInspection->LaserCenterY = sy;
         frmInspection->CCDRangeX = sx;
         frmInspection->CCDRangeY = sy;
         frmInspection->imRightCCD->Picture->Bitmap->Width = w;
         frmInspection->imRightCCD->Picture->Bitmap->Height = h;
         usb_ImageROIAry[no].Detach();
         usb_ImageROIAry[no].Attach(&usb_ImageAry[no]);
         GetImageXY(width,height,sx,sy,w,h,&x,&y);
         usb_ImageROIAry[no].SetPlacement(x,y,w,h);
         usb_ImageROIAry[no].Draw(frmInspection->imRightCCD->Canvas->Handle);
         frmInspection->imRightCCD->Refresh();
      }
      // Recipe Set
      else if(frmRecipeSet->Visible == true && frmRecipeSet->pcWaferInformation->ActivePage == frmRecipeSet->tsMacro) {
         w = frmRecipeSet->imRightCCD->Width;
         h = frmRecipeSet->imRightCCD->Height;
         if(frmRecipeSet->cbCCDFullImageLR->Checked == true) {
            w = width;
            h = height;
         }
         sx = (width - frmRecipeSet->imRightCCD->Width) / 2;
         sy = (height - frmRecipeSet->imRightCCD->Height) / 2;
         frmRecipeSet->LaserCenterX = sx;
         frmRecipeSet->LaserCenterY = sy;
         frmRecipeSet->CCDRangeX = sx;
         frmRecipeSet->CCDRangeY = sy;
         frmRecipeSet->imRightCCD->Picture->Bitmap->Width = w;
         frmRecipeSet->imRightCCD->Picture->Bitmap->Height = h;
         usb_ImageROIAry[no].Detach();
         usb_ImageROIAry[no].Attach(&usb_ImageAry[no]);
         GetImageXY(width,height,sx,sy,w,h,&x,&y);
         usb_ImageROIAry[no].SetPlacement(x,y,w,h);
         usb_ImageROIAry[no].Draw(frmRecipeSet->imRightCCD->Canvas->Handle);
         frmRecipeSet->imRightCCD->Refresh();
      }

      /*
      usb_ImageROIAry[no].Detach();
      usb_ImageROIAry[no].Attach(&usb_ImageAry[no]);

      if(frmInspection->Visible == true && frmInspection->pcInspection->ActivePage == frmInspection->tsMacroInspection &&
         frmInspection->cbFreezeRL->Checked == false) {
         if(frmInspection->cbCCDFullImageLR->Checked == true) {
            frmInspection->imRightCCD->Picture->Bitmap->Width = width;
            frmInspection->imRightCCD->Picture->Bitmap->Height = height;
            usb_ImageROIAry[no].SetPlacement(0,0,width,height);
         }
         else {
            // 要設Size
            frmInspection->imRightCCD->Picture->Bitmap->Width = w;
            frmInspection->imRightCCD->Picture->Bitmap->Height = h;
            usb_ImageROIAry[no].SetPlacement(x,y,w,h);
         }
         usb_ImageROIAry[no].Draw(frmInspection->imRightCCD->Canvas->Handle);
         frmInspection->imRightCCD->Refresh();
      }

      // 2023 1 5 - chc Recipe Set
      else if(frmRecipeSet->Visible == true && frmRecipeSet->pcWaferInformation->ActivePage == frmRecipeSet->tsMacro) {
         w = frmRecipeSet->imRightCCD->Width;
         h = frmRecipeSet->imRightCCD->Height;
         GetImageXY(width,height,sx,sy,w,h,&x,&y);
         if(frmRecipeSet->cbCCDFullImageLR->Checked == true) {
            frmRecipeSet->imRightCCD->Picture->Bitmap->Width = width;
            frmRecipeSet->imRightCCD->Picture->Bitmap->Height = height;
            usb_ImageROIAry[no].SetPlacement(0,0,width,height);
         }
         else {
            // 要設Size
            frmRecipeSet->imRightCCD->Picture->Bitmap->Width = w;
            frmRecipeSet->imRightCCD->Picture->Bitmap->Height = h;
            usb_ImageROIAry[no].SetPlacement(x,y,w,h);
         }
         usb_ImageROIAry[no].Draw(frmRecipeSet->imRightCCD->Canvas->Handle);
         frmRecipeSet->imRightCCD->Refresh();
      }
      */
   }

   // Basler Pylon GigE CCD: 計算Capture Rate
   boolBaslerImageLoadedAry[no] = true;
   boolCCDImageLoadedAry[no] = true;
   BaslerCaptureNoAry[no]++;
   if((count % 5) == 0) {
      GetTimeTic(&BaslerStopTimeAry[no],&BaslerStopTickAry[no]);
      BaslerElapsedmsAry[no] = ((BaslerStopTimeAry[no]*1000+BaslerStopTickAry[no]) - (BaslerStartTimeAry[no]*1000+BaslerStartTickAry[no]));
      double ratio;
      AnsiString msg;
      // Devide by zero
      if(BaslerElapsedmsAry[no] != 0) {
         ratio = ((double)BaslerCaptureNoAry[no] * 1000.0) / BaslerElapsedmsAry[no];
         msg.sprintf("%.1f",ratio);
         pnlCapturedNo3->Caption = msg;
      }
   }

   // 未在影像處理中
   boolInGigaBufferAry[no] = false;
   tmISRightCCD->Enabled = true;
   pnlISCCD3Capture->Color = clSilver;
   pnlISCCD3Capture->Refresh();
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::cbWBAutoClick(TObject *Sender)
{
int ccdno;
bool boolwbauto;

   WriteSystemLog("cbWBAutoClick");

   ccdno = combCCDSelect->ItemIndex;
   boolwbauto = cbWBAuto->Checked;
   if(ccdno == CCD_TOP && pnlISCCDStaus->Color == clLime)
      ICImagingControl1->WhiteBalanceAuto = boolwbauto;
   else if(ccdno == CCD_LEFT && pnlISCCD2Staus->Color == clLime)
      ICImagingControl2->WhiteBalanceAuto = boolwbauto;
   else if(ccdno == CCD_RIGHT && pnlISCCD3Staus->Color == clLime)
      ICImagingControl3->WhiteBalanceAuto = boolwbauto;

   if(boolwbauto == false)
      btnWBOneTouch->Enabled = true;
   else
      btnWBOneTouch->Enabled = false;

   WriteSystemLog("cbWBAutoClick Done");

}
//---------------------------------------------------------------------------
void __fastcall TfrnMain::SetCCDProperty()
{

   // Setup CCD後再設定
   if(pnlISCCDStaus->Color == clLime) {
      combCCDSelect->ItemIndex = CCD_TOP;
      rgCCDShutter->ItemIndex = CCDShutterAry[CCD_TOP];
      rgCCDShutterClick(this);
      tbCCDGain->Position = CCDGainAry[CCD_TOP];
      tbContrast->Position = CCDContrastAry[CCD_TOP];
      cbWBAuto->Checked = CCDWBAuto[CCD_TOP];
      frmInspection->cbWBAuto->Checked = cbWBAuto->Checked;
      ICImagingControl1->WhiteBalanceAuto = CCDWBAuto[CCD_TOP];
   }
   if(pnlISCCD2Staus->Color == clLime) {
      combCCDSelect->ItemIndex = CCD_LEFT;
      rgCCDShutter->ItemIndex = CCDShutterAry[CCD_LEFT];
      rgCCDShutterClick(this);
      tbCCDGain->Position = CCDGainAry[CCD_LEFT];
      tbContrast->Position = CCDContrastAry[CCD_LEFT];
      cbWBAuto->Checked = CCDWBAuto[CCD_LEFT];
      ICImagingControl2->WhiteBalanceAuto = CCDWBAuto[CCD_LEFT];
   }
   if(pnlISCCD3Staus->Color == clLime) {
      combCCDSelect->ItemIndex = CCD_RIGHT;
      rgCCDShutter->ItemIndex = CCDShutterAry[CCD_RIGHT];
      rgCCDShutterClick(this);
      tbCCDGain->Position = CCDGainAry[CCD_RIGHT];
      tbContrast->Position = CCDContrastAry[CCD_RIGHT];
      cbWBAuto->Checked = CCDWBAuto[CCD_RIGHT];
      ICImagingControl3->WhiteBalanceAuto = CCDWBAuto[CCD_RIGHT];
   }
   combCCDSelect->ItemIndex = CCD_TOP;
}
//---------------------------------------------------------------------------
// Read Status
bool boolRFIDRead = false;
// 2023 1 4 - chc RFID 8"
// RFID
//#define STX             0x02
//#define ETX             0x03
#define SOH             0x01
#define END             0x0d
// Send
// SOH Node No. Command code Page designation FCS CR
// 01h 01       0100         00000014         05  0Dh
// Response
//SOH Node No. Response code Page 1           Page 3           FCS CR
//01h 01       00            1234567890123456 1122334455667788 07  0Dh
//
AnsiString ReplyStrRFID8 = "";
char Buf8[1024];
int Buf8No = 0;
void __fastcall TfrnMain::ybRFID8CommNotify(TObject *Sender,
      int NotifyType)
{
char Buf[1024+1],c;
AnsiString msg;
int len,pos,n,readno;
bool boolstas = false;
bool boolclearerrorcode = false;

   // 先不管
   //if(NotifyType == EV_RXCHAR) {

      n = 0;
      while(1) {
         readno = ybRFID8->Read(&c,1);
         if(readno == 0)
            break;
         // >10才放入buffer, 否則為Control code
         if(c > 10) {
            Buf8[Buf8No++] = c;
            n++;
         }
         Sleep(1);
      }
      if(Buf8No > 0) {
         pnlRFIDResult->Caption = "None";

         int sno = 0;
         for(int i=0 ; i<Buf8No ; i++) {
            // 0x0d
            //01h 01       00            1234567890123456 1122334455667788 07  0Dh
            if(Buf8[i] == END) {
               if(i == 0) {
                  Sleep(10);
                  continue;
               }
               sno = i;
               int rno = 0;
               for(int j=0 ; j<i ; j++) {
                  if(Buf8[j] > 10) {
                     Buf[rno++] = Buf8[j];
                  }
               }
               Buf[rno] = 0x0;
               msg.sprintf("%s",Buf);
               // Log
               AddRFIDRecvMessage(msg);
               WriteSystemLog("RFID8: " + msg);
               pnlRFIDResult->Caption = msg;

               // 顯示CST ID
               int len = msg.Length();
               AnsiString scode;
               /* Rorze
               // 02200OKEE3Q076156
               // 12345678901234567890
               // 前面7碼是Header, 後面2碼是CheckSum
               // RFID裡面要有OK && len > 15
               if(len > 15 && msg.Pos("OK") > 0) {
                  scode = msg.SubString(8,len-9);
                  pnlCSTCode->Caption = scode;
               }
               WriteSystemLog("RFID8(實際)讀回 " + msg);
               */
               // 01 00 1234567890123456 1122334455667788 07
               // 12 34 5678901234567890 1234567890123456 7890
               len = msg.Length();
               AnsiString scode1,scode2;
               char rbuf[50],tbuf[50];
               rno = 0;
               if(len > 30) {
                  scode1 = msg.SubString(5,16);
                  sprintf(rbuf,"%s",scode1.c_str());
                  for(int i=0 ; i<16 ; i++) {
                     if(rbuf[i] >= 'A')
                        tbuf[i] = rbuf[i] - 'A' + 10;
                     else
                        tbuf[i] = rbuf[i] - '0';
                  }
                  for(int i=0 ; i<16 ; i+=2) {
                     rbuf[rno] = tbuf[i] * 16 + tbuf[i+1];
                     if(rbuf[rno] == 0x0)
                        rbuf[rno] = '*';
                     rno++;
                  }
                  rbuf[rno] = '\0';
                  scode1.sprintf("%s",rbuf);
                  pnlCSTCode->Caption = scode1;
                  //
                  rno = 0;
                  scode2 = msg.SubString(21,16);
                  sprintf(rbuf,"%s",scode2.c_str());
                  for(int i=0 ; i<16 ; i++) {
                     if(rbuf[i] >= 'A')
                        tbuf[i] = rbuf[i] - 'A' + 10;
                     else
                        tbuf[i] = rbuf[i] - '0';
                  }
                  for(int i=0 ; i<16 ; i+=2) {
                     rbuf[rno] = tbuf[i] * 16 + tbuf[i+1];
                     if(rbuf[rno] == 0x0)
                        rbuf[rno] = '*';
                     rno++;
                  }
                  rbuf[rno] = '\0';
                  scode2.sprintf("%s",rbuf);
                  pnlCSTCode2->Caption = scode2;
               }
               boolRFIDRead = true;
            }
         }
         // 012345678901234567890       => 21
         //        S                    => 7
         if(sno > 0) {
            for(int i=0 ; i<Buf8No-sno-1 ; i++)
               Buf8[i] = Buf8[i+sno+1];
            Buf8No -= (sno+1);
         }
      }

   // 先不管
   //}

   pnlRFID->Enabled = true;
   pnlRFIDOperation->Caption = "Idle";
   pnlRFIDOperation->Refresh();
}
//---------------------------------------------------------------------------
void __fastcall TfrnMain::InitRFIDCom()
{

   // 由參數決定COM Port
   pnlSystemMessage->Caption = "啟動RFID12 Com Port...";
   try {
      pnlRFID12->Color = clSilver;
      ybRFID12->Active = false;
      Sleep(200);

      // Baudrate
      if(combRFID12Baudrate->Text == "115200")
         ybRFID12->Baud = ybRFID12->br115200;
      else if(combRFID12Baudrate->Text == "57600")
         ybRFID12->Baud = ybRFID12->br57600;
      else if(combRFID12Baudrate->Text == "38400")
         ybRFID12->Baud = ybRFID12->br38400;
      else if(combRFID12Baudrate->Text == "19200") {
         ybRFID12->Baud = ybRFID12->br19200;
         WriteSystemLog("Robot: 19200");
      }
      else if(combRFID12Baudrate->Text == "9600")
         ybRFID12->Baud = ybRFID12->br9600;

      // 由參數決定COM Port
      ybRFID12->PortNo = combRFID12Comport->ItemIndex+1;
      WriteSystemLog("RFID12: COM" + IntToStr(ybRFID12->PortNo));

      // 1:1: 8/E/1
      // 1:N: 8/N/1
      //ybRFID12->Parity = ybRFID12->ptNoParity;
      //ybRFID12->ByteSize = 8;

      // Parity, DataBit, StopBit
      //ybRFID12->Parity = ybRFID12->ptEvenParity;
      //ybRFID12->ByteSize = 7;
      //ybRFID12->StopBits = ybRFID12->sbOneStopBit;
      //ybRFID12->FlowControl = ybRFID12->fcNone;
      //WriteSystemLog("RFID12: 8N1None");

      // Parity
      //if(cbNoParity->Checked == true)
      //   ybRFID12->Parity = ybRFID12->ptNoParity;
      //else
      //   ybRFID12->Parity = ybRFID12->ptEvenParity;

      ybRFID12->Active = true;
      pnlRFID12->Color = clLime;
      boolRFID12Status = true;
      RobotButton();
   }
   catch(Exception &e) {
      pnlSystemMessage->Caption = "ybRFID12: " + e.Message;
      sbSystem->Panels->Items[1]->Text = "ybRFID12: " + e.Message;
      pnlRFID12->Color = clRed;
      boolRFID12Status = false;
      RFID12Button();
   }
   UpdateRFID12Status();
   pnlSystemMessage->Caption = "啟動RFID12 Com Port.";

   // 由參數決定COM Port
   pnlSystemMessage->Caption = "啟動RFID8 Com Port...";
   try {
      pnlRFID8->Color = clSilver;
      ybRFID8->Active = false;
      Sleep(200);

      // Baudrate
      if(combRFID8Baudrate->Text == "115200")
         ybRFID8->Baud = ybRFID8->br115200;
      else if(combRFID8Baudrate->Text == "57600")
         ybRFID8->Baud = ybRFID8->br57600;
      else if(combRFID8Baudrate->Text == "38400")
         ybRFID8->Baud = ybRFID8->br38400;
      else if(combRFID8Baudrate->Text == "19200") {
         ybRFID8->Baud = ybRFID8->br19200;
         WriteSystemLog("Robot: 19200");
      }
      else if(combRFID8Baudrate->Text == "9600")
         ybRFID8->Baud = ybRFID8->br9600;

      // 由參數決定COM Port
      ybRFID8->PortNo = combRFID8Comport->ItemIndex+1;
      WriteSystemLog("RFID8: COM" + IntToStr(ybRFID8->PortNo));

      // 1:1: 8/E/1
      // 1:N: 8/N/1
      //ybRFID8->Parity = ybRFID8->ptNoParity;
      //ybRFID8->ByteSize = 8;

      // Parity, DataBit, StopBit
      //ybRFID8->Parity = ybRFID8->ptEvenParity;
      //ybRFID8->ByteSize = 7;
      //ybRFID8->StopBits = ybRFID8->sbOneStopBit;
      //ybRFID8->FlowControl = ybRFID8->fcNone;
      //WriteSystemLog("RFID8: 8N1None");

      // Parity
      //if(cbNoParity->Checked == true)
      //   ybRFID8->Parity = ybRFID8->ptNoParity;
      //else
      //   ybRFID8->Parity = ybRFID8->ptEvenParity;

      ybRFID8->Active = true;
      pnlRFID8->Color = clLime;
      boolRFID8Status = true;
      RobotButton();
   }
   catch(Exception &e) {
      pnlSystemMessage->Caption = "ybRFID8: " + e.Message;
      sbSystem->Panels->Items[1]->Text = "ybRFID8: " + e.Message;
      pnlRFID8->Color = clRed;
      boolRFID8Status = false;
      RFID8Button();
   }
   UpdateRFID8Status();
   pnlSystemMessage->Caption = "啟動RFID8 Com Port.";

}
//---------------------------------------------------------------------------
// 2023 1 4 - chc RFID12 Active
void __fastcall TfrnMain::UpdateRFID12Status()
{

   if(boolRFID12Status == true) {
      pnlRFID12->Color = clLime;
   }
   else {
      pnlRFID12->Color = clRed;
   }
}
//---------------------------------------------------------------------------
// boolRFID12Status = false;
void __fastcall TfrnMain::RFID12Button()
{

   btnRFIDSend->Enabled = boolRFID12Status;
   btnRFIDRead->Enabled = boolRFID12Status;
   btnRFIDTest->Enabled = boolRFID12Status;
   rgRFIDLoadPort->Enabled = boolRFID12Status;
}
//---------------------------------------------------------------------------
// 2023 1 4 - chc RFID8 Active
void __fastcall TfrnMain::UpdateRFID8Status()
{

   if(boolRFID8Status == true) {
      pnlRFID8->Color = clLime;
   }
   else {
      pnlRFID8->Color = clRed;
   }
}
//---------------------------------------------------------------------------
// boolRFID12Status = false;
void __fastcall TfrnMain::RFID8Button()
{

   btnRFIDSend->Enabled = boolRFID8Status;
   btnRFIDRead->Enabled = boolRFID8Status;
   btnRFIDTest->Enabled = boolRFID8Status;
   rgRFIDLoadPort->Enabled = boolRFID8Status;
}
//---------------------------------------------------------------------------
//
// 2023 1 4 - chc RFID 12"
// RFID
//#define STX             0x02
//#define ETX             0x03
//#define SOH             0x01
//#define END             0x0d
// Send
// SOH Node No. Command code Page designation FCS CR
// 01h 01       0100         00000014         05  0Dh
//  => FCS: NodeNo ~ Page designation
//  => Page designation: 8Digits, 0007FFFC: 共17Pages, 00000014: 0000 0000 0000 0000 0000 0000 0001 0100 means Page1 & 3
//                                                               0000 0000 0000 0111 1111 1111 1111 1100 neans total page
// Response
//SOH Node No. Response code Page 1           Page 3           FCS CR
//01h 01       00            1234567890123456 1122334455667788 07  0Dh
//
// Response code
//  "00", "Normal End"
//  "14", "Format Error"
//  "70", "Communications Error"
//  "71", "Verification Error "
//  "72", "No Tag Error"
//  "7B", "Outside Write Area Error"
//  "7E", "ID System Error(1)"
//  "7F", "ID System Error(2)"
//
AnsiString ReplyStrRFID12 = "";
char Buf12[1024];
int Buf12No = 0;
void __fastcall TfrnMain::ybRFID12CommNotify(TObject *Sender,
      int NotifyType)
{
char Buf[1024+1],c;
AnsiString msg,setcode;
int len,pos,n,readno;
bool boolstas = false;
bool boolclearerrorcode = false;

   // 先不管
   //if(NotifyType == EV_RXCHAR) {

      n = 0;
      while(1) {
         readno = ybRFID12->Read(&c,1);
         if(readno == 0)
            break;
         // >10才放入buffer, 否則為Control code
         if(c > 10) {
            Buf12[Buf12No++] = c;
            n++;
         }
         Sleep(1);
      }
      if(Buf12No > 0) {
         pnlRFIDResult->Caption = "None";

         int sno = 0;
         for(int i=0 ; i<Buf12No ; i++) {
            // 0x0d
            //01h 01       00            1234567890123456 1122334455667788 07  0Dh
            if(Buf12[i] == END) {
               if(i == 0) {
                  Sleep(10);
                  continue;
               }
               sno = i;
               int rno = 0;
               for(int j=0 ; j<i ; j++) {
                  if(Buf12[j] > 10) {
                     Buf[rno++] = Buf12[j];
                  }
               }
               Buf[rno] = 0x0;
               msg.sprintf("%s",Buf);
               // Log
               AddRFIDRecvMessage(msg);
               WriteSystemLog("RFID12: " + msg);
               pnlRFIDResult->Caption = msg;

               // 顯示CST ID
               int len = msg.Length();
               AnsiString scode;
               /* Rorze
               // 02200OKEE3Q076156
               // 12345678901234567890
               // 前面7碼是Header, 後面2碼是CheckSum
               // RFID裡面要有OK && len > 15
               if(len > 15 && msg.Pos("OK") > 0) {
                  scode = msg.SubString(8,len-9);
                  pnlCSTCode->Caption = scode;
               }
               WriteSystemLog("RFID12(實際)讀回 " + msg);
               */
               // 01 00 1234567890123456 1122334455667788 07
               // 12 34 5678901234567890 1234567890123456 7890
               len = msg.Length();
               AnsiString scode1,scode2,sretcode;
               char rbuf[50],tbuf[50];
               rno = 0;
               if(len > 30) {
                  sretcode = msg.SubString(3,2);
                  if(sretcode == "00")
                     pnlRFIDRet->Caption = "Normal end";
                  else if(sretcode == "14")
                     pnlRFIDRet->Caption = "Format err";
                  else if(sretcode == "70")
                     pnlRFIDRet->Caption = "Communication error";
                  else if(sretcode == "71")
                     pnlRFIDRet->Caption = "Verifaction error";
                  else if(sretcode == "72")
                     pnlRFIDRet->Caption = "No Tag error";
                  else if(sretcode == "7B")
                     pnlRFIDRet->Caption = "Outside write area error";
                  else if(sretcode == "7E")
                     pnlRFIDRet->Caption = "ID sstem error(1)";
                  else if(sretcode == "7F")
                     pnlRFIDRet->Caption = "ID sstem error(2)";
                  scode1 = msg.SubString(5,16);
                  sprintf(rbuf,"%s",scode1.c_str());
                  for(int i=0 ; i<16 ; i++) {
                     if(rbuf[i] >= 'A')
                        tbuf[i] = rbuf[i] - 'A' + 10;
                     else
                        tbuf[i] = rbuf[i] - '0';
                  }
                  for(int i=0 ; i<16 ; i+=2) {
                     rbuf[rno] = tbuf[i] * 16 + tbuf[i+1];
                     if(rbuf[rno] == 0x0)
                        rbuf[rno] = '*';
                     rno++;
                  }
                  rbuf[rno] = '\0';
                  scode1.sprintf("%s",rbuf);
                  pnlCSTCode->Caption = scode1;
                  //
                  rno = 0;
                  scode2 = msg.SubString(21,16);
                  sprintf(rbuf,"%s",scode2.c_str());
                  for(int i=0 ; i<16 ; i++) {
                     if(rbuf[i] >= 'A')
                        tbuf[i] = rbuf[i] - 'A' + 10;
                     else
                        tbuf[i] = rbuf[i] - '0';
                  }
                  for(int i=0 ; i<16 ; i+=2) {
                     rbuf[rno] = tbuf[i] * 16 + tbuf[i+1];
                     if(rbuf[rno] == 0x0)
                        rbuf[rno] = '*';
                     rno++;
                  }
                  rbuf[rno] = '\0';
                  scode2.sprintf("%s",rbuf);
                  pnlCSTCode2->Caption = scode2;
               }
               boolRFIDRead = true;
            }
         }
         // 012345678901234567890       => 21
         //        S                    => 7(20)
         if(sno > 0) {
            for(int i=0 ; i<Buf12No-sno-1 ; i++)
               Buf12[i] = Buf12[i+sno+1];
            Buf12No -= (sno+1);
         }
      }

   // 先不管
   //}

   pnlRFID->Enabled = true;
   pnlRFIDOperation->Caption = "Idle";
   pnlRFIDOperation->Refresh();
}
//---------------------------------------------------------------------------
// RFID
void __fastcall TfrnMain::GetRFIDCheckcode(char *buf,char *code1,char *code2)
{
char c1,c2;
int len;
unsigned char checkcode;

   len = strlen(buf);
   checkcode = 0;
   for(int i=0 ; i<len ; i++) {
      if(i == 0)
         checkcode = buf[i];
      else
         checkcode ^= buf[i];
   }
   // 6F
   c1 = (checkcode & 0xf0) >> 4;
   c2 = (checkcode & 0x0f);
   if(c1 < 10)
      c1 += '0';
   else
      c1 = (c1 - 10) + 'A';
   if(c2 < 10)
      c2 += '0';
   else
      c2 = (c2 - 10) + 'A';
   *code1 = c1;
   *code2 = c2;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::tmActiveSocket2Timer(TObject *Sender)
{
static bool first = true;

   if(pnlSocketConnect2->Color == clLime)
      tmActiveSocket2->Enabled = false;
   else {
      // 先設Close再Active
      csQRCode2->Close();
      pnlSystemMessage->Caption = "與QRCode2自動重連線...";
      AddPerformanceMessage(pnlSystemMessage->Caption);
      Sleep(100);

      // 23, admin, SO1(連線), SO0(斷線)
      if(first == true)
         csQRCode2->Port = 23;

      csQRCode2->Active = true;
   }

   if(first == true) {
      // 1500 => 3000(每3秒重連線)
      tmActiveSocket2->Interval = 3000;
      first = false;

      // 23, admin, SO1(連線), SO0(斷線)
      int cnt = 0;
      while(1) {
         Sleep(100);
         if(pnlSocketConnect2->Color == clLime) {
            SendSocket2("admin");
            Sleep(100);
            SendSocket2("");
            Sleep(100);
            SendSocket2("SO1");
            Sleep(100);
            // 斷線重連
            csQRCode2->Active = false;
            csQRCode2->Port = QRCodePort2;
            csQRCode2->Active = true;
            break;
         }
         cnt++;
         if(cnt > 20) {
            WriteSystemLog("QRCode2 Port 23設定失敗!");
            // 斷線重連
            csQRCode2->Active = false;
            csQRCode2->Port = QRCodePort2;
            csQRCode2->Active = true;
            break;
         }
      }
   }
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::pnlSocket2Click(TObject *Sender)
{
bool connect;

   pnlSocket2->Color = clSilver;
   pnlSocket2->Enabled = false;

   pnlSocket2->Enabled = true;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnSend2Click(TObject *Sender)
{
int no;
char buf[100];

   btnSend2->Enabled = false;
   sprintf(buf,"%s",edSocket2->Text.c_str());
   SendSocket2(buf);
   pnlMessage->Caption = "送出" + edSocket2->Text;
   WriteSystemLog(pnlMessage->Caption);
   AddMessage2(pnlMessage->Caption);
   btnSend2->Enabled = true;
   return;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnReady2Click(TObject *Sender)
{

   pnlVersionClick(this);
   return;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::btnQRCodeRead2Click(TObject *Sender)
{
int no;
char buf[100];

   btnQRCodeRead2->Enabled = false;

   edSocket2->Text = "READ";
   btnSend2Click(this);

   btnQRCodeRead2->Enabled = true;
}
//---------------------------------------------------------------------------

void __fastcall TfrnMain::csQRCode2Connect(TObject *Sender,
      TCustomWinSocket *Socket)
{

   btnSend2->Enabled = true;
   pnlSocketConnect2->Color = clLime;
   //pnlQRCodeConnect2->Color = clLime;
   AddMessage2("Socket2連線.");

   // 啟動心跳包
   tmStatus2->Enabled = true;
}
//---------------------------------------------------------------------------
void __fastcall TfrnMain::csQRCode2Disconnect(TObject *Sender,
      TCustomWinSocket *Socket)
{

   btnSend2->Enabled = false;
   pnlSocketConnect2->Color = clSilver;
   //pnlQRCodeConnect2->Color = clSilver;

   tmActiveSocket2->Enabled = true;
   AddMessage("Socket2斷線.");

   // 取消心跳包
   tmStatus2->Enabled = false;
}
//---------------------------------------------------------------------------

void __fastcall                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      